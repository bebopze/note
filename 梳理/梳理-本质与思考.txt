1、static

    static的本质是不依赖对象（this）

    用法：
        不想创建对象的情况下，调用某个方法          ->  static fun()

        不想创建对象的情况下，初始化某个成员变量     ->  static field


2、你有没有发现，在数据量比较小的情况下，
    Redis 中的很多数据类型，比如字典、有序集合等，都是通过多种数据结构来实现的，为什么会这样设计呢？
    用一种固定的数据结构来实现，不是更加简单吗？

    redis的数据结构由多种数据结构来实现，主要是出于时间和空间的考虑，当数据量小的时候通过数组下标访问最快、占用内存最小，而压缩列表只是数组的升级版；
    因为数组需要占用连续的内存空间，所以当数据量大的时候，就需要使用链表了，同时为了保证速度又需要和数组结合，也就有了散列表。
    对于数据的大小和多少采用哪种数据结构，相信redis团队一定是根据大多数的开发场景而定的。


3、我们讲到数据结构持久化有两种方法。对于二叉查找树这种数据结构，我们如何将它持久化到磁盘中呢？

    二叉查找树的存储，
    我倾向于存储方式一，通过填充叶子节点形成完全二叉树，然后以数组的形式存储到硬盘，数据还原过程也是非常高效的。
    如果用存储方式二就比较复杂了。



4、见过最好的抽象

    AbstractQueuedSynchronizer


5、SPI

    本地 服务发现 机制          -> 基于 本地配置文件                    ==>    接口A  ->  实现A2


6、enum

    语法糖                                 - https://blog.csdn.net/weixin_33834137/article/details/93866226


    class IEnum {
        PASS(1, "通过"),
        BACK(2, "打回");

        private int type;
        private String desc;
    }

    final class IEnum extend Enum {
        public static final IEnum PASS;
        public static final IEnum BACK;

        private final int type;
        private final String desc;

        IEnum[] values();

        ...
    }


7、CPU密集、I/O密集

    CPU密集      ->      CPU操作          ->  飞快                // 瞬间执行ok

    I/O密集      ->      IO读写操作       ->  慢到 - 阻塞          // 1cpu -> 10W+级 IO


8、同步/异步、阻塞/非阻塞

    自行体会：

        同步/异步        方法

        阻塞/非阻塞      线程


9、并行/并发

    并行      ->      同时
    并发      ->      交替


    普通解释：
        并行：同时  做不同事情  的能力
        并发：交替  做不同事情  的能力


    专业术语：
        并行：不同的代码块   同时执行
        并发：不同的代码块   交替执行


10、单体、SOA、微服务

    单体        商城系統

    SOA         财务/订单/物流/用户  系统

    微服务      用户/支付/...        服务



11、集群、分布式、主从（主备）

    集群（扩容）     ->      功能一致（多实例部署 - 负载均衡）        // 同一业务  ->  部署多份实例（配合负载均衡 -> 分担流量压力）

    分布式          ->      去中心化（分区存储）                    // 业务拆分、数据分散存储


    主从（主备）     ->      高可用（leader-follower）              // 同步更新 -> 可用性问题   、   异步更新 -> 一致性问题



12、服务扩展

    单体应用            // 全流程

        扩展      ->      应用级别（所有服务耦合在一起）


    分布式应用         // 单一职责

        服务拆分（微服务架构）   ->   各自 只做自己擅长的    ->     多个系统协同合作，完成一个特定任务的系统

        扩展     ->       单一服务级别（流量压力大的服务）



    扩容：

        集群   ->   加机器（相同实例  部署多份）    ->      配合负载均衡 - 分担请求压力


    ----------------------------------------------------------------
    将一套系统拆分成不同子系统，部署在不同服务器上         这叫  分布式
    然后部署多个相同的子系统在不同的服务器上               这叫  集群

    部署在不同服务器上的同一个子系统                      需要做 负载均衡



13、Java并发、DB并发

    Java并发      CPU/内存           写 -> 锁            读 -> 锁

    DB并发        IO设备（磁盘）      写 -> 锁            读 -> 隔离级别       // 读-已提交 / 快照读


    MySQL 依然是 通过锁 ->  来保证线程安全的

        写数据  ->  需要获取 写锁             ===>   行锁/间隙锁、  甚至 -> 表锁/锁库

        读数据  ->  也是需要获取 读锁         ===>    读写互斥时 -> 可能拿不到读锁   =>   Thread会阻塞        // 本质上和 Java多线程操作 一模一样




14、MySQL 事务隔离级别 与 锁 的关系                                     - https://www.cnblogs.com/wuzhiyuan/p/13839252.html

    事务的隔离级别：

        DB中 N个事务的可见性问题   ->  Java中 N个线程的可见性

        事务的安全性问题  ->  多个事务 并发操作(读/写) 同一个数据




        Thread -> 事务

            1个线程    ->    1个事务    =>    读/写  ->  读/写锁  ->  阻塞/唤醒

            N个线程    ->    N个事务    =>    读/写  ->  读/写锁  ->  阻塞/唤醒


        -------------------------------------------------------
                                脏读      不可重复读       幻读
        Read uncommitted	     √	        √	          √
        Read committed	         ×	        √	          √
        Repeatable read	         ×	        ×	          √
        Serializable	         ×	        ×	          ×


    独占锁（X锁）：

        1、独占锁也叫排他锁，该锁 一次只能被 一个线程所持有

        2、线程T对数据A 加上排他锁后  ->  则其他线程 不能再对数据A 加任何类型的锁

        3、获得排它锁的线程  ->  既能读数据，又能修改数据


    共享锁（S锁）：

        1、该锁可被多个线程所持有

        2、线程T对数据A 加上共享锁后  ->  则其他线程只能对A再加共享锁，不能加排它锁

        3、获得共享锁的线程  ->  只能读数据，不能修改数据



    ------------------------------------------------------------------------------------------
    Read uncommitted

        1、Mysql设置Read uncommitted隔离级别  ->  数据库在修改（update）数据时，使用的是  ->  共享锁

            所以在修改数据未提交事务时，查询（select）语句是能查到此时修改的数据

            如果回滚了修改的数据，则查询到的数据是有问题的，造成了脏读

            该隔离级别下：

                1、查询  ->  不加锁

                2、主要涉及到的是共享锁


    Read committed

        数据库在修改数据时，使用的是独占锁

        查询数据使用的是共享锁

        所以在修改数据时执行查询，查询数据会等待修改数据事务提交后，执行查询并返回提交后的结果


    Repeatable read

        Mysql默认的隔离级别，加锁情况同Read committed

        但是Repeatable read在读取数据后，不会立即释放共享锁，而是要等到事务结束后才会释放


    Serializable

        直接对操作的表加表锁，其他事务不能读写该表，效率比较低






15、String、string-pool

    字符串常量池     ->     "缓存"          // "享元模式"  ->  不变 + 共享  ==>  节省内存


    --------------------------------------------------------------------------------------------------------------------
    String两种赋值方式：

        1、引用类型 赋值方式                         // 堆     ->     新建

            String str_1 = new String("abc");

                1、在堆中 创建String对象，在构造函数中 -> 传入value字段的值 -> "abc"    返回String对象的堆地址引用
                2、将 堆地址引用  赋值给  变量str_1




        2、“基本类型” 赋值方式                       // string-pool（字符串常量池）  ->  缓存

            String s_1 = "abc";

                1、在 string-pool（字符串常量池） 中"查缓存"   ==>   有 -> 返回引用   /  无 -> 创建"abc"对象，返回引用
                2、将 常量池中的引用  -->  赋值给 变量s_1


    --------------------------------------------------------------------------------------------------------------------
    str_1.intern();                 // 堆 -> 字符串缓冲池

        1、在 string-pool（字符串常量池） 中"查缓存"
            有 -> 返回 常量池引用
            无 -> 将 堆中对象str_1  copy一份到  string-pool（字符串常量池）


