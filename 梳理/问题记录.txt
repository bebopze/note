1、消息稳定性问题（三方消息中间件不可靠、崩溃问题）

    其实，就是对消息做持久化备份                                      // 消息中间件一般都有这种能力哈🤣
    本地做消息日志，崩溃重启读取log能恢复（借鉴innoDB的redo log）

    自己做的话，
    可以存一份在内存(队列)中，开启异步线程刷到Redis、DB、文件中，作为备份log.
    如果遇到崩溃，读取本地备份log恢复.


2、消息重复消费问题
    给每个消息一个唯一ID（一般为具体业务的唯一ID，如：订单号order_id）
    每次消费前，check一下msg_id是否已消费过，是则直接丢弃.


3、消息中间件有qps限制，且远小于我们业务流量（业务流量_qps_2000 > mq_qps_1000）

    1、最简单的，当然是看能否直接提升中间件的性能，来提高qps限制      // 简单粗暴，加钱堆机器...  有钱任性，适合土豪玩家

    2、本地削峰，本地维护一个一级队列做流量缓冲，消息先入本地队列，然后再开启一个线程，从本地内存异步刷到MQ中.

        当然，重要业务，考虑自身系统也会崩溃的话，同样需要做消息的持久化备份了.

    3、流量前置拦截，网关层做限流，从源头截断.


4、什么时候，会考虑开始优化性能

    1、不管什么时候，首要的，必须优先保证业务的正确性。
        至于优化，不能为了优化而优化。
        不能业务都还没开始用，就考虑要优化了，那只能说是一开始设计的就不合理，没理解需求，或需求变化过大...

    2、最好的方式，依然是把问题控制在源头

        具体的，如果是SQL查询变慢的话，
        前期表结构一定要设计的合理，表设计烂了，后期再怎么优化都很难搞...
        查询优化的点：join的表要尽量的少、返回的字段尽量的少、where的条件尽量的少、排序字段尽量的少、尽量使用默认排序、建立正确的索引...


    3、上线前的压测，根据业务方的使用场景和性能要求，提前做数据的预估与压测.

    4、流量保护，预警和拦截


5、数据库表设计规范

    1、三大范式...

    2、but，外键约束这个在现代化大数据量的场景下，一般是不设置外键约束的，都是在业务层保证数据的关联关系.
        用innoDB的事务，来保证数据的正确性.

    3、根据业务实体，来创建表

    4、关联关系用被关联表的主键id表示

    ...


6、缓存一致性问题

    缓存数据，只保证最终一致性。
    把数据放到缓存里，就默认了会存在数据不一致的问题.

    没有绝对完美的方案，都是根据利弊做取舍，来找一个最优解.
    解决一个问题的时候，一定会带来新的问题.

    想保证准确性，就一定会牺牲性能；
    要保证高性能，就一定会牺牲准确性.
    要保证数据的百分百准备，那就只能用关系型数据库，MySQL、Oracle...

    说白了，这就是两个系统之间的数据同步问题.


    TODO 无非是怎么保证缓存数据更新的一个问题



7、关于异常宕机（断电、系统异常、内存溢出...）的保险措施

    其实，一般也就是 定期（如：每半小时）的持久化到磁盘，系统异常重启后，从磁盘读取最近的备份数据到内存，最多也就丢失小部分（如：半小时）数据.


8、接口的格式

    1、Dubbo           这样的 RPC  接口
    2、Spring Cloud    这样的 HTTP 接口


9、BeanUtils.copyProperties

    org.springframework.beans

        BeanUtils.copyProperties(source, target);

        // 浅拷贝                  - source 中包含 引用对象 的 慎用！！！

            基本类型 -> 值拷贝

            引用类型 -> 地址值拷贝


    org.apache.commons.beanutils.BeanUtils

        BeanUtils.copyProperties(target, source);

        // 浅拷贝          同上

            且 Date、BigDecimal 转换异常




10、what（是什么）、why（为什么）、how（怎么办）、where（应用场景）



11、并发工具类模块

    最佳实践：

        1、while(true) 总不让人省心

        2、signalAll() 总让人省心

        3、Semaphore 需要锁中锁

        4. 锁的申请和释放要成对出现

        5. 回调总要关心执行线程是谁

        6. 共享线程池：有福同享就要有难同当

        7. 线上问题定位的利器：线程栈 dump

        8. 所有的阻塞操作，都需要设置超时时间



12、StringBuilder 、StringBuffer

    安全不安全  没必要去记类名

        用的时刻 点进来看看 谁加了同步即可     synchronized  --->  StringBuffer


13、实现一个具备不可变性的类

    1、将一个类 所有的属性 都设置成 final 的，并且 只允许存在 只读方法，那么这个类基本上就具备不可变性了

    2、更严格的做法是这个 类本身 也是 final 的，也就是不允许继承

        因为子类可以覆盖父类的方法，有可能改变不可变性，所以推荐你在实际工作中，使用这种更严格的做法


    三点：
        1、类           final
        2、所有 属性     final
        3、所有 方法     只读


14、函数式编程

    Copy-on-Write模式

        函数式编程 的基础是 不可变性（Immutability）

        所以 函数式编程 里面所有的修改操作 都需要 Copy-on-Write 来解决


15、