1、结构

AQS

    待重写方法 -> 空实现                         // throw new UnsupportedOperationException()   ->   子类 选择性实现

        tryAcquire()                           // 独占式获取同步状态，试着获取，成功返回true，反之为false
        tryRelease()                           // 独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；

        tryAcquireShared()                     // 共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；
        tryReleaseShared()                     // 共享式释放同步状态，成功为true，失败为false


        isHeldExclusively()                    // 是否在独占模式下被线程占用


    Condition



========================================================================================================================
独占锁

    实现  ->  tryAcquire()、tryRelease()

共享锁

    实现  ->  tryAcquireShared()、tryReleaseShared()




========================================================================================================================
自定义同步器  ->  AQS模板方法  ->  重写方法

    ------------------------------------------------------------------------------------------
    1、 tryAcquire()、tryRelease()


        MyLock   ->   lock / tryLock / tryLock(time) / lockInterruptibly

            AQS   ->   acquire / tryAcquireNanos / acquireInterruptibly         // 模板方法

                sync   =>   tryAcquire()                                        // 重写方法

        ---------------------------------------
        MyLock   ->   unlock

            AQS   ->   release

                sync   =>   tryRelease()


    ------------------------------------------------------------------------------------------
    2、 tryAcquireShared()、tryReleaseShared()


        MyLock   ->   lock / tryLock / tryLock(time) / lockInterruptibly

            AQS   ->   acquireShared / tryAcquireSharedNanos / acquireSharedInterruptibly           // 模板方法

                sync   =>   tryAcquireShared()                                                      // 重写方法

        ---------------------------------------
        MyLock   ->   unlock

            AQS   ->   releaseShared

                sync   =>   tryReleaseShared()



    --------------------------------------------------------------------------------
    isHeldExclusively()         // 是否在独占模式下被线程占用  ->  独占模式 + 占用锁资源

        MyLock.isLocked       ->   sync.isHeldExclusively


------------------------------------------------------------------------------------------
Condition

    MyLock.newCondition   ->   sync.newCondition



========================================================================================================================

    volatile int state;     // 共享变量  ->  同步状态


    CLH（Craig Landin Hagersten -> 人名）队列         // FIFO双端同步队列  ->  基于Node 双向链表   ->   通过内置的FIFO队列 来完成获取资源线程的排队工作

        1、FIFO双端同步队列   ->   公平队列

        2、基于Node 双向链表


    阻塞同步：

        1、获取资源fail  =>  当前线程被构造成一个Node  ->  addQueue

        2、当前线程 被阻塞在队列中  =>  通过LockSupport.park实现   ->   其实是等待态

        3、释放锁（同步状态）  =>  唤醒后继Node  ->  此Node继续加入到对 同步状态（锁） 的争夺中



========================================================================================================================
Node

    static final Node SHARED = new Node();          // 共享式  Node模式标识   ->   new Node()
    static final Node EXCLUSIVE = null;             // 独占式  Node模型标识   ->   null



    volatile  Node prev
    volatile  Node next

    volatile  Thread thread          // 与当前Node 关联的 排队中的Thread



    volatile int waitStatus = 0         // 等待状态  ->  初始值 0

        CANCELLED  =  1      ->      线程已被取消   ->   等待超时或者被中断

        SIGNAL     = -1      ->      后继线程需要被唤醒（unpaking）

        CONDITION  = -2      ->      结点线程等待在Condition上   ==>   当被signal后  =>  会从  等待队列 -> 同步队列

        PROPAGATE  = -3      ->      下一次共享式同步状态  会被无条件地传播下去



========================================================================================================================
acquire()  ->  获取 同步状态（锁）

    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();

    -----------------------------------------------------------
        if (tryAcquire()) {
            return;
        }

        if (acquireQueued(addWaiter(Node.EXCLUSIVE), arg))) {
            selfInterrupt();
        }

    -------------------------------------------------------------------------
    1、非阻塞方式获取锁   =>   调用重写的 tryAcquire()     ->  获取 同步状态（锁）

        1、获取 同步状态（锁）成功  ->  直接返回

        2、获取 同步状态（锁）失败  ->  构建 独占式Node，加入同步队列

            加入同步队列 后  =>  给 当前Thread  ->  设置中断标识

========================================================================================================================
tryAcquireNanos

    ----------------------------------------------------------------
    final boolean tryAcquireNanos(int arg, long nanosTimeout) {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);
    }

    ----------------------------------------------------------------
    1、检测线程是否中断   =>  是 -> 抛出异常

    2、先尝试用 常规非阻塞方式 - tryAcquire()，获取一次 同步状态（锁）

    3、尝试获取失败   ->  再走 超时模式   ->   获取 同步状态（锁）

        超时  ->  自旋重试  +  time校验


========================================================================================================================
release

    ----------------------------------------------------------------
    final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0) {
                unparkSuccessor(h);
            }
            return true;
        }
        return false;
    }

    -----------------------------------------------------------------------------------------------
    1、调用重写的 tryRelease()     ->  释放 同步状态（锁）    ->  释放失败 返回false     // 释放锁

    2、拿到队列 头Node，如果队列不为空  ->  唤醒 节点后继者                              // 唤醒 等待线程




========================================================================================================================
acquireSharedInterruptibly




========================================================================================================================
tryAcquireShared


========================================================================================================================
releaseShared



