------------------------------------------------------------------------------------------------------------------------
并发
------------------------------------------------------------------------------------------------------------------------
    功能：  高效、正确    的并发


    高效：

        多线程

        线程池

        异步




    正确：

        可见性、volatile

        happens-before

        CAS


        管程模型、信号量模型

        条件变量

        synchronized  ->  锁升级

        AQS

            Lock    ->  非阻塞、可中断、可超时

            重入锁

            读写锁

            StampedLock

            同步器 -> CountDownLatch、CyclicBarrier

            Semaphore



        并发容器

        原子类


------------------------------------------------------------------------------------------------------------------------
Collection

    List

    Set

    Map

    Queue

------------------------------------------------------------------------------------------------------------------------
IO
------------------------------------------------------------------------------------------------------------------------

    BIO、NIO、AIO

    多路复用机制（select、poll、epoll）

    线程模型

        线程池 + 阻塞IO

        线程池 + 非阻塞IO             // read、write 同步


    非阻塞IO

        未就绪 -> 不阻塞 -> 轮询获取就绪态   ->  read、write 仍为  同步调用


    真正 - 非阻塞IO

        就绪态 非轮询 ->  异步回调通知 就绪  ->  read、write 异步调用（子线程 执行 -> OS 子线程 实现） ->  回调通知 r/w 结果


    零拷贝     mmap、sendfile   ->  内核 ⇄ 用户


------------------------------------------------------------------------------------------------------------------------
数据结构与算法
------------------------------------------------------------------------------------------------------------------------

    数据结构：存    ->   高效存   ->    空间复杂度

             取    ->  高效查    ->    时间复杂度



    ---------------------------------------------------
    基础数据结构

        数组

        链表


    变体： 数组、链表  的各种组合

        栈

        队列

        树

            二叉树、多叉树

            二叉查找树

            平衡二叉查找树

                红黑树

                堆

                B+树


        跳表


        图（三维、多维）



    ---------------------------------------------------
    算法：

        排序
            插入、冒泡、选择    ->  O(n²)
            快排、归并         ->  O(nlogN)
            桶、计数、基数      ->  O(n)


            分治
                分解 + merge          递归 merge（拆分 + 比较 + 合并） 到不能再分
                分解 + partition      递归 partition（拆分 + 比较） 到不能再分

            分区点
                随机、三数取中

            原地

            稳定


            Arrays.sort

                基础数据类型
                    双轴快排
                        47   ->  插入
                        286  ->  快排    中点、1/7、2/7    =/!=   单/双 轴
                        > 286  ->  趋近有序    -> 归并
                                   无序        -> 快排

                引用类型
                    归并   ->   TimSort    ->  归并的优化版    --> 插入、快排、归并



        递归

        二分查找

            有序  ->  O(logN)

            内存有限

        哈希

            hash表

            密码

            文件内容完整性     ->  迅雷下载、blockchain


        贪心

        并行



------------------------------------------------------------------------------------------------------------------------
MySQL
------------------------------------------------------------------------------------------------------------------------

    功能：存、取

        高效存 -> redo log

            Server层、引擎层、InnoDB 引擎

            写日志快、写磁盘慢、  异步存盘

            redo log

            binlog

            两阶段提交

            crash-safe

            事务

            undo log

            隔离：  视图、版本追溯






        高效取 -> 索引

            高效查 数据结构选取

            二叉树、N叉树、B+树  ->  树高 = IO次数

            索引模型

            索引类型

            索引在B+树中的存储结构

            回表

            索引维护

            索引大小、N的大小、页的大小、树高









    -------------------------------------------------------------------
    首要功能 存储，高效存     ->  redo log        异步存盘

    但是不是简单的存储
    我们还要查，高效查       ->  索引



    1、redo log

        ....



    2、索引

        ....

        除了 数据结构化 方便了查询
        在说到高效检索方面，那就是索引了
        MySQL里面也是用索引来实现高效查
        索引在引擎层实现，由每种引擎各自实现，无统一规范，相同数据结构的索引，实现也完全不同



------------------------------------------------------------------------------------------------------------------------
JVM
------------------------------------------------------------------------------------------------------------------------


    -----------------------
    编译

        运行
            .java   ->  .class  ->  机器码


        编译器

            解释执行                ->  同声传译

                当前线程
                一个语句

            即时编译                ->  全文翻译

                C1、C2、Graal         // Client、Server
                额外线程
                一个方法
                运行时信息 -> 优化

            混合模式

                解释执行 + 即时编译

                二八法则    ==>  热点代码 -> 即时编译（运行时信息 -> 优化）


    -----------------------
    类加载

        .class  ->   方法区


        字节流   ->    JVM Java类

    -----------------------
    异常

        异常实例的构造十分昂贵
            记录栈轨迹   ->  逐一访问 当前线程-栈帧，记录各种调试信息（类、方法、行）


        Throwable
            Error                       无法恢复        ->      终止 线程、虚拟机
            Exception                   需要捕获处理
                RuntimeException        可以抢救一下


    -----------------------
    反射

        获取、修改  Java对象 运行时信息

        应用：
            IDE自动提示
            Spring IOC

        开销大
            校验                       ->  方法可见性、参数校验
            基本类型参数  拆装箱         ->  Object[] arg
            无法优化                    ->  无法  方法内联、JIT编译优化



    -----------------------
    Java对象 的 内存


    -----------------------
    JVM的内存管理

        内存分布
            堆、方法区 、 栈(java/native)、PC计数器

        GC -> 堆内存

            找垃圾
                引用计数
                可达性分析

            回收垃圾
                标记-清除        碎片
                复制            空间利用率低
                标记-整理        慢  ->   性能开销较大

            回收线程
                串行
                    Serial          ->      单核、小内存(100M)应用
                并行
                    Parallel        ->      多核 + 无响应时间要求（后台任务、科学计算）
                并发
                    CMS、G1、ZGC     ->      多核 + 快速响应（互联网应用、电信）

            分代回收
                二八法则    ->  新生代（Eden + Survivor[from/to]）  +  老年代

            分代GC

                部分GC（Partial GC）

                    Young GC    ->  仅 新生代               ==>  Minor GC

                    Old   GC    ->  仅 老年代               ->  CMS - 并发模式

                    Mixed GC    ->  新生代 + 部分-老年代     ->  G1


                完全GC（Full GC）

                    整个堆       ->    新生代  +  老年代  +  方法区（如果存在）


            ---------------------------
            一般意义上的GC

                Minor GC

                    新生代              ->      复制算法

                    频繁  ->  快速回收

                    快    ->  大部分对象 都是垃圾   ==>  需要复制的对象 很少

                    ----------------------
                    TLAB（申请堆内存   ->   线程共享   ->   并发安全问题）

                    卡表（老年代  ->  指向 新生代的对象   ===>  卡表维护 脏卡  ->  不用扫描 整个老年代）


                Full GC

                    全堆 + 方法区        ->      标记-整理

                    触发频率低

                    慢   ->  全堆扫描


    -----------------------
    Java内存模型

        as-if-serial 的保证

        多线程   ->   同步


        --------------------
        happens-before

            结果串行

            传递性

            volatile

            锁


            线程start

            线程join

            构造器


        --------------------
        JMM 实现

            内存屏障  ->  禁止重排序（编译优化）


    -----------------------
    Java字节码

        字节码注入       ==>  AOP   AspectJ（静态代理 - 编译器）  /   JDK(接口)/Cglib(类)（动态代理 - 运行期）

    -----------------------
    方法内联

        提高方法嵌套调用的  变量、返回值等 中间态的维护成本

    -----------------------
    intrinsic

    -----------------------
    逃逸分析


    -----------------------
    代码优化

        字段访问相关优化

        循环优化            ->  不相干code 循环外提  、 步数+  、 分支

        向量化

        注解处理器          =>  注解(标签) 的语义实现   -> 编译规则、编辑/生成 源代码

        JVM监控诊断 工具

        JNI

        Java Agent与字节码注入



















