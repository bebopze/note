------------------------------------------------------------------------------------------------------------------------
并发
------------------------------------------------------------------------------------------------------------------------
    功能：  高效、正确    的并发


    高效：

        多线程

        线程池

        异步




    正确：

        可见性、volatile

        happens-before

        CAS


        管程模型、信号量模型

        条件变量

        synchronized  ->  锁升级

        AQS

            Lock    ->  非阻塞、可中断、可超时

            重入锁

            读写锁

            StampedLock

            同步器 -> CountDownLatch、CyclicBarrier

            Semaphore



        并发容器

        原子类


------------------------------------------------------------------------------------------------------------------------
Collection

    List

    Set

    Map

    Queue

------------------------------------------------------------------------------------------------------------------------
IO
------------------------------------------------------------------------------------------------------------------------

    BIO、NIO、AIO

    多路复用机制（select、poll、epoll）

    线程模型

        线程池 + 阻塞IO

        线程池 + 非阻塞IO             // read、write 同步


    非阻塞IO

        未就绪 -> 不阻塞 -> 轮询获取就绪态   ->  read、write 仍为  同步调用


    真正 - 非阻塞IO

        就绪态 非轮询 ->  异步回调通知 就绪  ->  read、write 异步调用（子线程 执行 -> OS 子线程 实现） ->  回调通知 r/w 结果


    零拷贝     mmap、sendfile   ->  内核 ⇄ 用户


------------------------------------------------------------------------------------------------------------------------
数据结构与算法
------------------------------------------------------------------------------------------------------------------------

    数据结构：存    ->   高效存   ->    空间复杂度

             取    ->  高效查    ->    时间复杂度



    ---------------------------------------------------
    基础数据结构

        数组

        链表


    变体： 数组、链表  的各种组合

        栈

        队列

        树

            二叉树、多叉树

            二叉查找树

            平衡二叉查找树

                红黑树

                堆

                B+树


        跳表


        图（三维、多维）



    ---------------------------------------------------
    算法：

        排序
            插入、冒泡、选择    ->  O(n²)
            快排、归并         ->  O(nlogN)
            桶、计数、基数      ->  O(n)


            分治
                分解 + merge          递归 merge（拆分 + 比较 + 合并） 到不能再分
                分解 + partition      递归 partition（拆分 + 比较） 到不能再分

            分区点
                随机、三数取中

            原地

            稳定


            Arrays.sort

                基础数据类型
                    双轴快排
                        47   ->  插入
                        286  ->  快排    中点、1/7、2/7    =/!=   单/双 轴
                        > 286  ->  趋近有序    -> 归并
                                   无序        -> 快排

                引用类型
                    归并   ->   TimSort    ->  归并的优化版    --> 插入、快排、归并



        递归

        二分查找

            有序  ->  O(logN)

            内存有限

        哈希

            hash表

            密码

            文件内容完整性     ->  迅雷下载、blockchain


        贪心

        并行



------------------------------------------------------------------------------------------------------------------------
MySQL
------------------------------------------------------------------------------------------------------------------------

    功能：存、取

        高效存 -> redo log

            Server层、引擎层、InnoDB 引擎

            写日志快、写磁盘慢、  异步存盘

            redo log

            binlog

            两阶段提交

            crash-safe

            事务

            undo log

            隔离：  视图、版本追溯






        高效取 -> 索引

            高效查 数据结构选取

            二叉树、N叉树、B+树  ->  树高 = IO次数

            索引模型

            索引类型

            索引在B+树中的存储结构

            回表

            索引维护

            索引大小、N的大小、页的大小、树高









    -------------------------------------------------------------------
    首要功能 存储，高效存     ->  redo log        异步存盘

    但是不是简单的存储
    我们还要查，高效查       ->  索引



    1、redo log

        ....



    2、索引

        ....

        除了 数据结构化 方便了查询
        在说到高效检索方面，那就是索引了
        MySQL里面也是用索引来实现高效查
        索引在引擎层实现，由每种引擎各自实现，无统一规范，相同数据结构的索引，实现也完全不同



------------------------------------------------------------------------------------------------------------------------
JVM
------------------------------------------------------------------------------------------------------------------------


    -----------------------
    编译

        运行
            .java   ->  .class  ->  机器码


        编译器

            解释执行                ->  同声传译

                当前线程
                一个语句

            即时编译                ->  全文翻译

                C1、C2、Graal         // Client、Server
                额外线程
                一个方法
                运行时信息 -> 优化

            混合模式

                解释执行 + 即时编译

                二八法则    ==>  热点代码 -> 即时编译（运行时信息 -> 优化）


    -----------------------
    类加载

        .class  ->   方法区


        字节流   ->    JVM Java类

    -----------------------
    异常

        异常实例的构造十分昂贵
            记录栈轨迹   ->  逐一访问 当前线程-栈帧，记录各种调试信息（类、方法、行）


        Throwable
            Error                       无法恢复        ->      终止 线程、虚拟机
            Exception                   需要捕获处理
                RuntimeException        可以抢救一下


    -----------------------
    反射

        获取、修改  Java对象 运行时信息

        应用：
            IDE自动提示
            Spring IOC

        开销大
            校验                       ->  方法可见性、参数校验
            基本类型参数  拆装箱         ->  Object[] arg
            无法优化                    ->  无法  方法内联、JIT编译优化



    -----------------------
    Java对象 的 内存


    -----------------------
    JVM的内存管理

        内存分布
            堆、方法区 、 栈(java/native)、PC计数器

        GC -> 堆内存

            找垃圾
                引用计数
                可达性分析

            回收垃圾
                标记-清除        碎片
                复制            空间利用率低
                标记-整理        慢  ->   性能开销较大

            回收线程
                串行
                    Serial          ->      单核、小内存(100M)应用
                并行
                    Parallel        ->      多核 + 无响应时间要求（后台任务、科学计算）
                并发
                    CMS、G1、ZGC     ->      多核 + 快速响应（互联网应用、电信）

            分代回收
                二八法则    ->  新生代（Eden + Survivor[from/to]）  +  老年代

            分代GC

                部分GC（Partial GC）

                    Young GC    ->  仅 新生代               ==>  Minor GC

                    Old   GC    ->  仅 老年代               ->  CMS - 并发模式

                    Mixed GC    ->  新生代 + 部分-老年代     ->  G1


                完全GC（Full GC）

                    整个堆       ->    新生代  +  老年代  +  方法区（如果存在）


            ---------------------------
            一般意义上的GC

                Minor GC

                    新生代              ->      复制算法

                    频繁  ->  快速回收

                    快    ->  大部分对象 都是垃圾   ==>  需要复制的对象 很少

                    ----------------------
                    TLAB（申请堆内存   ->   线程共享   ->   并发安全问题）

                    卡表（老年代  ->  指向 新生代的对象   ===>  卡表维护 脏卡  ->  不用扫描 整个老年代）


                Full GC

                    全堆 + 方法区        ->      标记-整理

                    触发频率低

                    慢   ->  全堆扫描


    -----------------------
    Java内存模型

        as-if-serial 的保证

        多线程   ->   同步


        --------------------
        happens-before

            结果串行

            传递性

            volatile

            锁


            线程start

            线程join

            构造器


        --------------------
        JMM 实现

            内存屏障  ->  禁止重排序（编译优化）


    -----------------------
    Java字节码

        字节码注入       ==>  AOP   AspectJ（静态代理 - 编译器）  /   JDK(接口)/Cglib(类)（动态代理 - 运行期）

    -----------------------
    方法内联

        提高方法嵌套调用的  变量、返回值等 中间态的维护成本

    -----------------------
    intrinsic

    -----------------------
    逃逸分析


    -----------------------
    代码优化

        字段访问相关优化

        循环优化            ->  不相干code 循环外提  、 步数+  、 分支

        向量化

        注解处理器          =>  注解(标签) 的语义实现   -> 编译规则、编辑/生成 源代码

        JVM监控诊断 工具

        JNI

        Java Agent与字节码注入





========================================================================================================================
高并发系统设计
========================================================================================================================


------------------------------------------------------------------------------------------------------------------------
基础
------------------------------------------------------------------------------------------------------------------------

高并发、高性能、高可用



------------------------------------------------------------------------------------------------------------------------
数据库
------------------------------------------------------------------------------------------------------------------------

池化技术


数据库优化：

    读   ->  主从（读写）分离

    写   ->  分库分表


发号器：

    Snowflake

    UUID：
        32位 字符串     ->      耗费空间        适用 request_id
        非递增          ->      不利于业务排序
        非有序          ->      B+树有序  ->  利于顺序写

        没有业务含义      ->      某个机房、某个服务


NoSQL

    在高并发场景下，数据库 和 NoSQL 互补

    内存  ==>   高效读        ->   缓存


数据迁移：
    双写
    级联同步





------------------------------------------------------------------------------------------------------------------------
缓存
------------------------------------------------------------------------------------------------------------------------


缓存更新：

    先更新DB  ->  再删除cache

    1、相对安全      ==>     设置较短TTL

    2、绝对安全      ==>     加锁


缓存的高可用：

    实现高可用的核心   ==>   依旧是集群     ->     多个缓存节点，提高容错率


    Client端实现      ->      缓存调用方（非用户端）

        由客户端的策略  ->  决定如何写缓存、如何读缓存
        性能高，但是逻辑复杂，无法跨平台


    Proxy实现

        所有客户端先 -> 访问中间件  ->  然后中间件 决定了缓存策略

        因为引入了中间件
            所以性能较差，但是可以跨平台，并且有能力的公司还可以自研中间件。

    Server端实现

        主从切换  ->  由服务端实现

        最大的缺点是  ->  增加了运维成本


缓存穿透

    1、回种空值

    2、布隆过滤器
        hash表


缓存并发穿透：

    1、分布式锁   ==>   拿到锁的  ->  去DB加载缓存

    2、缓存失效   ->  启动后台线程 ->  到DB 加载cache   ==>  在此之前，此缓存都直接返回null




------------------------------------------------------------------------------------------------------------------------
消息队列
------------------------------------------------------------------------------------------------------------------------

消息队列
    暂时存储数据的一个容器     ==>     平衡  低速系统、高速系统   ->  处理任务 时间差   的一个工具

作用：
    解耦、异步、削峰

新问题：
    复杂性
    可用性
    消息丢失、重复
    消息延迟
    消息顺序
    ...


消息幂等
    生成端         ==>     网络抖动    ->      重发2~3次
    存储端         ==>     kafka ACK机制
    消费端         ==>     msg_id check        ==>   事务问题   ->   加锁、乐观锁、分布式事务



消息延迟

    1、监控

        MQ自带监控个tools / JMX

        特殊消息    ==>     生成时间 、 消费时间  ->  时间差   ==>  消费速率

    2、增加消费者 、 池化 异步消费


    3、高效存储介质 、 零拷贝




------------------------------------------------------------------------------------------------------------------------
分布式服务
------------------------------------------------------------------------------------------------------------------------

分布式   ==>  去中心化（分区存储）




------------------------------------------------------------------------------------------------------------------------
运维
------------------------------------------------------------------------------------------------------------------------

设计模式
基本数据结构与算法、io
并发
MySQL
redis、mq
jvm
分布式、高可用、高并发
微服务、Docker、k8s、DevOps、Service Mesh（跨语言）、云原生（抽象[应用、服务治理] - 统一调度标准）


1、熟练掌握常用设计模式
2、熟练掌握基本数据结构与算法、io
3、熟练掌握并发
4、熟练掌握MySQL
5、熟练掌握Redis、MQ
6、熟练掌握jvm
8、熟练掌握Dubbo、SpringCloud微服务体系
7、熟练掌握分布式、高可用、高并发架构
9、熟悉微服务、容器化、DevOps、云原生体系
10、熟悉Linux常用命令，熟悉Nginx等常用应用的安装搭建与运维



1、熟练掌握常用设计模式、面向对象编程思想，有良好的编程规范              - 创建对象（单例/工厂/Builder）    组合（代理/装饰者/适配器/享元）    交互（观察者）

2、熟练掌握基本数据结构与算法、IO模型                                 - 数组、链表、散列表、红黑树/B+树/跳表  插入、快排/归并   BIO/NIO/AIO、零拷贝

3、熟练掌握并发：JMM、JUC并发包、并发容器、原子类                      - 可见性/有序性/原子性   分工/同步/互斥   线程池/ForkJoinPool（生产-消费）   CAS

4、熟练掌握MySQL：DB引擎、WAL机制、innoDB事务隔离（MVCC）、数据库锁、索引结构、查询优化     - buffer_pool、LRU、回表、索引逻辑删除、数据逻辑删除、数据空洞

5、熟练掌握Redis、MQ、zk                                            - 数据结构、TTL、单/多线程、内存、缓存、Lua   生成-消费、解耦/异步/削峰、幂等、消息丢失
                                                                    分布式监听器（观察者模式）、分布式锁、文件系统、元数据存储、配置中心

6、熟练掌握jvm                           - 堆、方法区(元空间)、栈、PC寄存器（线程切换）   引用计数/可达性分析   标记-清除/标记-复制/标记-整理     young/old、minor GC、full GC

8、熟练掌握Dubbo、SpringCloud微服务体系                              - 提供者/注册中心/消费者、协议、序列化、幂等、分布式事务    网关/认证鉴权/容灾/限流降级/分布式追踪

7、熟练掌握分布式、高可用、高并发架构                                  - 去中心化、分区存储   CAP/ACID/BASE    主从（高可用）   集群（分流）   分库分表（分布式DB）、读写分离(分流)

9、熟悉微服务、容器化、DevOps、云原生体系                             - 单体 -> SOA(系统) -> 微服务(服务 + 治理) -> ServiceMesh（服务 + 代理通信/治理） ->  同一标准（服务治理抽象化 + 应用调用抽象化）

                                                                    自动化运维/发布、   Docker(环境隔离)   、  Docker管理平台（扩缩容） + 监控 +  服务治理


10、熟悉Linux常用命令、熟悉Nginx等搭建与运维                          - cd、 ll/ls、tar -zxvf、rm、 rm -rf、top、 vim/less/more、   history、   ps -ef|grep xx 、 ps aux|grep xx 、kill -9 pid

                                                                    docker pull、docker build、docker images、  docker run、  docker start、docker exec、  docker stop、docker rm、docker rmi



------------------------------------------------------------------------------------------------------------------------
结合起来讲
    1、避免前后重复
    2、避免干巴巴的概念
    3、归根结底 还是应用  有真正的场景

        ------------------------------------------------------------------------
        数据结构
            散列表、红黑树  -  HashMap
            散列表、跳表    -  Redis -> hash、list
            B+树    -  MySQL-索引

        排序算法
            Arrays.sort
                基本类型    插入  、  快排(双分区点)   、 归并(趋近有序) / 快排
                引用类型    二分查找 + 插入排序       、  归并


------------------------------------------------------------------------------------------------------------------------
对比起来讲

    Java并发 VS MySQL并发

        互斥锁 + 条件变量（等待/唤醒）

        锁 + MVCC





------------------------------------------------------------------------------------------------------------------------
1. 熟悉 常用设计模式，具备良好的编程规范，具备良好的面向对象编程思想           // 设计模式 -> 工程经验的总结

    设计模式
        创建型
            单例模式、工厂模式（工厂方法和抽象工厂）、Builder(建造者)模式
            原型模式

        结构型
            代理模式（附加功能）、桥接模式、装饰者模式（增强）、适配器模式（老系统/接口 兼容）
            门面模式、组合模式、享元模式（共享、不可变、节省内存）

        行为型
            观察者模式（发布-订阅）、模板模式、策略模式、职责链模式（处理链 - Filter/Interceptor）、迭代器模式、状态模式
            访问者模式、备忘录模式、命令模式、解释器模式、中介模式

        应用场景
        解决方案


    封装（抽象）、继承、多态



2.熟练掌握 基本数据结构与算法，io模型

    数据结构与算法

        数组、链表

        栈、队列、散列表
        二叉树、堆、跳表
        图、Trie 树


        递归、排序

        二分查找、搜索

        哈希算法、贪心算法、分治算法

        回溯算法、动态规划、字符串匹配算法


        时间复杂度
        空间复杂度

        高效读
        高效写


    io模型

        BIO
        NIO
        AIO

        零拷贝


3.深刻理解CAP、ACID、BASE理论

    CAP（分布式）         一致性、可用性、分区容错性        // CP（zk、consul）、AP（Eureka）、CA（MySQL）


                        分布式  ==>  去中心化  ->  数据分区存储（完整数据 -> 所有分区 加起来） ->  各分区 通过网路通信

                                    =>  网络故障  ->  分区数据 无法访问  ==>  分区故障

                                        =>  引入主备  ->  分区数据 存储多份  ==>  分区容错性

                                            =>  异步复制  ==>  可用性  ->  导致 一致性问题

                                            =>  同步复制  ==>  一致性  ->  等待复制ok期间（暂停服务） ->  导致 可用性问题


                            这里的  可用性  ->  不是架构体系里的 高可用架构   ->  是服务 不暂停（数据同步 无延迟）

    ACID（DB事务）        原子性、一致性、隔离性、持久性

    BASE

        Basically Available         基本可用
        Soft state                  软状态             // 中间状态  ->  同步延迟
        Eventually consistent       最终一致性


        BASE 是对  CAP中 一致性(C)和可用性(A)  权衡的结果

            DB  ->  NoSQL



4.熟练掌握 Java基础、JDK中常用集合源码、线程池、AQS等并发工具类

    集合
        List        ArrayList  /  LinkedList
        Set         HashSet    /  TreeSet
        Map         HashMap    /  TreeMap
        Queue       ArrayBlockingQueue / LinkedBlockingQueue / PriorityBlockingQueue           单端队列 / 双端队列（Deque）

        HashMap / ConcurrentHashMap


    并发bug源头：
        可见性     // 缓存
        有序性     // 编译优化
        原子性     // 线程切换


        JMM规范   ==>  按需禁用   ->  编译优化（有序性）、缓存（可见性）
            happens-before、volatile、synchronized、final      ==>   读写屏障

        互斥锁     ==>  按需禁用 线程切换（原子性）
            synchronized
                锁升级
            Lock




    JUC     // 同步工具

        分工、同步、互斥

        AQS
            Lock        非阻塞/超时/可中断

            CountDownLatch
            CyclicBarrier

            Semaphore


        并发容器
        原子类

        Fail-Fast



    线程池
    ThreadLocal





5.熟悉分布式、高可用、高并发架构体系

    分布式     =>     去中心化 -> 服务拆分（微服务）、DB分库分表、zk

                        新问题：CAP、事务

                                服务治理

                                问题排查

                                运维


                                Snowflake



    高可用     =>     主从架构（主备切换） + 监听检测（zk / 哨兵）

                        主从同步延迟

                        数据丢失

    高并发     =>     缓存（并发读压力 - DB的脆弱性） + MQ（削峰、异步、解耦）

                        可用性

                        一致性

                        复杂性


                        消息延迟
                        消息丢失
                        消息顺序





