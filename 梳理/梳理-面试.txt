========================================================================================================================
Dubbo
========================================================================================================================

1、工作原理

    提供者、注册中心、消费者

    监控
    proxy   ->   无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信    // 动态代理


2、协议

    通信协议        dubbo协议      // 小数据量->高并发 、 hessian序列化 、单一长连接、NIO、消费者数量大于生产者


                   rmi协议        // 阻塞式、短连接、JDK序列化、传输文件

                   hessian

                   http
                   webservice
                   redis
                   rest
                   gPRC

    序列化          hession
                   Java二进制序列化
                   json
                   SOAP



3、扩展机制

    SPI             A接口 = A2实现            // jdbc -> MySQL/Oracle     自定义扩展配置/插件扩展          SPI -> service provider interface




4、服务治理：

    负载均衡        随机
                   轮询
                   最短响应时间   -> 能者多劳
                   hash             // 节点A、B、C       如果C节点挂掉  ->  AB不变、  虚拟一个结点C -> 平均分配到AB



    容错策略        失败重试其它机器        ->  读操作         // 默认配置

                   调用失败就立即失败      ->  非幂等的 写操作

                   异常时忽略             ->  不重要的接口调用      // 如：日志记录

                   失败了后台自动记录请求，然后定时重发               ->   写消息队列

                   并行调用多个 provider，只要一个成功就立即返回      ->  实时性要求较高  的 读操作    // 耗资源


                   逐个调用所有的 provider，任何一个 provider 出错则报错     ->  通知所有provider 更新缓存或日志



    动态代理        默认使用 javassist 动态字节码生成，创建代理类        // Javassist  =>  Java字节码生成 框架   ->  JBoss AOP 实现方案

                                                                    // 可通过 spi 扩展机制配置自己的动态代理策略


    --------------------------------------------------------------------------------------------------------------------
    服务治理         分布式调用链             调用链路自动生成                ->  zipkin
                    监控                    服务访问压力以及时长统计

                    服务分层（避免循环依赖）
                    调用链路失败监控和报警
                    服务鉴权
                    每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）

    --------------------------------------------------------------------------------------------------------------------


    服务降级         Mock                   调用接口失败的时候 ->  走 Mock 降级服务返回


    失败重试/超时重试           异常  ->  自动重试                     // 幂等操作

                              timeout   -> 等待时长
                              retries   -> 报错，重试指定的次数       // 一般用于读   ->  幂等





5、分布式新问题：


    幂等            zk        create znode                 +  check
                   redis      set kv                      +  check

                   版本号                  // 乐观锁
                   唯一约束                // 数据库唯一约束


    调用顺序（并发场景）          分布式锁        // redis、zk

                                分布式队列      // redis

                                内存队列        // hash（同一机器） + 队列排队（内存队列）


                                最好  ->  业务上避免  顺序操作



6、设计一个RPC框架               参照dubbo分层：

                                      service      接口层             给服务提供者和消费者来实现的
                                      config       配置层             主要是对 dubbo 进行各种配置的
                                      proxy        服务代理层          无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信
                                      registry     服务注册层          负责服务的注册与发现
                                      cluster      集群层              封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务
                                      monitor      监控层              对 rpc 接口的调用次数和调用时间进行监控
                                      protocal     远程调用层          封装 rpc 调用
                                      exchange     信息交换层          封装请求响应模式，同步转异步
                                      transport    网络传输层          抽象 mina 和 netty 为统一接口
                                      serialize    数据序列化层


                              --------------------------------------------
                              服务provider、注册中心registry、消费者consumer
                              网络通信代理层proxy
                              序列化serialize
                              配置config

                              监控monitor
                              集群cluster




7、CAP                 分布式系统中 三者只能满足其二         // AP  ->  一般保证 高可用性(A)  、    最终一致性(C)






----------------------------------------------------------------
dubbo 必须知道的一些东西：

    dubbo 工作原理：    服务注册、注册中心、消费者、代理通信、负载均衡；
    网络通信、序列化：   dubbo 协议、长连接、NIO、hessian 序列化协议；
    dubbo SPI 机制：   你了解不了解 dubbo的 SPI机制？如何基于SPI机制 对dubbo进行扩展？

    负载均衡策略、集群容错策略、动态代理策略：
                       dubbo 跑起来的时候一些功能是如何运转的？怎么做负载均衡？怎么做集群容错？怎么生成动态代理？



2、Hystrix

    1、线程池隔离       ==>     tomcat线程  - 转交给 ->  Hystrix线程  执行task

        用 Hystrix自己的线程 去执行调用

        ----------------------------------------------------------------------------------------
        场景：
            外部（依赖服务）访问，网络访问       ->     适合绝大多数场景

        应用：
            对依赖服务 的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）

        举个栗子：
            从 Nginx 开始，缓存都失效了，那么 Nginx 通过缓存服务去调用商品服务。

            缓存服务默认的线程大小是 10 个，最多就只有 10 个线程去调用商品服务的接口。

            即使商品服务接口故障了，最多就只有 10 个线程会 hang 死在调用商品服务接口的路上。

            缓存服务的 Tomcat 内其它的线程还是可以用来调用其它的服务，干其它的事情。




    2、信号量隔离       ==>     tomcat线程 执行task

        直接让 tomcat线程    去调用依赖服务

        ----------------------------------------------------------------------------------------
        场景：
            内部访问，不涉及任何的网络请求

            不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问

        应用：
            比如说，我们一般来说，缓存服务，可能会将一些量特别少、访问又特别频繁的数据，放在自己的纯内存中。


        举个栗子：
            一般我们在获取到商品数据之后，都要去获取商品是属于哪个地理位置、省、市、卖家等

            可能在自己的纯内存中，比如就一个 Map 去获取。

            对于这种直接访问本地内存的逻辑，比较适合用信号量做一下简单的隔离。



        优点在于：
            不用自己管理线程池啦，不用 care timeout 超时，也不需要进行线程的上下文切换啦。

            信号量做隔离的话，性能相对来说会高一些。



2、断路器

    构造command  ->  执行前 check是否已经触发了 断路器  ->  否，继续执行command  ->  suc / fail / reject / timeout 事件发送给  断路器

    -> 断路器 做事件统计



------------------------------------------------------------------------------------------------------------------------
MySQL亿级数据-报表统计

    1、binlog主从复制   ==>   单独划分 1台从库  ->  做报表统计

        1、即不影响  主库的写
        2、也不影响  其他从库的读


    2、分库分表  ==>  分区统计  +  分区合并

        1、可以在    中间件层 完成
        2、也可以在  应用层   完成


    3、大数据  ==>  Hive

        数据仓库    ->      延迟


    4、

