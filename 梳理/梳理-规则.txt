1、ACID       // 强事务机制

    A   原子性     要么都成功，要么都失败
    C   一致性     事务执行前后，数据的完整性必须保持一致                                     // DB中 不能有中间态
    I   隔离性     在并发环境中，事务是相互隔离的，一个事务的执行不能不被其他事务干扰
    D   持久性     一旦事务提交，就永久保存

    -----------------------
    隔离性   ->   隔离级别



2、CAP        // 分布式系统中 三者只能满足其二                - https://codahale.com/you-cant-sacrifice-partition-tolerance

    C       一致性
    A       可用性
    P       分区容错性           // 就是 去中心化(分区) + 主从备份(容错性)

                    // 分区    ==>   分布式存储 去中心化   ->  分区存储

                    // 容错性  ==>   分区挂掉怎么办 ->  分区数据 - 主从备份（一致性、可用性）


                               以实际效果而言，分区相当于  ->  对通信的时限要求
                               系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择


    ----------------------------------------------------------------------------------------------------
    分布式  ==>  去中心化  ->  数据分区存储（完整数据 -> 所有分区 加起来） ->  各分区 通过网路通信

                        =>  网络故障  ->  （部分）分区数据 无法访问  ==>  分区故障

                            =>  引入主备  ->  分区数据 存储多份  ==>  分区容错性

                                =>  异步复制  ==>  可用性  ->  导致 一致性问题

                                =>  同步复制  ==>  一致性  ->  等待复制ok期间（暂停服务） ->  导致 可用性问题

    ----------------------------------------------------------------------
    CP模型   ->   适合 强要求ACID（一致性）场景        如：银行转账
    AP模型   ->   适合 只要求BASE（可用性）场景        如：网页cdn场景
    ----------------------------------------------------------------------
    CP模型的KV存储   ->   适合用于提供基础服务，保存少量数据                                   // 作用类似zk
    AP模型的KV存储   ->   适合查询量大的场景，不要求数据的强一致性  能容忍可能的短暂的一致性延迟   // 目前广泛应用于分布式缓存系统
    ----------------------------------------------------------------------
    一个分布式系统里面，节点组成的网络本来应该是连通的
        然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域
        数据就散布在了这些不连通的区域中  ->  这就叫分区

    当你一个数据项只在一个节点中保存
        那么分区出现后，和这个节点不连通的部分就访问不到这个数据了
        这时分区就是无法容忍的

    提高分区容忍性的办法就是
        一个数据项复制到多个节点上
        那么出现分区之后，这一数据项就可能分布到各个区里
        容忍性就提高了

    然而，要把数据复制到多个节点，就会带来一致性的问题
        就是多个节点上面的数据可能是不一致的
        要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题

    总的来说就是：
        数据存在的节点越多，分区容忍性越高
        但要复制更新的数据就越多，一致性就越难保证
        为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低


    ----------------------------------------------------------------------
    CA
        MySQL（关系型数据库）

        将所有的数据 放在一个库   ->  满足一致性和可用性     // 不满足 去中心化

    CP
        Zookeeper、Consul

        强一致性    ==>  牺牲可用性      ->  分区同步时，暂停服务

    AP
        Eureka

        可用性     ==>  牺牲一致性      ->  分区同步时，数据短暂不一致



3、BASE

    Basically Available         基本可用
    Soft state                  软状态             // 中间状态  ->  同步延迟
    Eventually consistent       最终一致性


    BASE 是对  CAP中一致性(C)和可用性(A)  权衡的结果


