1、ACID       // 强事务机制      -> 数据强一致性

    A   原子性     要么都成功，要么都失败
    C   一致性     事务执行前后，数据的完整性必须保持一致                                     // DB中 不能有中间态
    I   隔离性     在并发环境中，事务是相互隔离的，一个事务的执行不能被其他事务干扰
    D   持久性     一旦事务提交，就永久保存

    -----------------------
    隔离性   ->   隔离级别



2、CAP        // 分布式系统中 三者只能满足其二（权衡妥协）                - https://codahale.com/you-cant-sacrifice-partition-tolerance

    C       一致性
    A       可用性
    P       分区容错性           // 就是 去中心化(分区) + 主从备份(容错性)

                    // 分区    ==>   分布式存储 去中心化   ->  分区存储

                    // 容错性  ==>   分区挂掉怎么办 ->  分区数据 - 主从备份（一致性、可用性）


                               以实际效果而言，分区相当于  ->  对通信的时限要求
                               系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择


    ----------------------------------------------------------------------------------------------------
    分布式  ==>  去中心化  ->  数据分区存储（完整数据 -> 所有分区 加起来） ->  各分区 通过网路通信

                        =>  网络故障  ->  （部分）分区数据 无法访问  ==>  分区故障

                            =>  引入主备  ->  分区数据 存储多份  ==>  分区容错性

                                =>  异步复制  ==>  可用性  ->  导致 一致性问题

                                =>  同步复制  ==>  一致性  ->  等待复制ok期间（暂停服务） ->  导致 可用性问题

    ----------------------------------------------------------------------
    CP模型   ->   适合 强要求ACID（一致性）场景        如：银行转账
    AP模型   ->   适合 只要求BASE（可用性）场景        如：网页cdn场景
    ----------------------------------------------------------------------
    CP模型的KV存储   ->   适合用于提供基础服务，保存少量数据                                    // 作用类似zk
    AP模型的KV存储   ->   适合查询量大的场景，不要求数据的强一致性  能容忍可能的短暂的一致性延迟      // 目前广泛应用于分布式缓存系统
    ----------------------------------------------------------------------
    一个分布式系统里面，节点组成的网络本来应该是连通的
        然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域
        数据就散布在了这些不连通的区域中  ->  这就叫分区

    当你一个数据项只在一个节点中保存
        那么分区出现后，和这个节点不连通的部分就访问不到这个数据了
        这时分区就是无法容忍的

    提高分区容忍性的办法就是
        一个数据项复制到多个节点上
        那么出现分区之后，这一数据项就可能分布到各个区里
        容忍性就提高了

    然而，要把数据复制到多个节点，就会带来一致性的问题
        就是多个节点上面的数据可能是不一致的
        要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题

    总的来说就是：
        数据存在的节点越多，分区容忍性越高
        但要复制更新的数据就越多，一致性就越难保证
        为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低


    ----------------------------------------------------------------------
    CA
        MySQL（关系型数据库）

        将所有的数据 放在一个库   ->  满足一致性和可用性     // 不满足 去中心化

    CP
        Zookeeper、Consul

        强一致性    ==>  牺牲可用性      ->  分区同步时，暂停服务

    AP
        Eureka

        可用性     ==>  牺牲一致性      ->  分区同步时，数据短暂不一致



3、BASE              // 服务可用性

    Basically Available         基本可用
    Soft state                  软状态             // 中间状态  ->  同步延迟
    Eventually consistent       最终一致性


    BASE 是对  CAP中一致性(C)和可用性(A)  权衡的结果





---------------------------------------------------------
CAP（权衡妥协）、ACID（数据强一致性）、BASE（服务可用性）



    你可以将 ACID 特性理解为 CAP 中一致性的边界，最强的一致性，也就是 CAP 的酸（Acid）

    根据 CAP 理论，如果在分布式系统中实现了一致性，可用性必然受到影响

        比如，如果出现一个节点故障，则整个分布式事务的执行都是失败的

        实际上，绝大部分场景对一致性要求没那么高，短暂的不一致是能接受的

        另外，也基于可用性和并发性能的考虑，建议在开发实现分布式系统，如果不是必须，尽量不要实现事务，可以考虑采用最终一致性。


    BASE 理论是对 CAP 中一致性和可用性权衡的结果，它来源于对大规模互联网分布式系统实践的总结，是基于 CAP 定理逐步演化而来的。

        它的核心思想是
            如果不是必须的话，不推荐实现事务或强一致性

            鼓励可用性和性能优先，根据业务的场景特点，来实现非常弹性的基本可用，以及实现数据的最终一致性

        BASE 理论主张通过牺牲部分功能的可用性，实现整体的基本可用

            也就是说，通过服务降级的方式，努力保障极端情况下的系统可用性

        ACID 理论是传统数据库常用的设计理念，追求强一致性模型

        BASE 理论支持的是大型分布式系统，通过牺牲强一致性获得高可用性

        BASE 理论在很大程度上，解决了事务型系统在性能、容错、可用性等方面痛点。

        另外我再多说一句，BASE 理论在 NoSQL 中应用广泛，是 NoSQL 系统设计的事实上的理论支撑。
