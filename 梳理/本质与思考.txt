1、static

    static的本质是不依赖对象（this）

    用法：
        不想创建对象的情况下，调用某个方法          ->  static fun()

        不想创建对象的情况下，初始化某个成员变量     ->  static field


2、你有没有发现，在数据量比较小的情况下，
    Redis 中的很多数据类型，比如字典、有序集合等，都是通过多种数据结构来实现的，为什么会这样设计呢？
    用一种固定的数据结构来实现，不是更加简单吗？

    redis的数据结构由多种数据结构来实现，主要是出于时间和空间的考虑，当数据量小的时候通过数组下标访问最快、占用内存最小，而压缩列表只是数组的升级版；
    因为数组需要占用连续的内存空间，所以当数据量大的时候，就需要使用链表了，同时为了保证速度又需要和数组结合，也就有了散列表。
    对于数据的大小和多少采用哪种数据结构，相信redis团队一定是根据大多数的开发场景而定的。


3、我们讲到数据结构持久化有两种方法。对于二叉查找树这种数据结构，我们如何将它持久化到磁盘中呢？

    二叉查找树的存储，
    我倾向于存储方式一，通过填充叶子节点形成完全二叉树，然后以数组的形式存储到硬盘，数据还原过程也是非常高效的。
    如果用存储方式二就比较复杂了。



4、见过最好的抽象

    AbstractQueuedSynchronizer


5、SPI

    本地 服务发现 机制          -> 基于 本地配置文件                    ==>    接口A  ->  实现A2


6、enum

    语法糖                                 - https://blog.csdn.net/weixin_33834137/article/details/93866226


    class IEnum {
        PASS(1, "通过"),
        BACK(1, "打回");

        private int type;
        private String desc;
    }

    final class IEnum extend Enum {
        public static final IEnum PASS;
        public static final IEnum BACK;

        private final int type;
        private final String desc;

        IEnum[] values();

        ...
    }


7、CPU密集、I/O密集

    CPU密集      ->      CPU操作          ->  飞快                // 瞬间执行ok

    I/O密集      ->      IO读写操作       ->  慢到 - 阻塞          // 1cpu -> 10W+级 IO


8、同步/异步、阻塞/非阻塞

    自行体会：

        同步/异步        方法

        阻塞/非阻塞      线程


9、并行/并发

    并行      ->      同时
    并发      ->      交替


    普通解释：
        并行：同时  做不同事情  的能力
        并发：交替  做不同事情  的能力


    专业术语：
        并行：不同的代码块   同时执行
        并发：不同的代码块   交替执行


10、单体、SOA、微服务

    单体        商城系統

    SOA         财务/订单/物流/用户  系统

    微服务      用户/支付/...        服务



11、集群、分布式、主从（主备）

    集群（扩容）     ->      功能一致（多实例部署 - 负载均衡）        // 同一业务  ->  部署多份实例（配合负载均衡 -> 分担流量压力）

    分布式          ->      去中心化（分区存储）                    // 业务拆分、数据分散存储


    主从（主备）     ->      高可用（leader-follower）              // 同步更新 -> 可用性问题   、   异步更新 -> 一致性问题



12、服务扩展

    单体应用            // 全流程

        扩展      ->      应用级别（所有服务耦合在一起）


    分布式应用         // 单一职责

        服务拆分（微服务架构）   ->   各自 只做自己擅长的    ->     多个系统协同合作，完成一个特定任务的系统

        扩展     ->       单一服务级别（流量压力大的服务）



    扩容：

        集群   ->   加机器（相同实例  部署多份）    ->      配合负载均衡 - 分担请求压力


    ----------------------------------------------------------------
    将一套系统拆分成不同子系统，部署在不同服务器上          这叫  分布式
    然后部署多个相同的子系统在不同的服务器上               这叫  集群

    部署在不同服务器上的同一个子系统                      需要做 负载均衡

