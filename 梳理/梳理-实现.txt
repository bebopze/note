1、分布式 监听（分布式-观察者模式）

    zk      znode 动态监听（K/V）


2、分布式 锁

    Redis   SETNX KV

    zk      创建znode节点   suc / fail -> 监听 znode（释放 -> 重新尝试获取锁）

    --------------------------------------------------------------------------------
    对比：

        zk优势：

            redis   ==>   需要轮询尝试获取锁  ->  耗性能
            zk      ==>   监听通知           ->  无序轮询，性能开销低


            redis   ==>   客户端挂了  ->  等待TTL            =>  不会自动释放锁
            zk      ==>   客户端挂了  ->  临时znode自动消失   =>  自动释放锁


            redis致命  ==>  锁续期  ->  后台定时线程 续期


            redis  轮询获取锁、计算TTL  ->   麻烦
            zk     语义更清晰


        redis优势：

            redis   ==>   天然支持 高并发（频繁加锁/释放锁）

            zk      ==>   并发性能 一般  （zk的强一致性）


        综合：
            zk的分布式锁 比 Redis的分布式锁    ==>   牢靠（强一致性）、模型健壮、简单易用



3、分布式 事务

    XA(两阶段提交)                       ->  强一致性            数据库 原生跨库事务 解决方案      低性能
    TCC                                 ->  强一致性            预扣资源                        编码复杂、难维护

    Saga                                ->  最终一致性          长事务、长流程      遗留老系统/三方服务 无法提供TCC 3个接口的
    本地消息表                           ->  最终一致性
    可靠消息最终一致性                    ->  最终一致性           两阶段事务消息（prepared/confirm） + 轮询/回调          ->  RocketMQ（已实现）   /  其他MQ + 自扩展实现
    最大努力通知                         ->  最终一致性           MQ + DB/队列


4、分布式 session

    redis

    JWT token


5、接口幂等

    redis           set kv

    zk              create znode


6、限流

    算法：
        1、计数器           瞬时峰值问题

        2、滑动窗口         对计数器方式的改进, 增加一个 时间粒度 的度量单位      ==>   1min  ->  6等分

        3、漏桶             规定固定容量的桶

                                有水进入，有水流出

                                对于流进的水我们无法估计进来的数量、速度， 对于流出的水  ->  我们可以控制速度

        4、令牌桶           规定固定容量的桶

                                token 以固定速度往桶内填充，当桶满时 -> token 不会被继续放入

                                每过来一个请求 ->  把token 从桶中移除，  如果桶中没有token -> 不能请求


    实现：
        Guava、spring cloud gateway、sentinel

