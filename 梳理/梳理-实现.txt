1、分布式监听（分布式-观察者模式）

    zk      znode 动态监听（K/V）


2、分布式锁

    Redis   SETNX KV

    zk      创建znode节点   suc / fail -> 监听 znode（释放 -> 重新尝试获取锁）

    --------------------------------------------------------------------------------
    对比：

        zk优势：

            redis   ==>   需要轮询尝试获取锁   ->  耗性能
            zk      ==>   监听通知           ->  无需轮询，性能开销低


            redis   ==>   客户端挂了  ->  等待TTL            =>  不会自动释放锁
            zk      ==>   客户端挂了  ->  临时znode自动消失   =>  自动释放锁


            redis致命  ==>  锁续期  ->  后台定时线程 续期


            redis  轮询获取锁、计算TTL  ->   麻烦
            zk     语义更清晰


        redis优势：

            redis   ==>   天然支持 高并发（频繁加锁/释放锁）

            zk      ==>   并发性能 一般  （zk的强一致性）


        综合：
            zk的分布式锁 比 Redis的分布式锁    ==>   牢靠（强一致性）、模型健壮、简单易用



3、分布式事务


    1、XA(两阶段提交)            // 强一致性（强依赖DB）

        数据库 原生跨库事务 解决方案

        低性能      ->  依赖DB XA协议  ->  需要直连DB

        场景：
            1个应用  ->  直连 N个DB   🚫🚫🚫   // 微服务严禁 跨库直连   ->   只能通过API访问 其他服务库的数据



    2、TCC                      // 强一致性（手动编程  ->  严重依赖 手动回滚/补偿）

        预扣资源   ->  编码复杂、难维护

        适用场景：
            金融  +  短事务（执行快、时间短）


        实现：

            每一个服务  ->  都需要提供3个API

                try         ->    预扣/冻结  资源
                confirm     ->    执行
                cancel      ->    手动维护 回滚逻辑（恶心 + 难维护）  /  补偿逻辑（回滚失败）        // 执行成功的  ->  回滚



    3、Saga                     //  最终一致性（补偿事务）  +  高并发


        长事务、长流程


        原理：
            1、业务流程中每个参与者  ->   都提交本地事务
            2、若某一个参与者失败    ->   则补偿前面已经成功的参与者

            --------------------------------------------------------
            1、左侧是正常的事务流程

            2、当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程

                反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉

            ----------------------------------------------------------------------------------------------------
            T1  ->  T2  ->  T3（err）     ==>     C3  ->  C2  ->  C1      // 主事务  ->  同步  / 也可异步（维护代价）


        场景：
            1、遗留老系统、三方服务   ->   无法提供 TCC模式要求的三个接口
            2、业务流程长、业务流程多


        优势：
            1、一阶段提交本地事务，无锁，高性能

            2、参与者可异步执行，高吞吐

            3、补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的

        缺点：
            不保证事务的隔离性




    4、本地消息表                ->  最终一致性

        原理：

            A
                1、写DB +  消息表A（prepare）
                2、发送消息

                后台线程   ->   扫码消息表A（prepare）  ->  重新发送到MQ

            B
                1、收到消息  ->  写消息表B（防止重复消费 + prepare）  +  执行本地事务
                2、B执行成功  ->  更新 消息表B（commit）  +  消息表A（commit）

                事务执行失败的 / 更新消息表A失败的   ->  收到重复消息   ->  check   ->   重新执行事务B / 更新消息表A


        不适用：
            严重依赖 DB的消息表来管理事务

            高并发不适用

            扩展性差



    5、可靠消息最终一致性         ->  最终一致性


        两阶段事务消息（prepared/confirm） + 轮询/回调          ->  RocketMQ（已实现）   /  其他MQ + 自扩展实现


        实现：

            A系统：
                1、发送  带状态消息（prepared）  ->   MQ      // 消息发送失败  ->  直接fail

                2、A执行本地事务

                    成功  ->   发送 confirm消息

                    失败  ->   发送 cancel消息


            MQ：
                定时轮询   ->   prepared 消息   ->   回调接口   ->   询问A  事务执行 成功/失败


            B系统：
                1、收到  confirm消息   ->   执行本地事务

                2、B执行本地事务

                    成功  ->   ok

                    失败  ->   无限重试  /      回滚 -> 通知A系统 回滚    /     警报 ->  人工回滚/补偿


        -----------------------------------------------------------
        RocketMQ 事务消息

            1、事务消息 带状态   ->   prepared / confirm / cancel

            2、轮询  +  回调接口



    6、最大努力通知              ->  最终一致性        MQ + DB/队列

        原理：
            1、A系统 执行本地事务 ok   ->   发送消息 到MQ

            2、专门消费MQ的 最大努力通知服务

                1、消费事务消息   ->   记录 DB/内存队列

                2、调用B系统

            3、B系统 执行本地事务

                成功   ->   ok

                失败   =>   最大努力通知服务  ->  定时尝试 重新调用B   ->   反复N次（可配）   =>  还是不行  ->  放弃


        场景：
            最大努力通知方案是分布式事务中  对一致性要求最低的一种

            适用于一些最终一致性时间敏感度低的业务         ->      充值成功 - 通知






4、分布式session

    redis

    JWT token


5、幂等

    redis           set kv

    zk              create znode


6、限流

    算法：
        1、计数器           瞬时峰值问题

        2、滑动窗口         对计数器方式的改进, 增加一个 时间粒度 的度量单位      ==>   1min  ->  6等分

        3、漏桶             规定固定容量的桶

                                有水进入，有水流出

                                对于流进的水我们无法估计进来的数量、速度， 对于流出的水  ->  我们可以控制速度

        4、令牌桶           规定固定容量的桶

                                token 以固定速度往桶内填充，当桶满时 -> token 不会被继续放入

                                每过来一个请求 ->  把token 从桶中移除，  如果桶中没有token -> 不能请求


    实现：
        Guava、spring cloud gateway、sentinel

