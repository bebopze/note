1、消息稳定性问题（三方消息中间件不可靠、崩溃问题）

    其实，就是对消息做持久化备份                                      // 消息中间件一般都有这种能力哈🤣
    本地做消息日志，崩溃重启读取log能恢复（借鉴innoDB的redo log）

    自己做的话，
    可以存一份在内存(队列)中，开启异步线程刷到Redis、DB、文件中，作为备份log.
    如果遇到崩溃，读取本地备份log恢复.


2、消息重复消费问题
    给每个消息一个唯一ID（一般为具体业务的唯一ID，如：订单号order_id）
    每次消费前，check一下msg_id是否已消费过，是则直接丢弃.


3、消息中间件有qps限制，且远小于我们业务流量（业务流量_qps_2000 > mq_qps_1000）

    1、最简单的，当然是看能否直接提升中间件的性能，来提高qps限制      // 简单粗暴，加钱堆机器...  有钱人性，适合土豪玩家

    2、本地削峰，本地维护一个一级队列做流量缓冲，消息先入本地队列，然后再开启一个线程，从本地内存异步刷到MQ中.

        当然，重要业务，考虑自身系统也会崩溃的话，同样需要做消息的持久化备份了.

    3、流量前置拦截，网关层做限流，从源头截断.


4、什么时候，会考虑开始优化性能

    1、不管什么时候，首要的，必须优先保证业务的正确性。
        至于优化，不能为了优化而优化。
        不能业务都还没开始用，就考虑要优化了，那只能说是一开始设计的就不合理，没理解需求，或需求变化过大...

    2、最好的方式，依然是把问题控制在源头

        具体的，如果是SQL查询变慢的话，
        前期表结构一定要设计的合理，表设计烂了，后期再怎么优化都很难搞...
        查询优化的点：join的表要尽量的少、返回的字段尽量的少、where的条件尽量的少、排序字段尽量的少、尽量使用默认排序、建立正确的索引...


    3、上线前的压测，根据业务方的使用场景和性能要求，提前做数据的预估与压测.

    4、流量保护，预警和拦截


5、数据库表设计规范

    1、三大范式...

    2、but，外键约束这个在现代化大数据量的场景下，一般是不设置外键约束的，都是在业务层保证数据的关联关系.
        用innoDB的事务，来保证数据的正确性.

    3、根据业务实体，来创建表

    4、关联关系用被关联表的主键id表示

    ...


6、缓存一致性问题

    缓存数据，只保证最终一致性。
    把数据放到缓存里，就默认了会存在数据不一致的问题.

    没有绝对完美的方案，都是根据利弊做取舍，来找一个最优解.
    解决一个问题的时候，一定会带来新的问题.

    想保证准确性，就一定会牺牲性能；
    要保证高性能，就一定会牺牲准确性.
    要保证数据的百分百准备，那就只能用关系型数据库，MySQL、Oracle...

    说白了，这就是两个系统之间的数据同步问题.


    TODO 无非是怎么保证缓存数据更新的一个问题



7、关于异常宕机（断电、系统异常、内存溢出...）的保险措施

    其实，一般也就是 定期（如：每半小时）的持久化到磁盘，系统异常重启后，从磁盘读取最近的备份数据到内存，最多也就丢失小部分（如：半小时）数据.


8、接口的格式

    1、Dubbo 这样的 RPC 接口
    2、Spring Cloud 这样的 HTTP 接口


9、BeanUtils.copyProperties

    org.springframework.beans

        BeanUtils.copyProperties(source, target);

        // 浅拷贝                  - source 中包含 引用对象 的 慎用！！！

            基本类型 -> 值拷贝

            引用类型 -> 地址值拷贝


    org.apache.commons.beanutils.BeanUtils

        BeanUtils.copyProperties(target, source);

        // 浅拷贝          同上

            且 Date、BigDecimal 转换异常




10、what（是什么）、why（为什么）、how（怎么办）、where（应用场景）

