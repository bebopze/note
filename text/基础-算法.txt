------------------------------------------------------------
基本数据结构与算法           -   算法
------------------------------------------------------------

1、排序                // 应用：快排（大规模数据  ->  O(nlogn)  ）、插入（小规模数据    ->  O(n²)   ）

    1、时间复杂度

        1、归并排序、快速排序                     // O(nlogn)


            1、分治思想 + 递归实现

                归并排序和快速排序 是两种稍微复杂的排序算法

                它们用的都是 分治的思想，代码都通过 递归来实现，过程非常相似

            2、递推公式 + merge/partition：

                1、理解归并排序的重点

                    递推公式  和  merge() 合并函数

                2、同理，理解快排的重点

                    递推公式  和  partition() 分区函数



            3、分析：                               // 稳定、原地

                1、归并排序算法        // 稳定、非原地

                    在任何情况下 时间复杂度都比较稳定 的排序算法     ->  O(nlogn)

                    这也使它存在致命的缺点
                        即归并排序 不是原地排序算法，空间复杂度比较高，是 O(n)
                        正因为此，它也没有快排应用广泛

                2、快速排序算法        // 非稳定、原地

                    虽然最坏情况下的时间复杂度是 O(n²)，但是平均情况下时间复杂度都是 O(nlogn)

                    不仅如此，快速排序算法时间复杂度退化到 O(n²) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况


            --------------------------
            分治思想

            Java：

                Arrays.sort     ->      DualPivotQuicksort.sort     // 快排



        2、计数排序、基数排序、桶排序              // O(n)    ->  线性排序

            1、非基于比较：

                都不涉及元素之间的比较操作


            2、适用场景：                 // 苛刻       ->  应用不多

                1、桶排序 和 计数排序

                    排序思想 是非常相似的

                    都是针对 范围不大的数据

                    将数据划分成 不同的桶 来实现排序


                2、基数排序

                    要求数据可以划分成 高低位，位之间有 递进关系

                    比较两个数，我们只需要 比较高位，高位相同的 再比较低位

                    而且每一位的数据范围不能太大，因为基数排序算法 需要借助桶排序 或者 计数排序 来完成每一个位的排序工作



        3、冒泡排序、插入排序、选择排序            // O(n²)                ->      小规模数据

            应用：

                冒泡排序、选择排序   ->  纯粹 理论层面，实际应用 不多

                插入排序            ->  部分语言的 排序函数 实现





    2、分析 一个排序算法的 指标：

        1、执行效率

            1、最好情况、最坏情况、平均情况时间复杂度

            2、时间复杂度的系数、常数 、低阶

            3、比较次数 和 交换（移动）次数


        2、内存消耗

            空间复杂度

                原地排序（Sorted in place）         // 空间 -> O(1)

                    特指 空间复杂度是 O(1)          // 除了 存储数据本身的空间 不需要额外的辅助存储空间


        3、稳定性

            如果待排序的序列中存在 值相等的元素，经过排序之后，相等元素之间 原有的先后顺序不变

            ----------------------------
            1，2，1       ->      1，1，2

                前后2个1的顺序不变  ->  稳定 排序算法

            ---------------------------------------------------
            订单 多属性 排序：      // 下单时间 + 金额  排序

                稳定排序算法 可以保持 金额相同的 两个对象，在排序之后的 前后顺序不变

                    1、第一次排序之后，所有的订单按照 下单时间 从早到晚有序了

                    2、在第二次排序中，我们用的是 稳定的排序算法

                        所以经过第二次排序之后，相同金额的订单 仍然保持下单时间 从早到晚有序



2、二分查找



3、递归

    1、优势：
        高效、简洁的编码技巧

    2、弊端：

        堆栈溢出、重复计算、函数调用耗时多、空间复杂度高




4、并行算法


5、哈希算法


6、贪心算法