------------------------------------------------------------
基本数据结构与算法           -   算法
------------------------------------------------------------

1、排序                // 应用：快排 [大规模数据  ->  O(nlogn) + 原地 + 非稳定 ]  、 插入 [小规模数据  ->  O(n²) + 原地 + 稳定 ]

    1、时间复杂度


        1、桶排序、计数排序、基数排序                 // O(n)    ->  线性排序          ->  条件苛刻

            1、非基于比较：

                都不涉及元素之间的比较操作


            2、适用场景：                 // 苛刻       ->  应用不多

                1、桶排序 和 计数排序

                    排序思想 是非常相似的

                    都是针对 范围不大的数据

                    将数据划分成 不同的桶 来实现排序


                2、基数排序

                    要求数据可以划分成 高低位，位之间有 递进关系

                    比较两个数，我们只需要 比较高位，高位相同的 再比较低位

                    而且每一位的数据范围不能太大，因为基数排序算法 需要借助桶排序 或者 计数排序 来完成每一个位的排序工作



        2、归并排序、快速排序、堆排序                     // O(nlogn)                ->      大规模数据


            1、分治思想 + 递归实现

                1、核心：

                    分治思想

                2、实现：

                    递归


            2、实现：

                1、归并

                    递推公式  和  merge() 合并函数

                2、快排

                    递推公式  和  partition() 分区函数



            3、分析：                               // 原地（空间）、稳定（交换次数）

                1、归并排序        // 稳定、非原地

                    1、稳定：

                        在任何情况下 时间复杂度都比较稳定 的排序算法     ->  O(nlogn)

                    2、非原地：

                        空间复杂度 较高  ->  O(n)

                            每次都要 借助一个额外的数字 进行merge操作，所以空间复杂度为O(n)

                            如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费就翻倍了

                        -------------------------
                        归并 没有 快排 应用广：

                            快排 -> 原地    ->  空间复杂度 O(1)

                            归并 -> 非原地  ->  空间复杂度 O(n)


                2、快速排序        // 原地、非稳定

                    缺点：

                        快速排序在 最坏情况下的 时间复杂度是 O(n²)

                    优化：

                        合理地选择 pivot  ->  来避免 “复杂度恶化”


                    理想的分区点：

                        被分区点分开 的两个分区中，数据的 数量差不多

                    分区算法：

                        1、三数取中法

                            首、尾、中间，分别取出一个数，然后对比大小，取这3个数的 中间值 作为分区点

                        2、随机法

                            随机选择一个元素

                                不能保证每次 分区点 都选的比较好

                                但从 概率 的角度来看，也不大可能出现 每次分区点都选得很差

                        3、Java中的 分区算法

                            DualPivotQuicksort

                                双分区点的选取

                                    1、计算区间1/7长

                                    2、取区间 中间值作为e3

                                    3、中值e3 左右1/7、2/7处，各取值（e1, e2, e4, e5）

                                    4、将 e1, e2, e3, e4, e5 排序后，按照大小 依次放回原位置         // 此时 5个位置的 e已变化

                                    5、取分区点：

                                        1、若 5个e值 各不相等，则取 e2, e4 作为双分区点      ->  双分区点

                                        2、有相等，则取 e3 为单分区点                       ->  单分区点

                                    6、遍历，分区

                                    7、递归，快排




            --------------------------
            分治思想

            Java：

                Arrays.sort     ->      DualPivotQuicksort.sort     // 快排







        3、冒泡排序、插入排序、选择排序            // O(n²)                ->      小规模数据

            应用：

                冒泡排序、选择排序   ->  纯粹 理论层面，实际应用 不多

                插入排序            ->  部分语言的 排序函数 实现           // 原地 + 稳定





    2、分析 一个排序算法的 指标：            // 时间、空间、稳定

        1、执行效率（时间）

            1、最好情况、最坏情况、平均情况时间复杂度

            2、时间复杂度的系数、常数 、低阶

            3、比较次数 和 交换（移动）次数


        2、内存消耗

            空间复杂度

                原地排序（Sorted in place）         // 空间 -> O(1)

                    特指 空间复杂度是 O(1)          // 除了 存储数据本身的空间 不需要额外的辅助存储空间


        3、稳定性

            如果待排序的序列中存在 值相等的元素，经过排序之后，相等元素之间 原有的先后顺序不变

            ----------------------------
            1，2，1       ->      1，1，2

                前后2个1的顺序不变  ->  稳定 排序算法

            ---------------------------------------------------
            订单 多属性 排序：      // 下单时间 + 金额  排序

                稳定排序算法 可以保持 金额相同的 两个对象，在排序之后的 前后顺序不变

                    1、第一次排序之后，所有的订单按照 下单时间 从早到晚有序了

                    2、在第二次排序中，我们用的是 稳定的排序算法

                        所以经过第二次排序之后，相同金额的订单 仍然保持下单时间 从早到晚有序



2、二分查找



3、递归

    1、优势：
        高效、简洁的编码技巧

    2、弊端：

        堆栈溢出、重复计算、函数调用耗时多、空间复杂度高




4、并行算法


5、哈希算法


6、贪心算法




----------------------------------------------
排序算法 的综合比较指标：

    1、时间

        O(n) < O(nlogn) < O(n²)

        实际应用：

            O(nlogn)        ->   快速（原地、非稳定）   >   归并（非原地、稳定）

    2、空间

        最佳：

            O(1) ->  原地排序           // 不需要占用 额外的数据结构（内存空间）  存储比较过程中的中间态

    3、稳定

        相等元素 两两比较     ->     位置不变


        应用场景：

            多条件排序       // 下单时间 + 金额  排序




----------------------------------------------
时间：O(n) < O(nlogn) < O(n²)


    1、桶排序、计数排序、基数排序           // 快，场景严苛           -->  应用价值  有限

        应用：
            不具备 广泛应用价值


    2、归并排序、快速排序                  // 中规中矩，应用广泛      -->  适用  大规模数据

        应用广泛：

            快排 应用较多（原地排序，  空间O(1)        ， 非稳定）

            归并 应用次之（非原地排序，空间O(n)费内存   ，  稳定 ）


    3、冒泡排序、插入排序、选择排序         // 时间复杂度较高          -->  仅适用 小规模数据

        应用：
            插入（小规模数据）



----------------------------------------------
Java中的排序实现

    1、Arrays.sort

        1、基本数据类型：               // 快排

            DualPivotQuicksort




                -----------------------------------------------------------------------------------------------------
                1、算法步骤：                 // 非DualPivotQuicksort的 最终实现，但思路可作为 DualPivotQuicksort实现的理解

                    1、对于很小的数组（长度小于27），会使用 插入排序

                    2、选择 两个点P1,P2 作为轴心，比如我们可以使用 第一个元素和最后一个元素

                    3、P1必须比P2要小，否则将这两个元素交换
                        现在将整个数组分为四部分：
                            第一部分：比P1小的元素
                            第二部分：比P1大但是比P2小的元素
                            第三部分：比P2大的元素
                            第四部分：尚未比较的部分
                        在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后第四部分没有元素

                    4、从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分中的一个

                    5、移动L，K，G指向

                    6、重复4、5步，直到第四部分没有元素

                    7、将P1与第一部分的最后一个元素交换，将P2与第三部分的第一个元素交换

                    8、递归的将一二三部分排序





            快排实现：

                2个 pivot 分区优化       ->      分成3段

                一般的快排 采用1个pivot 来把一个数组划分成两半，然后递归之

                大量经验数据表面，采用2个pivot划分成3份 的算法更高效，这就是 DualPivotQuicksort





        2、引用数据类型：               // 归并     ->  引用类型 存储指针  ->  O(n)空间占用  实际要低的多  -> 这时候  (归并的)稳定性 相对 (快排的)空间   优势就凸显了

            1、MergeSort

                1.7以前版本的 归并排序

                实现：
                    递归

            2、TimSort

                1.7新引入的 归并排序 优化版

                实现：
                    归并 + 快排 + 二分查找



    2、Collections.sort

        Arrays.sort

            1、MergeSort

            2、TimSort




----------------------------------------------
快排

    1、缺点：

        1、分区点 选择不当      ->  复杂度退化  ->  O(n)

        2、递归                ->  堆栈溢出


    2、分区点 优化：

        双分区


    3、递归优化

        1、限制递归深度            // 简单粗暴

            用系统栈  ->  受限于系统栈的内存限制


        2、模拟栈                  // 即：  递归  ->  改写为 循环

            在堆上 模拟实现一个函数调用栈，手动模拟  递归压栈、出栈的过程        ->      摒弃系统栈，就没有了 系统栈大小的限制


    4、实际中的快排：

        1、小数据        ->  插入

        2、中等数据      ->  双分区快排

        3、大数据        ->  无序：双分区快排      、    有序：归并





------------------------------------------------
为什选择 快速排序？

    1、线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序

    2、为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数

    3、同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排


------------------------------------------------
归并排序

    空间复杂度 应该没那么高，因为实际存储的都是 指针或引用

------------------------------------------------
通用排序函数 实现技巧

    1、数据量不大时，可以采取用 空间换时间 的思路

    2、数据量大时，优化 快排分区点的选择

    3、防止堆栈溢出，可以选择 在堆上手动模拟调用栈 解决

    4、在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n²)级别的插入排序

    5、用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致

------------------------------------------------
小规模数据       ->  插入


    小规模数据 前提下

        O(n²)的算法  并不一定比  O(nlogn)的算法  执行时间长：

            时间复杂度 代表的是 一个增长趋势
            如果画成增长曲线图，你会发现 O(n²) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些

            但是，在大O复杂度表示法中，我们会 省略低阶、系数和常数

                也就是说，O(nlogn) 在没有省略低阶、系数、常数之前，可能是 O(knlogn + c)
                而 k 和 c 可能是一个比较大的数


    对于小数据量的排序，我们选择：

        比较简单、不需要递归 的 插入排序算法


    插入：

        原地 + 稳定

    哨兵：

        少做一次判断

            排序函数是非常常用、非常基础的函数，性能的优化要做到极致


        道理很简单：

            插入排序 遍历整个数组，将  遍历值  放在  前面的有序数组的合适位置

            找合适位置的过程是从后往前的，所以为了防止超界，每次都要判定是否超界，无形中增加了很多没用的比较操作（只有最后一次超界的判定才是有用的）

            为了防止这一情况

            我们先判断 第一个值是否小于val：

                如果是，  则可放心大胆的向前遍历，寻找正确的位置

                如果不是，则第一个位置就是我们要的位置，所有数据向后移位，将val放在第一个就好


--------------------------------------------------------------------------------------
为什么插入排序比冒泡排序更受欢迎？

    冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。

    插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。



    稳定性 的作用：


        多条件排序       // 金额 + 下单时间

            最先想到的方法是：

                1、先按照 金额 进行排序

                2、再遍历排序之后的数据，对 每个金额相同的小区间，再按照 下单时间 排序


            难实现：

                这种排序思路 理解起来不难，实现 却会很复杂！！！


            最优：

                借助 稳定排序算法：

                    1、先按照 下单时间 给订单排序          // 注意是 按照 下单时间，不是金额

                    2、排序完成之后，我们用稳定排序算法，按照 订单金额 重新排序







--------------------------------------------------------------------------------------
工业级排序：

    1、插入排序      ->      小规模数据

    2、快速排序      ->      大规模数据

    3、归并排序      ->      大规模数据   +   趋近有序

    4、堆排序        ->      大规模数据                      // 快排 恶化至 O(n²)时   ->   可用 堆排序[ 稳定 O(nlogn) ]





------------------------------------------------------------------------------------------------------------------------
数据结构与算法：动态图解十大经典排序算法            - https://www.cnblogs.com/guoyaohua/p/8600214.html
                                               - https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

C++ sort源码分析                  - http://feihu.me/blog/2014/sgi-std-sort

C++中的sort分析:简直就是艺术品      - https://www.cnblogs.com/ygh1229/articles/9806398.html





--------------------------------------------------------------------------------------
快速排序 算法的优化：

    1、三数取中（找更好的分区点）
    2、随机法（找更好的分区点）
    3、手动模拟栈（防止递归引起的堆栈溢出）

qsort()：

    归并  +   快排（三数取中法+手动模拟栈）   +  插入（哨兵）












