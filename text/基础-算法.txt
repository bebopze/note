------------------------------------------------------------
基本数据结构与算法           -   算法
------------------------------------------------------------

1、排序                // 应用：快排（大规模数据  ->  O(nlogn)  ）、插入（小规模数据    ->  O(n²)   ）

    1、时间复杂度


        1、桶排序、计数排序、基数排序              // O(n)    ->  线性排序          ->  条件苛刻

            1、非基于比较：

                都不涉及元素之间的比较操作


            2、适用场景：                 // 苛刻       ->  应用不多

                1、桶排序 和 计数排序

                    排序思想 是非常相似的

                    都是针对 范围不大的数据

                    将数据划分成 不同的桶 来实现排序


                2、基数排序

                    要求数据可以划分成 高低位，位之间有 递进关系

                    比较两个数，我们只需要 比较高位，高位相同的 再比较低位

                    而且每一位的数据范围不能太大，因为基数排序算法 需要借助桶排序 或者 计数排序 来完成每一个位的排序工作



        2、归并排序、快速排序                     // O(nlogn)                ->      大规模数据


            1、分治思想 + 递归实现

                归并排序和快速排序 是两种稍微复杂的排序算法

                它们用的都是 分治的思想，代码都通过 递归来实现，过程非常相似

            2、递推公式 + merge/partition：

                1、理解归并排序的重点

                    递推公式  和  merge() 合并函数

                2、同理，理解快排的重点

                    递推公式  和  partition() 分区函数



            3、分析：                               // 稳定、原地

                1、归并排序算法        // 稳定、非原地

                    在任何情况下 时间复杂度都比较稳定 的排序算法     ->  O(nlogn)

                    这也使它存在致命的缺点
                        即归并排序 不是原地排序算法，空间复杂度比较高，是 O(n)
                        正因为此，它也没有快排应用广泛

                2、快速排序算法        // 非稳定、原地

                    虽然最坏情况下的时间复杂度是 O(n²)，但是平均情况下时间复杂度都是 O(nlogn)

                    不仅如此，快速排序算法时间复杂度退化到 O(n²) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况


            --------------------------
            分治思想

            Java：

                Arrays.sort     ->      DualPivotQuicksort.sort     // 快排







        3、冒泡排序、插入排序、选择排序            // O(n²)                ->      小规模数据

            应用：

                冒泡排序、选择排序   ->  纯粹 理论层面，实际应用 不多

                插入排序            ->  部分语言的 排序函数 实现





    2、分析 一个排序算法的 指标：            // 时间、空间、稳定

        1、执行效率

            1、最好情况、最坏情况、平均情况时间复杂度

            2、时间复杂度的系数、常数 、低阶

            3、比较次数 和 交换（移动）次数


        2、内存消耗

            空间复杂度

                原地排序（Sorted in place）         // 空间 -> O(1)

                    特指 空间复杂度是 O(1)          // 除了 存储数据本身的空间 不需要额外的辅助存储空间


        3、稳定性

            如果待排序的序列中存在 值相等的元素，经过排序之后，相等元素之间 原有的先后顺序不变

            ----------------------------
            1，2，1       ->      1，1，2

                前后2个1的顺序不变  ->  稳定 排序算法

            ---------------------------------------------------
            订单 多属性 排序：      // 下单时间 + 金额  排序

                稳定排序算法 可以保持 金额相同的 两个对象，在排序之后的 前后顺序不变

                    1、第一次排序之后，所有的订单按照 下单时间 从早到晚有序了

                    2、在第二次排序中，我们用的是 稳定的排序算法

                        所以经过第二次排序之后，相同金额的订单 仍然保持下单时间 从早到晚有序



2、二分查找



3、递归

    1、优势：
        高效、简洁的编码技巧

    2、弊端：

        堆栈溢出、重复计算、函数调用耗时多、空间复杂度高




4、并行算法


5、哈希算法


6、贪心算法




----------------------------------------------
排序算法 的综合比较指标：

    1、时间

        O(n) < O(nlogn) < O(n²)

        实际应用：

            O(nlogn)        ->   快速（原地、非稳定）   >   归并（非原地、稳定）

    2、空间

        最佳：

            O(1) ->  原地排序           // 不需要占用 额外的数据结构（内存空间）  存储比较过程中的中间态

    3、稳定

        相等元素 两两比较     ->     位置不变


        应用场景：

            多条件排序       // 下单时间 + 金额  排序




----------------------------------------------
时间：O(n) < O(nlogn) < O(n²)


    1、桶排序、计数排序、基数排序           // 快，场景严苛           -->  应用价值  有限

        应用：
            不具备 广泛应用价值


    2、归并排序、快速排序                  // 中规中矩，应用广泛      -->  适用  大规模数据

        应用广泛：

            快排 应用较多（原地排序，  空间O(1)        ， 非稳定）

            归并 应用次之（非原地排序，空间O(n)费内存   ，  稳定 ）


    3、冒泡排序、插入排序、选择排序         // 时间复杂度较高          -->  仅适用 小规模数据

        应用：
            插入（小规模数据）



----------------------------------------------
Java中的排序实现

    1、Arrays.sort

        1、基本数据类型：               // 快排

            DualPivotQuicksort

                1、算法步骤：

                    1、对于很小的数组（长度小于27），会使用 插入排序

                    2、选择 两个点P1,P2 作为轴心，比如我们可以使用 第一个元素和最后一个元素

                    3、P1必须比P2要小，否则将这两个元素交换
                        现在将整个数组分为四部分：
                            第一部分：比P1小的元素
                            第二部分：比P1大但是比P2小的元素
                            第三部分：比P2大的元素
                            第四部分：尚未比较的部分
                        在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后第四部分没有元素

                    4、从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分中的一个

                    5、移动L，K，G指向

                    6、重复4、5步，直到第四部分没有元素

                    7、将P1与第一部分的最后一个元素交换，将P2与第三部分的第一个元素交换

                    8、递归的将第一二三部分排序





            快排实现：

                2个 pivot 分区优化       ->      分成3段

                一般的快排 采用1个pivot 来把一个数组划分成两半，然后递归之

                大量经验数据表面，采用2个pivot划分成3份 的算法更高效，这就是 DualPivotQuicksort





        2、引用数据类型：               // 归并     ->  引用类型 存储指针  ->  O(n)空间占用  实际要低的多  -> 这时候  (归并的)稳定性 相对 (快排的)空间   优势就凸显了

            1、MergeSort

                1.7以前版本的 归并排序

                实现：
                    递归

            2、TimSort

                1.7新引入的 归并排序 优化版

                实现：
                    归并 + 快排 + 二分查找



    2、Collections.sort

        Arrays.sort

            1、MergeSort

            2、TimSort





----------------------------------------------
快速排序 算法的优化：

    1、三数取中（找更好的分区点）
    2、随机法（找更好的分区点）
    3、手动模拟栈（防止递归引起的堆栈溢出）

qsort()：

    归并  +   快排（三数取中法+手动模拟栈）   +  插入（哨兵）












