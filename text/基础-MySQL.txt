========================================================================================================================
1、SQL执行过程
========================================================================================================================

    客户端     ->      Server端
                                   ↗   查缓存（MySQL8 已废弃）

    ->  连接器（管理连接，权限验证）  ->  分析器（词法分析，语法分析）  ->  优化器（执行计划生成，索引选择） ->  执行器（操作引擎，返回结果）

    ->  存储引擎（存储数据，提供读写接口）



    MySQL：

        1、Server层                                   // 不同的存储引擎共用一个 Server 层，也就是 从连接器到执行器 的部分

            连接器、查询缓存、分析器、优化器、执行器等

            涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）

            所有 跨存储引擎的功能 都在这一层实现，比如 存储过程、触发器、视图 等


        2、存储引擎层                                  // 存、取     插件式

            负责 数据的存储和提取

            其架构模式是 插件式 的，支持 InnoDB、MyISAM、Memory 等多个存储引擎

            最常用的存储引擎是 InnoDB



========================================================================================================================
2、日志                        // CRUD 记录
========================================================================================================================

    1、redo log              // 引擎层 日志、InnoDB 引擎特有的日志、crash-safe、事务

        作用：
            crash-safe、事务


        目的：         // 提高写入性能   ->  通过  crash-safe、事务  保证数据完整性

            每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高

                // 写入磁盘的操作 成本过高：   ->  写入 log file  ->  就直接返回 insert/update/delete 成功    ->  后台再从 log file  --同步至-->  磁盘

                    // 所有我们先写入 一个日志file，做个缓冲        // 类似 log4j日志

                    // 读取 log  ->  解析 log  ->  写入磁盘

                    // 再从log file中，更新到磁盘（ 因为直接写入磁盘，需要经过 IO、查询、更新、维护索引...  --->  成本较高  ->  时间较慢  -->  系统效率慢 ）


        优化：

            先写日志，再写磁盘       // 也就是先写粉板，等不忙的时候再写账本

                InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了

                同时，InnoDB 引擎会在适当（空闲）的时候，将这个操作记录更新到磁盘里面


        日志 存储：  // 本质就是一个  循环队列

            本质就是一个  循环队列
            --------------------------------------
            日志存储空间有限，记满了    ->  停下来（阻塞），批量处理一批  ->  写入磁盘  ->  清除已处理日志，腾出空间


        理解：

            类比 掌柜记账

                黑板记账(日志，写入内存)    ->  打烊后（系统空闲）核算，记入账本（写入磁盘）

            -----------------------------
            黑板写满了   ->  停下来，先核算一批，写入账本  ->  擦除 -> 重新黑板记账



        crash-safe：                 // redo log 记录在 file，也是一种物理存储   并不是在内存中   ->   只要记录在了粉板上，就具备 crash-safe 的能力了

            只要写入了 log file，就已经持久化到 file 文件中了

            log file 类似 log4j 的日志文件，也是 持久化存储在 物理磁盘 上

            就算 数据库异常崩溃，log file 依然存在

            重启后，继续 读取、解析log，再持久化到磁盘



        实现：

            "循环队列"   ->  本质上是一个 循环file

            checkpoint  ->  游标



    2、binlog            // Server层 日志   ->  所有引擎 公有     、  归档

        归档日志    ->  数据恢复




------------------------------------------------------------------------------------------------------------------------
redo log、binlog 区别：         // 都是log file   ->  类似 log4j 业务日志   ->   均存储在 物理磁盘

    redo log    ->  引擎层   日志       InnoDB 独有        固定大小   循环写入(覆盖)       ->  crash-safe

    binlog      ->  Server层 日志      公有日志            无大小限制 追加写入             ->  归档


------------------------------------------------------------------------------------------------------------------------
物理日志 redo log

    保证 crash-safe 能力

    innodb_flush_log_at_trx_commit 参数设置成 1      ->      表示每次事务的 redo log 都直接持久化到磁盘

        // 这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失



------------------------------------------------------------------------------------------------------------------------
两阶段提交：      // InnoDB

    redo log（prepare）   ->  binlog  ->  redo log（commit）

    为了 让两份日志 之间的逻辑一致    // 两类日志 职责功能 各不相同   ->  破坏一个，就会破坏 现有 逻辑 和 功能

    -----------------------
    本质上，从设计目的：

        redo log    负责 事务

        binlog      负责 归档恢复

        各司其职，相互配合，才提供(保证)了 Mysql InnoDB 的现有功能（crash-safe、事务、归档恢复）

        如果 你非要破坏 其中一个log，自然也就破坏了 现有逻辑和功能（crash-safe、事务、归档恢复）

    ---------------------------
    两阶段提交

        是  跨系统 维持数据逻辑一致性  时常用的一个方案

        即使你不做数据库内核开发，日常开发中也有可能会用到

        如：分布式事务 的 两阶段提交

------------------------------------------------------------------------------------------------------------------------
crash-safe、两阶段提交、事务

    InnoDB 为了 提高写入效率     ->  设计了 redo log

    为了解决 redo log 和 磁盘 数据的一致性问题     ->  设计了 crash-safe

    具体：

        两阶段提交   +   事务(状态 标记)

------------------------------------------------------------------------------------------------------------------------
数据恢复：       // 依靠 ->  数据库备份  +  binlog（归档日志）

    1、找到 最近的一次全量备份（如：一天一备，也就是昨晚），恢复至临时库

    2、从 备份的时间点 开始，将binlog取出来，重放到误删表的时刻

        binlog（归档日志） -> 恢复数据：
            从 最近一次全量备份 的时间点 开始；
            到 删库跑路        的时间点 结束；

    应用：

        1、误删恢复

        2、扩容    ->  搭建备库（全量备份 + binlog）


------------------------------------------------------------------------------------------------------------------------
binlog为什么说是逻辑日志呢？它里面的内容 也是 存储成物理文件，怎么说是逻辑 而不是物理

    这样理解：

        逻辑日志 可以给别的数据库，别的引擎使用，以及大家都 讲得通（认可）这个“逻辑”

        物理日志 就只有“我”自己能用，别人没有共享我的“物理格式”


------------------------------------------------------------------------------------------------------------------------
redo log 的持久化

    实际上，为了提高 redo log 的写入效率：

        并没有 每次都直接将 redo log 写入file

        而是放到buffer中，积攒多条 再一次性刷盘

        --------------------------------------------
        innodb_flush_log_at_trx_commit      0/1

            设置成 1       ->     每次事务的 redo log  都直接 持久化 到磁盘

            建议设置成 1    ->    可以保证 MySQL 异常重启之后 redo log 不丢失     --> 保证了 数据不丢失


------------------------------------------------------------------------------------------------------------------------
binlog 的持久化

    sync_binlog     0/1

        参数设置成 1        ->    表示每次事务的 binlog  都直接 持久化 到磁盘

        也建议设置成 1      ->    可以保证 MySQL 异常重启之后 binlog 不丢失


------------------------------------------------------------------------------------------------------------------------
binlog 还不能去掉

    1、redo log 只有InnoDB有，别的引擎没有

    2、redo log是循环写的，不持久保存，binlog 的“归档”这个功能，redolog是不具备的


    3、binlog 是MySQL 原生支持的，很多三方扩展、或现有的数据同步方案  强依赖了 binlog    // 主从同步 即是通过 解析 binlog 实现的


------------------------------------------------------------------------------------------------------------------------
redo log 和 binlog  两套日志 共存

    归根结底是 历史原因

        binlog      MySQL 原生自带

        redo log    InnoDB 三方公司开发   后来被 MySQL 合并到官方版本   造成了 二者共存的局面

                    // 既然是三方公司开发，也不好直接改你的 binlog

                    // 且改动原有的设计，成本也非常大，而且你还不是官方

                    // 最优方案自然是在 MySQL 提供的扩展插件（自定义 引擎扩展）上 重新开发一套log   ->  redo log


------------------------------------------------------------------------------------------------------------------------
crash-safe 崩溃恢复：

    redo log 里面的数据有两种状态，分别是：prepare、commit

    宕机后重启

        如果 redo log 里面的数据是 commit 状态，则commit

        如果是 prepare 状态，则需要根据 binlog 来确定  数据 是回滚还是提交

            如果 binlog 中已经记录了 prepare 状态数据的逻辑修改，则commit，否则需要回滚

            // 如果 修改 已经归档到 binlog，则此数据 必须提交，因为 下游的从库 会用到binlog，这样才能保证主从一致



------------------------------------------------------------------------------------------------------------------------
crash-safe 可能情况分析：

    1-prepare阶段     2-写binlog       3-commit

    当在 2之前 崩溃

        重启恢复：没有commit，且 binlog 中不完整/不存在            ->  rollback

        备份恢复：没有 binlog

        一致

    当在 3之前 崩溃

        重启恢复：虽没有commit，但满足 prepare 和 binlog完整       ->  commit

        备份恢复：有 binlog

        一致


------------------------------------------------------------------------------------------------------------------------
redo log 和 binlog 是如何关联的

    xid     ->      通过 事务ID 关联



========================================================================================================================
3、事务隔离
========================================================================================================================

    事务：
        ACID（Atomicity、Consistency、Isolation、Durability，即 原子性、一致性、隔离性、持久性）



    隔离级别：       //  隔离级别 -> 全局共享参数     ====>  一般情况下，所有线程 都为同一个隔离级别      A事务 与 B事务  -->  可类比 多线程 下的可见性问题


        读未提交（read un-committed）：                // 非阻塞、能看到

            一个事务还没提交时，它做的变更就能被别的事务看到


        读已提交（read committed）：                   // 非阻塞、看不到

            一个事务提交之后，它做的变更才会被其他事务看到


        可重复读（repeatable read）：                  // 非阻塞、看不到      实现：缓存第一次读取的值（别人改数据的事务 已经提交，我在我的事务中也 根本不去读）

            一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的

            当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的


        串行化（serializable）：                       // 阻塞

            顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”

            当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行


------------------------------------------------------------------------------------------------------------------------
隔离级别 - 效率  的平衡：

    隔离 得越严实     ->      效率 就会越低

    因此很多时候，我们都要在 二者之间 寻找一个平衡点

------------------------------------------------------------------------------------------------------------------------
默认隔离级别：

    官方MySQL     ->   可重复读（repeatable read）

    阿里云RDS     ->   读已提交（read committed）

------------------------------------------------------------------------------------------------------------------------
关于隔离级别的理解：

    1、read uncommitted

        可以看到未提交的数据（脏读），举个例子：别人说的话你都相信了，但是可能他只是说说，并不实际做。

    2、read committed

        读取提交的数据。但是，可能多次读取的数据结果不一致（不可重复读，幻读）。用读写的观点就是：读取的行数据，可以写。

    3、repeatable read（MySQL 默认隔离级别）

        可以重复读取，但有幻读

        读写观点：

            读取的数据行不可写，但是可以往表中新增数据

            在MySQL中，其他事务新增的数据，看不到，不会产生幻读

            采用多版本并发控制（MVCC）机制解决幻读问题

    4、serializable

        可读，不可写

        像Java中的锁，写数据必须等待另一个事务结束

------------------------------------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------






    把 一致性读、当前读和行锁 串起来



========================================================================================================================
3、索引
========================================================================================================================


========================================================================================================================
4、锁
========================================================================================================================



========================================================================================================================
5、order by      // 排序
========================================================================================================================




========================================================================================================================
6、高可用、主备、读写分离
========================================================================================================================



========================================================================================================================
7、join
========================================================================================================================



========================================================================================================================
8、临时表
========================================================================================================================



========================================================================================================================
9、InnoDB、Memory
========================================================================================================================





========================================================================================================================
10、自增主键
========================================================================================================================




========================================================================================================================
11、insert 锁
========================================================================================================================




========================================================================================================================
12、复制一张表
========================================================================================================================


========================================================================================================================
13、分区表
========================================================================================================================




