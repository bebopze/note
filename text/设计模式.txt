23 种经典的设计模式

    1. 创建型                          // 对象的创建

        常用：   单例模式、工厂模式（工厂方法和抽象工厂）、Builder(建造者)模式
        不常用： 原型模式

        主要解决：对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。


    2. 结构型                          // 类或对象的组合或组装

        常用：   代理模式、桥接模式、装饰者模式、适配器模式
        不常用： 门面模式、组合模式、享元模式

        主要解决：结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。


    3. 行为型                          // 类或对象之间的交互

        常用：   观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式
        不常用： 访问者模式、备忘录模式、命令模式、解释器模式、中介模式

        主要解决：类或对象之间的交互 问题


面向对象

    面向对象的四大特性：封装、抽象、继承、多态

    面向对象编程与面向过程编程的区别和联系

    面向对象分析、面向对象设计、面向对象编程

    接口和抽象类的区别以及各自的应用场景

    基于接口而非实现编程的设计思想

    多用组合少用继承的设计思想

    面向过程的贫血模型和面向对象的充血模型


设计原则

    SOLID 原则 -SRP 单一职责原则

    SOLID 原则 -OCP 开闭原则

    SOLID 原则 -LSP 里式替换原则

    SOLID 原则 -ISP 接口隔离原则

    SOLID 原则 -DIP 依赖倒置原则

    DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


编码规范

     20 条最快速改善代码质量的编程规范


代码重构

    重构的目的（why）、对象（what）、时机（when）、方法（how）；

    保证重构不出错的技术手段：单元测试和代码的可测试性；

    两种不同规模的重构：大重构（大规模高层次）和 小重构（小规模低层次）。



计算机思维：   二进制指令、汇编语言、面向过程
人类思维：     面向对象


个人理解
    一切的一切 都是以人为本
    人脑能理解、处理的信息 是非常非常有限的！！！
    认知极限



----------创建型


1、单例模式                          // 全局唯一 对象

    功能：
        用来创建 全局唯一的对象

    饿汉式、懒汉式

    双重检测

        关于网上人传人的 所谓指令重排导致的 new出来的对象赋值返回之后，还没来得及初始化的问题，给出的 用volatile禁止指令重排 的解决方案！
        这种说法和解决方案，早已过时！！！

        只有很低的Java版本才有这个问题！

        我们现在普遍用的1.8+高版本的JDK，早已在内部实现中解决了这个问题。
        具体的实现也很简单，就是将 new操作 和 初始化操作 设计为原子操作，自然就不存在 指令重排了！！！

    静态内部类

    枚举


2、工厂模式                          // 相关对象

    功能：
        用来创建 不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的 参数来决定 创建哪种类型的对象。

    类型：
        简单工厂、工厂方法、抽象工厂

    应用场景：
        当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式。

    何为复杂：
        1、大坨 if-else 分支判断，动态地根据不同的类型创建不同的对象。
        2、单个对象本身的创建过程比较复杂，比如要组合其他类对象，做各种初始化操作。

    相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？
        封装对象的创建过程，将对象的创建和使用相分离。

    作用：
        封装变化、代码复用、隔离复杂性、控制复杂度

    解耦：
        对象的 创建 和 使用


3、Builder模式                         // 复杂对象

    功能：
        用来创建 复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。

    应用场景：
        1、构造函数的参数列表过长，可选参数过多。
        2、一次性初始化，屏蔽中间状态。            // 即：单个单个的set()
        3、创建不可变对象，                      // Builder模式，未对外提供set()，无法修改属性！


4、原型模式                          //  针对 创建成本比较大 的对象

    功能：
        针对 创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

    浅拷贝
        Java 中的 clone() 语法
        只拷贝第一层，引用对象共享 内存地址。

    深拷贝
        递归拷贝 引用对象，直到只有 基本数据 为止。

    应用场景：
        对象的创建成本比较大

            对象中的数据 需要经过 复杂的计算 才能得到（比如排序、计算哈希值），
            或者需要从 RPC、网络、数据库、文件系统等 非常慢速的 IO 中读取.



----------结构型


5、代理模式                          // 附加功能

    在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

    实现：
        1、通过实现相同的接口     -->  静态实现：手动创建Proxy      /      动态实现： JDK   Proxy
        2、继承被代理类          -->  静态实现  手动创建Proxy      /      动态实现： Cglib Proxy      --> ASM

    静态代理
        提前  -->  手动创建Proxy
        静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。

    动态代理（Dynamic Proxy）
        运行时  -->  自动动态生成Proxy  -->  替换target
        不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。


    Spring AOP
        底层的实现原理就是 基于动态代理

        步骤：
            用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。
            Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。
            原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。

    应用场景：
        1、非功能性需求
            如：监控、统计、鉴权、限流、事务、幂等、日志。
            与业务功能解耦

        2、RPC、缓存
            RPC 框架也可以看作一种代理模式————远程代理：将网络通信、数据编解码等细节隐藏起来。

            缓存：
                ...
                cache=true/false --> 走缓冲/实时查询


6、桥接模式                          // 独立

    两种理解：

        1、将"抽象"和"实现"解耦，让它们可以独立变化。
             “抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。
             “实现”，也并非“接口的实现类”，而是一套独立的“类库”。
             “抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。

        2、一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。
            “组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。

    经典应用：
        JDBC驱动



7、装饰器模式                         // 增强

    主要解决：
        继承关系过于复杂的问题，通过组合来替代继承。

        "组合优于继承" 原则

    主要作用：
        给原始类添加 增强功能

        这是判断是否该用装饰器模式的一个重要的依据

    特点：
        1、装饰器类和原始类继承同样的父类，这样我们 可以对原始类“嵌套”多个装饰器类。
        2、装饰器类是 对功能的增强，这也是装饰器模式应用场景的一个重要特点。


    对于为什么中间要多继承一个FilterInputStream类，我的理解是这样的：

        假如说 BufferedInputStream 类直接继承自InputStream类，且没有进行重写，只进行了装饰。
        创建一个 InputStream is = new BufferedInputStream(new FileInputStream(FilePath));
        此时调用is的没有重写方法(如read方法)时，调用的是InputStream类中的read方法，而不是FileInputStream中的read方法。
        这样的结果不是我们想要的，所以要将方法再包装一次。

        中间加一层FilterInputStream类，也是避免代码的重复，多个装饰器只用写一遍包装代码即可。


8、适配器模式                         // 兼容

    就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。

    生活实例：
        USB转接头

    实现：
        1、类适配器
            使用 继承关系 来实现

        2、对象适配器
            使用 组合关系 来实现

    应用场景：
        接口不兼容

        适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。

        如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。


    接口不兼容：
        1、封装有缺陷的接口设计
        2、统一多个类的接口设计
        3、替换依赖的外部系统
        4、兼容老版本接口
        5、适配不同格式的数据



9、门面模式                          // 整合、易用

    定义：
        门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。

    用途：
        设计合理的接口 粒度，以兼顾接口的 易用性 和 通用性。


    “子系统（subsystem）”
        既可以是一个完整的系统，也可以是更细粒度的类或者模块。


    应用场景
        1、解决易用性问题
            封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。

        2、解决性能问题
            多个接口调用替换为一个门面接口调用，减少网络通信成本

        3、解决分布式事务问题

            在一个 事务(门面接口) 中执行两个 SQL操作(子接口)



10、组合模式                         // 树形结构

    定义：
        将 一组对象（文件和目录）组织成 树形结构，以表示一种 ‘部分 - 整体’ 的层次结构（目录与子目录的嵌套结构）。

    主要用来
        处理树形结构数据

    功能：
        组合模式让客户端可以 统一 单个对象（文件）和 组合对象（目录）的处理逻辑（递归遍历）。

    “数据”
        简单理解为 一组对象集合


    应用场景：
        树形结构

        如：
            1、文件系统（文件夹-文件）
            2、部门-员工



11、享元模式                         // 共享、不可变、节省内存

    定义：
        所谓“享元”，顾名思义就是 被共享的单元。

    意图：
        复用对象，节省内存。
        前提是享元对象是不可变对象。

    “不可变对象”
        一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。


    实现：
        通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存 已经创建好的享元对象，以达到复用的目的。

    应用场景举例：
        1、棋牌游戏
        2、文本编辑器

        3、Java Integer 类

            享元工厂类   -->     IntegerCache
            享元对象     -->     事先创建好的整型对象：[-127, 128]

        4、Java String 类
            享元工厂类   -->     字符串常量池（JVM 开辟一块存储区 专门存储字符串常量）
            享元对象     -->     字符串常量


    不用过度使用：
        享元模式对 JVM 的垃圾回收并不友好

        享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉。


    享元模式 VS 单例、缓存、对象池 设计意图：

        应用单例模式是为了 保证对象全局唯一。
        应用享元模式是为了 实现对象复用，节省内存。
        缓存是为了 提高访问效率，而非复用。
        池化技术中的“复用”理解为“重复使用”，主要是为了 节省时间。



----------行为型


12、观察者模式                            // 发布-订阅

    观察者模式（Observer Design Pattern）也被称为 发布订阅 模式（Publish-Subscribe Design Pattern）

    定义：
        在对象之间定义一个 一对多的依赖，当一个对象状态 改变 的时候，所有依赖的对象都会 自动收到通知。


    各种不同的叫法：
        Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener


    实现方式：
        同步阻塞的实现方式，异步非阻塞的实现方式；
            单线程/新开子线程
        有进程内的实现方式，也有跨进程的实现方式。
            单系统/跨系统：RPC、消息队列

        1、同步
            观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。

        2、EventBus

            核心类/方法：

                AsyncEventBus extends EventBus
                    异步 / 同步

                void register(Object object);       /   void unregister(Object object);
                    注册  /  取消注册

                void post(Object event);
                    发送消息

                    消息类型匹配：
                        Msg2 extends Msg1  ---->  发送 Msg2类型 的消息，其 父类Msg1 也能接收到。

                @Subscribe
                    标明：msg -->  clazz.fun()     的 映射关系


            执行逻辑：
                post -> msg -> clazz.fun()  -->  反射执行 clazz.fun(msg)


        3、消息队列
            彻底解耦，被观察者完全不感知观察者，观察者也完全不感知被观察者。
            被观察者 只管 发送消息 到消息队列，观察者 只管从消息队列中 读取消息 来执行相应的逻辑。


    解耦：
        具体到观察者模式，它是将观察者和被观察者代码解耦


    应用场景：
        小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，如：邮件订阅、RSS Feeds.



13、模板模式                         // 复用、扩展

    定义
        模板方法模式 在一个方法中定义一个 算法骨架，并将某些步骤 推迟到子类中实现。
        模板方法模式 可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

    作用
        复用、扩展

        复用 指的是，所有的子类可以复用父类中提供的模板方法的代码。
        扩展 指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

    “算法”
        可以理解为 广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。
        这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。

    经典实现
        模板方法 定义为 final，可以 避免被子类重写。
        需要子类重写的方法 定义为 abstract，可以 强迫子类去实现。


    案例：
          Java IO  InputStream    read(byte b[], int off, int len);   -->    read();
          AbstractList            addAll();                           -->    add();
          Servlet                 service();                          -->    doGet();    /   doPost();
          JUnit                   runBare();                          -->    setUp();    /   tearDown();


    应用场景：
        常用在框架开发中
            通过提供功能扩展点，让框架用户在不修改框架源码的情况下，基于扩展点定制化框架的功能。


    ---------------------------

    回调

        作用：
            复用、扩展

        同步/异步：
            同步回调 看起来更像 模板模式
            异步回调 看起来更像 观察者模式

        经典实现：
            1、回调对象作为参数：抽象的回调接口

                void process(ICallback iCallback) {
                    // ...

                    // 回调对象.回调函数();
                    iCallback.callback();
                }

            2、客户端使用时，传入回调接口的匿名内部类作为回调对象，回调对象内部实现回调内容的扩展.

                b.process(new ICallback() { // 回调对象
                    @Override
                    public void callback() {
                        // 回调扩展
                        System.out.println("callback me ...");
                    }
                });


        应用：

            1、JdbcTemplate

                基于(同步)回调，非基于模板：

                    Spring 提供的 xxTemplate 类：JdbcTemplate、RedisTemplate、RestTemplate

                    尽管都叫作 xxTemplate
                        但它们 并非基于 模板模式 来实现的，而是基于 回调 来实现的，确切地说应该是 同步回调。

                    同步回调 从应用场景上 很像 模板模式
                        所以，在命名上，这些类使用 Template（模板）这个单词作为后缀。

                底层实现：
                    JdbcTemplate 通过回调的机制，
                    将 不变的执行流程 抽离出来，放到 模板方法 execute() 中，
                    将 可变的部分 设计成 回调 StatementCallback，由用户来定制。

                    class JdbcTemplate {

                        execute(StatementCallback<T> action) {

                            // ...

                            // 回调
                            action.callback();
                        }
                    }


            2、setClickListener
                Android控件 注册事件监听器

            3、addShutdownHook()
                Tomcat 和 JVM 的 shutdown hook


    ---------------------------

    回调 VS 模板：

        应用场景 一致：
            复用、扩展

        实现不同：
            回调  -->  组合  -->   回调对象
            模板  -->  继承  -->   子类复写



14、策略模式                         // 解耦、消除if-else

    定义：
        定义一组算法类，将每个算法分别封装起来，让它们可以互相替换。
        策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。

    作用：
        解耦 策略的定义、创建和使用，控制代码的复杂度
        避免冗长的 if-else 或 switch 分支判断
        提供框架的扩展点

    设计意图：


    解耦：
        策略的定义、创建、使用


    大文件内容排序：

        10GB   -->  外部排序算法
        100GB  -->  加入多线程并发排序          -> “单机版”的 MapReduce
        1TB    -->  使用真正的 MapReduce 框架  ->  "多机版"  -->  利用多机的处理能力，提高排序的效率     // 加大算力


    消除 if-else 、switch-case 分支判断：

        1、查表法：    提前创建 + Map缓存

        2、反射：      配置文件 / annotation注解 标注 + 反射 动态加载、创建



15、职责链模式                            // 处理链

    定义：
        将请求的 发送和接收 解耦，让多个接收对象 都有机会 处理这个请求。
        将这些接收对象 串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。

    通俗：
        在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。
        一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。
        链条上的每个处理器 各自承担各自的处理职责，所以叫作 职责链模式。

    作用：
        复用、扩展

    应用场景：

        1、框架开发：
            提供框架的扩展点，基于扩展点定制化框架的功能。

            Servlet Filter
                Filter 对 请求和响应 的拦截 是在 doFilter() 一个函数中实现的。
                Tomcat 处理器链：ApplicationFilterChain

            Spring Interceptor
                Interceptor 对 请求 的拦截 在 preHandle() 中实现，对 响应 的拦截 在 postHandle() 中实现。
                Spring MVC 处理器链：HandlerExecutionChain

            Dubbo Filter

            Netty ChannelPipeline

        2、过滤/替换 敏感词

    实现：
        1、使用 链表 来存储处理器
        2、使用 数组 来存储处理器


16、状态模式                         // 状态机

    定义：
        状态模式 是 状态机 的一种实现方式

    作用：
        用来实现 状态机

    状态机
        常用在 游戏、工作流引擎 等系统开发中

    状态机的3个组成部分：
        状态（State）、事件（Event）、动作（Action）

        事件 也称为 转移条件（Transition Condition），事件 触发 状态的转移 及 动作的执行。
        动作不是必须的，可能只转移状态，不执行任何动作。

    状态机的 实现：
        1、分支逻辑法
            简单的状态机，这种实现方式最简单、最直接，是首选。
            利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将 每一个状态转移 原模原样地 直译 成代码。
        2、查表法
            对于 状态很多、状态转移 比较复杂 的状态机来说，查表法比较合适。
            通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。
        3、状态模式
            对于 状态并不多、状态转移 比较简单，
            但事件 触发执行的动作 包含的业务逻辑 比较复杂 的状态机。



17、迭代器模式                            // 容器、迭代

    迭代器模式：
        将 集合对象的遍历操作 从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。

    作用：
        遍历 集合对象（容器）

    遍历集合的方式：
        for 循环、foreach 循环、迭代器

    迭代器遍历 集合的 优势：

    “集合对象”：
        数组、链表、树、图、跳表

    实现：
        基于接口编程
            容器          接口  -->  实现类
            容器迭代器     接口  -->  实现类


    fail-fast：
        modCount 快照值 比较
            next()、remove()、add()...        -->    checkForComodification();


    迭代器中 提供的 remove()                    // 鸡肋
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;


    Java实现
        迭代器类 是 容器类 的 内部类
        next() 函数 不仅将游标后移一位，还会 返回当前的元素。



18、访问者模式                            // 解耦

    定义：
        允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。

    不建议使用：
        难理解、难实现，代码的可读性、可维护性 差，实际开发中很少用到。


    设计意图
        解耦操作和对象本身

    函数重载
        在大部分 面向对象编程语言中 是 静态绑定 的

    Double Dispatch
        Single Dispatch
            指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。

        Double Dispatch
            指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。


        “Dispatch”
            可以把方法调用理解为一种 消息传递，也就是“Dispatch”。
            一个对象 调用 另一个对象的方法，就相当于 给它发送一条消息。这条消息起码要包含 对象名、方法名、方法参数。



19、备忘录模式                            // 快照、  副本 -> 恢复

    定义：
        也叫 快照（Snapshot）模式

        在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后 恢复 对象为先前的状态。
            1、不违背封装原则的 前提下
            2、存储副本 -->  后期恢复

    应用场景：
        防丢失、撤销、恢复

    大对象 的备份
        1、只备份必要的恢复信息，结合最新的数据来恢复；
        2、全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。


20、命令模式                             // 函数 -> 对象

    定义：
        命令模式 将 请求（命令）封装为 一个对象，
        这样可以使用 不同的请求 参数化 其他对象（将不同请求依赖注入到其他对象），
        并且能够支持请求（命令）的 排队执行、记录日志、撤销等（附加控制）功能。

    设计意图：
        当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。

    核心实现：
        将 函数 封装成 对象                     // C语言 天然支持 函数参数化

        设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。
        实现的角度  -->  类似 回调

    主要作用

        控制命令的执行

        借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。

    应用场景

        游戏开发

        异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志


    游戏开发

        如：天天酷跑、跑跑卡丁车

        客户端： 交互复杂（ 人物、动作、表情、服装、道具... ）   -->  职责复杂
        后端：   数据（比如积分、生命值、装备）的更新和查询      -->  职责简单的多

        客户端 ⇋ 服务端   数据交互：

            通信方式： 长连接  -->  数据交互频繁、节省网络连接建立的开销
            通信格式： Protocol Buffer、JSON、XML、自定义格式
            请求内容： 指令 和 数据   -->  指令我们也可以叫作事件，数据是执行这个指令所需的数据。

            服务器在接收到客户端的请求之后，解析出 指令和数据，根据指令的不同，执行不同的处理逻辑。

            实现：
                1、线程池
                2、单线程轮询     -->  IO密集型业务

    命令模式 VS 策略模式

        在策略模式中
            不同的策略具有 相同的目的、不同的实现、互相之间可以替换。
            比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。

        在命令模式中
            不同的命令具有 不同的目的，对应不同的处理逻辑，并且互相之间不可替换。


21、解释器模式                            //


22、中介模式                             //






























----------------
总领
----------------


本质：
    设计模式 要干的事情就是 解耦
        创建型模式 是将 创建和使用代码  解耦
        结构型模式 是将 不同功能代码    解耦
        行为型模式 是将 不同的行为代码  解耦


为什么要用设计模式？

    很多设计模式都是试图将 庞大的类拆分 成 更细小的类，然后再通过 某种更合理的结构 组装 在一起。


创建型、结构型、行为型：

    创建型设计模式 主要解决 对象的创建 问题
    结构型设计模式 主要解决 类或对象的组合或组装 问题
    行为型设计模式 主要解决 类或对象之间的交互 问题



设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述。

    实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，
    门面模式 有点类似 迪米特法则（最少知识原则）和 接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。
    此外，门面模式还有点类似 封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。


代理 和 装饰器 设计意图

    代理模式中，  代理类  附加的是 跟原始类无关 的功能。
    装饰器模式中，装饰器类 附加的是 跟原始类相关的 增强功能。



代理、桥接、装饰器、适配器 4 种设计模式的区别：

    代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。

    桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。

    装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。

    适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。


    相似点：
        代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。
        它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。



框架的作用：
    隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。




----------------
重点
----------------

关于所谓的模式，实现和原理并不重要，
重要的是模式的 应用场景、设计意图！！！

切勿本末倒置！！！



设计原则和思想 比 设计模式 更加普适和重要!!!


每个设计模式都应该由两部分组成：
    第一部分是 应用场景，即这个模式   可以解决哪类问题；
    第二部分是 解决方案，即这个模式的 设计思路 和 具体的代码实现。



❌被动地“看”   ✅主动地“思考”

知识是死的，能力才是活的。

