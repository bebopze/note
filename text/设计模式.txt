23 种经典的设计模式

    1. 创建型

        常用：   单例模式、工厂模式（工厂方法和抽象工厂）、Builder(建造者)模式
        不常用： 原型模式

        主要解决：对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。


    2. 结构型

        常用：   代理模式、桥接模式、装饰者模式、适配器模式
        不常用： 门面模式、组合模式、享元模式

        主要解决：结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。

    3. 行为型

        常用：   观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式
        不常用： 访问者模式、备忘录模式、命令模式、解释器模式、中介模式

        主要解决：

面向对象

    面向对象的四大特性：封装、抽象、继承、多态

    面向对象编程与面向过程编程的区别和联系

    面向对象分析、面向对象设计、面向对象编程

    接口和抽象类的区别以及各自的应用场景

    基于接口而非实现编程的设计思想

    多用组合少用继承的设计思想

    面向过程的贫血模型和面向对象的充血模型


设计原则

    SOLID 原则 -SRP 单一职责原则

    SOLID 原则 -OCP 开闭原则

    SOLID 原则 -LSP 里式替换原则

    SOLID 原则 -ISP 接口隔离原则

    SOLID 原则 -DIP 依赖倒置原则

    DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


编码规范

     20 条最快速改善代码质量的编程规范


代码重构

    重构的目的（why）、对象（what）、时机（when）、方法（how）；

    保证重构不出错的技术手段：单元测试和代码的可测试性；

    两种不同规模的重构：大重构（大规模高层次）和 小重构（小规模低层次）。


个人理解

    一切的一切 都是以人为本

    人脑能理解、处理的信息 是非常非常有限的！！！

    认知极限



计算机思维：   二进制指令、汇编语言、面向过程

人类思维：     面向对象




1、单例模式                          // 用来创建 全局唯一的对象

    功能：
        用来创建 全局唯一的对象

    饿汉式、懒汉式

    双重检测

        关于网上人传人的 所谓指令重排导致的 new出来的对象赋值返回之后，还没来得及初始化的问题，给出的 用volatile禁止指令重排 的解决方案！
        这种说法和解决方案，早已过时！！！

        只有很低的Java版本才有这个问题！

        我们现在普遍用的1.8+高版本的JDK，早已在内部实现中解决了这个问题。
        具体的实现也很简单，就是将 new操作 和 初始化操作 设计为原子操作，自然就不存在 指令重排了！！！

    静态内部类

    枚举


2、工厂模式                         // 创建 不同但是相关类型的对象（继承同一父类或者接口的一组子类）

    功能：
        用来创建 不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的 参数来决定 创建哪种类型的对象。

    简单工厂、工厂方法、抽象工厂

    应用场景：
        当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式。

    何为复杂：
        1、大坨 if-else 分支判断，动态地根据不同的类型创建不同的对象。
        2、单个对象本身的创建过程比较复杂，比如要组合其他类对象，做各种初始化操作。

    相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？
        封装对象的创建过程，将对象的创建和使用相分离。

    作用：
        封装变化、代码复用、隔离复杂性、控制复杂度


3、Builder模式                    // 建造者模式 用来创建 复杂对象

    功能：
        用来创建 复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。

    应用场景：
        1、构造函数的参数列表过长，可选参数过多。
        2、一次性初始化，屏蔽中间状态。            // 即：单个单个的set()
        3、创建不可变对象，                      // Builder模式，未对外提供set()，无法修改属性！


4、原型模式                      //  针对 创建成本比较大 的对象

    功能：
        针对 创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

    浅拷贝
        Java 中的 clone() 语法
        只拷贝第一层，引用对象共享 内存地址。

    深拷贝
        递归拷贝 引用对象，直到只有 基本数据 为止。

    应用场景：
        对象的创建成本比较大

            对象中的数据 需要经过 复杂的计算 才能得到（比如排序、计算哈希值），
            或者需要从 RPC、网络、数据库、文件系统等 非常慢速的 IO 中读取.


-----------

5、代理模式

    在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

    实现：
        1、通过实现相同的接口     -->  静态实现：手动创建Proxy      /      动态实现： JDK   Proxy
        2、继承被代理类          -->  静态实现  手动创建Proxy      /      动态实现： Cglib Proxy      --> ASM

    静态代理
        提前  -->  手动创建Proxy
        静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。

    动态代理（Dynamic Proxy）
        运行时  -->  自动动态生成Proxy  -->  替换target
        不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。


    Spring AOP
        底层的实现原理就是 基于动态代理

        步骤：
            用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。
            Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。
            原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。

    应用场景：
        1、非功能性需求
            如：监控、统计、鉴权、限流、事务、幂等、日志。
            与业务功能解耦

        2、RPC、缓存
            RPC 框架也可以看作一种代理模式————远程代理：将网络通信、数据编解码等细节隐藏起来。

            缓存：
                ...
                cache=true/false --> 走缓冲/实时查询


6、桥接模式

    两种理解：

        1、将"抽象"和"实现"解耦，让它们可以独立变化。
             “抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。
             “实现”，也并非“接口的实现类”，而是一套独立的“类库”。
             “抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。

        2、一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。
            “组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。

    经典应用：
        JDBC驱动



7、装饰器模式

    主要解决：
        继承关系过于复杂的问题，通过组合来替代继承。

        "组合优于继承" 原则

    主要作用：
        给原始类添加 增强功能

        这是判断是否该用装饰器模式的一个重要的依据

    特点：
        1、装饰器类和原始类继承同样的父类，这样我们 可以对原始类“嵌套”多个装饰器类。
        2、装饰器类是 对功能的增强，这也是装饰器模式应用场景的一个重要特点。


    对于为什么中间要多继承一个FilterInputStream类，我的理解是这样的：

        假如说 BufferedInputStream 类直接继承自InputStream类，且没有进行重写，只进行了装饰。
        创建一个 InputStream is = new BufferedInputStream(new FileInputStream(FilePath));
        此时调用is的没有重写方法(如read方法)时，调用的是InputStream类中的read方法，而不是FileInputStream中的read方法。
        这样的结果不是我们想要的，所以要将方法再包装一次。

        中间加一层FilterInputStream类，也是避免代码的重复，多个装饰器只用写一遍包装代码即可。


----------------
总领
----------------


为什么要用设计模式？

    很多设计模式都是试图将 庞大的类拆分 成 更细小的类，然后再通过 某种更合理的结构 组装 在一起。


代理 和 装饰器 设计意图

    代理模式中，  代理类  附加的是 跟原始类无关 的功能。
    装饰器模式中，装饰器类 附加的是 跟原始类相关的 增强功能。







