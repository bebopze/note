23 种经典的设计模式

    1. 创建型

        常用：   单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式
        不常用： 原型模式

    2. 结构型

        常用：   代理模式、桥接模式、装饰者模式、适配器模式
        不常用： 门面模式、组合模式、享元模式

    3. 行为型

        常用：   观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式
        不常用： 访问者模式、备忘录模式、命令模式、解释器模式、中介模式


面向对象

    面向对象的四大特性：封装、抽象、继承、多态

    面向对象编程与面向过程编程的区别和联系

    面向对象分析、面向对象设计、面向对象编程

    接口和抽象类的区别以及各自的应用场景

    基于接口而非实现编程的设计思想

    多用组合少用继承的设计思想

    面向过程的贫血模型和面向对象的充血模型


设计原则

    SOLID 原则 -SRP 单一职责原则

    SOLID 原则 -OCP 开闭原则

    SOLID 原则 -LSP 里式替换原则

    SOLID 原则 -ISP 接口隔离原则

    SOLID 原则 -DIP 依赖倒置原则

    DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


编码规范

     20 条最快速改善代码质量的编程规范


代码重构

    重构的目的（why）、对象（what）、时机（when）、方法（how）；

    保证重构不出错的技术手段：单元测试和代码的可测试性；

    两种不同规模的重构：大重构（大规模高层次）和 小重构（小规模低层次）。


个人理解

    一切的一切 都是以人为本

    人脑能理解、处理的信息 是非常非常有限的！！！

    认知极限



计算机思维：   二进制指令、汇编语言、面向过程

人类思维：     面向对象




1、单例模式

    饿汉式、懒汉式

    双重检测

        关于网上人传人的 所谓指令重排导致的 new出来的对象赋值返回之后，还没来得及初始化的问题，给出的 用volatile禁止指令重排 的解决方案！
        这种说法和解决方案，早已过时！！！

        只有很低的Java版本才有这个问题！

        我们现在普遍用的1.8+高版本的JDK，早已在内部实现中解决了这个问题。
        具体的实现也很简单，就是将 new操作 和 初始化操作 设计为原子操作，自然就不存在 指令重排了！！！

    静态内部类

    枚举


2、工厂模式

    简单工厂、工厂方法、抽象工厂

    应用场景：
        当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式。

    何为复杂：
        1、大坨 if-else 分支判断，动态地根据不同的类型创建不同的对象。
        2、单个对象本身的创建过程比较复杂，比如要组合其他类对象，做各种初始化操作。

    相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？
        封装对象的创建过程，将对象的创建和使用相分离。

    作用：
        封装变化、代码复用、隔离复杂性、控制复杂度


3、Builder模式                    // 建造者模式

    应用场景：
        1、构造函数的参数列表过长，可选参数过多。
        2、一次性初始化，屏蔽中间状态。            // 即：单个单个的set()
        3、创建不可变对象，                      // Builder模式，未对外提供set()，无法修改属性！


4、原型模式

    浅拷贝
        Java 中的 clone() 语法
        只拷贝第一层，引用对象共享 内存地址。

    深拷贝
        递归拷贝 引用对象，直到只有 基本数据 为止。

    应用场景：
        对象的创建成本比较大

            对象中的数据 需要经过 复杂的计算 才能得到（比如排序、计算哈希值），
            或者需要从 RPC、网络、数据库、文件系统等 非常慢速的 IO 中读取.


5、代理模式



