------------------------------------------------------------
java 基础，jdk 中常用集合源码,线程池,aqs 等 concurrent 工具类
------------------------------------------------------------

1、Collection

    List    //  有序（存取 顺序一致）

            ArrayList              数组

            LinkedList             链表

            Vector                 数组                           synchronized


    Set     // 无序 + 去重


            HashSet                散列表（HashMap）

            TreeSet                红黑树（TreeMap）


    Map     // 无序 + 去重


            HashMap                散列表 + 链表/红黑树

            TreeMap                红黑树

            Hashtable              散列表 + 链表                   synchronized


    Queue   // 有序 -> 先进先出


        单端队列

            ArrayBlockingQueue          数组（有界）

            LinkedBlockingQueue         链表（无界）

            PriorityBlockingQueue       数组（无界 优先队列）

        双端队列

            Deque



2、equals 和 hashcode

    1、相等（相同）的对象 必须具有相等的哈希码（或者散列码）

    2、如果两个对象的hashCode相同，它们并不一定相同


    equals()

        this == obj                地址值


    hashcode()

        作用于 散列表     确定在散列表中的索引位

        一般作用于引用类型 的比较时
            重写equals()      +       自定义重写hashcode()（成员变量值 相加）



------------------------------------------------------------
并发理论、JVM内存模型
------------------------------------------------------------

1、并发编程 bug 的 源头

    1、可见性       // 共享变量

        缓存

            均衡 CPU 与 内存 的 速度差


            导致新bug：

                不同线程 操作的是 各自的CPU缓存

    2、有序性

        编译优化
            指令重排 -> 提高 缓存 利用率


            导致新bug：

                拿到 未初始化完成 的 对象

    3、原子性

        线程切换

            分时复⽤ CPU，均衡 CPU 与 I/O设备 的速度差

            导致新bug：

                1条 高级语言 语句 = N条 CPU 指令

                CPU 执行单位 -->  1条 CPU 指令

                操作系统 做 线程切换，可以发⽣在 任何⼀条 CPU指令 执⾏完



    -- 再次证明：没有完美的技术，引入一门新的技术 来解决问题的同时，必定会带来新的问题



2、Java 的 解决方案

    1、Java内存模型                                        // 可见性 、 有序性

        Java 中 提出了 JMM（Java内存模型）解决方案

            来解决 可见性 和 有序性 问题

                -- 再次证明：计算机科学领域 的 任何问题 都可以通过 增加一个间接的中间层 来解决

                    - Java 的 内存模型 是 并发编程领域 的 ⼀次重要创新

        JMM的 功能：

            按需 禁用 缓存(可见性) 和 编译优化(有序性)

        提供的 工具：

            volatile、synchronized 和 final 三个关键字，Happens-Before 规则



            Happens-Before 规则：                  // 可见性❗❗❗

                1、Happens-Before 语义 的 现实理解：

                    如果 A事件 是导致 B事件 的 起因，那么 A事件 ⼀定是先于（Happens-Before） B事件 发⽣的


                2、在 Java 语⾔⾥⾯：

                    Happens-Before 的语义：

                        本质上是一种  可见性❗❗❗


                    A Happens-Before B

                        意味着 A事件 对 B事件 来说是可⻅的，⽆论 A事件 和 B事件 是否发⽣在同⼀个线程⾥

                        例如 A事件 发⽣在 线程1 上，B事件 发⽣在 线程2 上，Happens-Before 规则保证 线程2 上也能看到	A事件 的发⽣




            1、volatile：             // 禁用 缓存、编译优化

                1、原始语义：禁用 缓存                                        // 禁用 缓存

                    强制 CPU缓存 刷新至 主内存，并强制 使 其他CPU的缓存 失效，使用时 从主内存 重新读取.


                2、Java 内存模型 在 1.5 版本对 volatile 语义进⾏了增强         // 禁用 缓存、编译优化

                    Happens-Before 规则 增强语义

                        对⼀个 volatile变量 的 写操作， Happens-Before 于 后续对这个 volatile变量 的 读操作   // 可见、顺序

                            ==>  volatile变量 - 写 Happens-Before 后续 读


            2、synchronized          // 禁用 缓存、编译优化                       - https://blog.csdn.net/qq_30118563/article/details/90106667

                1、原始语义：
                    互斥锁

                2、Happens-Before 规则 增强语义

                    对 一个锁 的 解锁 Happens-Before 于 后续对 这个锁 的 加锁            // 可见、顺序

                    // 保证了执行顺序、同时保证了 可见性


                    语义类似 volatile

                        锁释放、获取锁 的 内存语义：
                            释放 锁 时，会将 持锁线程 的 工作内存的共享变量值 刷到 主内存
                            获取 锁 时，JMM 将 持锁线程的 工作内存 置为无效，临界区代码 必须从 主内存中 读共享变量

                            锁释放 与 volatile写，锁获取 与 volatile读 有相同内存语义！！！

                        小结：
                            A释放锁    ->    即 A 向后来将拿锁的 线程B 发送 一个消息
                            B获取锁    ->    即 B 接收了 之前释放锁的 线程A 的一个消息
                            A释放锁、B获取锁，其实就是 A向B 发送个消息



                        synchronized关键字的内存语义            - 摘自：Java并发编程之美                 - https://www.cnblogs.com/cold-windy/p/11743013.html

                            加锁 和 释放锁 的语义：
                                当 获取 锁 以后， 会 清空 锁块内 本地内存中将会被用到的共享变量，在 使用这些共享变量时 从 主内存 进行加载
                                在 释放 锁 时，   将 本地内存中修改的 共享变量 刷新到 主内存 中

                        进入 synchronized块 的 内存语义：

                            把 在synchronized块内 使用到的变量 从 线程的工作内存中 清除，这样在 synchronized 块中 使用到该变量时，
                            就不会从线程的工作内存中获取，而是直接从主内存中获取

                        退出 synchronized块 的 内存语义：

                            把 在synchronized块内 对共享变量的修改 刷新到 主内存




            3、程序的顺序性规则       // 顺序、可见

                在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作             // 同一线程

                可以重排，但是要保证 符合 Happens-Before 规则
                Happens-Before 规则 关注的是 可见性❗❗❗

                所谓顺序：

                    指的是 你可以用 顺序的方式 推演 程序的执行，但是 程序的执行 不一定是 完全顺序的

                    编译器保证：

                        结果一定  ==  顺序方式 推演的结果


            4、传递性                // 顺序、可见

            5、线程 start() 规则     // 顺序、可见

            6、线程 join() 规则      // 顺序、可见


        final

            告诉编译器优化得更好一点

            final 修饰变量时，初衷是告诉编译器：  这个变量 ⽣⽽不变，可以 可劲儿优化

            final修饰符：

                final修饰的实例字段则是 涉及到 新建对象的发布问题

                当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。


        实现：
            JVM内部实现   - JVM编程人员实现

            ----------------------------
            Java内存模型底层怎么实现的？

                主要是通过 内存屏障(memory barrier) 禁止重排序的

                即时编译器 根据 具体的 底层体系架构：

                    将这些 内存屏障 替换成 具体的 CPU 指令


                对于编译器而言：

                    内存屏障将限制它所能做的重排序优化

                而对于处理器而言：

                    内存屏障将会导致缓存的刷新操作


                比如，对于volatile：

                    编译器将在volatile字段的读写操作前后各插入一些内存屏障



    2、互斥锁         // 原子性

        功能：

            按需 禁用 "线程切换"

                非真正的 禁用 "线程切换"，CPU 在 单位时间片 后 依然会做 线程切换，

                只是切换时，锁 不会释放，其他线程拿到了CPU使用权，然后获取不到锁，就进不来临界区，继续被挂起

                然后继续 重新分配 CPU使用权

                持有 锁 的线程 重新争夺到 CPU使用权 后，程序可继续执行，就保证了 执行不中断  ---> 保证了 原子性

        工具：
            synchronized、Lock







------------------------------------------------------------
编程模型、并发工具
------------------------------------------------------------



1、并发编程 核心

    落实到我们编程人员的这里，编写并发程序，主要就是三点：

        分工、同步、互斥

        所以，JDK 内容看起来繁杂，但是其实就是针对这三类问题，提供的各种对应 工具 而已


    分工

        拆解任务 -> 并分配给线程          // 串行 -> 并行


        分工工具：
            线程池、Fork/Join

    同步

        线程协作                        // 任务依赖 -> 线程通信


        同步工具：
            CountDownLatch、CyclicBarrier
            synchronized                    ->  wait()、notify()、notifyAll()
            Lock - Condition                ->  await()、signal()、signalAll()

    互斥

        共享资源 竞争                   // 同一时刻 只允许 一个线程 访问


        互斥工具：
            synchronized、Lock




4、分工                    // 任务拆分         串行 -> 并行

    Fork/Join

    线程池


5、同步                    // 线程通信

    CountDownLatch        ->    AQS

    CyclicBarrier         ->    ReentrantLock -> AQS


    Condition


6、互斥                    // 锁

    synchronized        - 互斥                 阻塞 / 无超时 / 不可中断                      管程模型

        同步
            wait()

            notify()

            notifyAll()


    Lock                - 互斥                                                              管程模型

        lock()                                  阻塞

        tryLock()                               非阻塞

        tryLock(long time, TimeUnit unit)       超时

        lockInterruptibly()                     可中断



        同步
            Condition newCondition()

                await()

                signal()

                signalAll()



        ReentrantLock                          ->    AQS

        ReentrantReadWriteLock

            ->    StampedLock（1.8 读写锁  乐观读[无锁]）



    Semaphore                   信号量模型

                                               ->    AQS

        没对外暴露 Condition





7、并发容器/原子类


    有锁

        ConcurrentHashMap

    无锁

        Atomic



8、Java内存模型

    缓存

        按需禁用            ->      volatile

    编译优化

        按需禁用            ->      Happens-Before、synchronized、final

                                    顺序              // 同一线程
                                    可见              // 跨线程      共享变量            写 -HB-> 后续 读
                                    传递              // 跨线程
                                    锁                // 跨线程      释放 -HB-> 后续 获取
                                    start()           // 跨线程      主-子线程 通信      主--start-->子     主 -HB-> 子
                                    join()            // 跨线程      子-主线程 通信      主--join--> 子     子 -HB-> 主








------------------------------------------------------------
基本数据结构与算法
------------------------------------------------------------


------------------------------------------------------------
tcp/ip 网络
------------------------------------------------------------





------------------------------------------------------------
mysql 关系型数据库,mysql 索引，innodb 锁机制
------------------------------------------------------------


------------------------------------------------------------
jvm 内存分布
------------------------------------------------------------


------------------------------------------------------------
分布式事物，最终一致性等解决方案
------------------------------------------------------------


------------------------------------------------------------
cap、base 理论，了解 raft 一致性算法
------------------------------------------------------------



------------------------------------------------------------
springmvc，spring，mybatis
------------------------------------------------------------




------------------------------------------------------------
dubbo 框架，掌握 dubbo RPC 原理、负载均衡、容错机制
------------------------------------------------------------




------------------------------------------------------------
cloud
------------------------------------------------------------





------------------------------------------------------------
hystrix sentinel 服务熔断降级框架
------------------------------------------------------------


