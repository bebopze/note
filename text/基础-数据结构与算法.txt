------------------------------------------------------------
基本数据结构与算法
------------------------------------------------------------

1、数据结构 与 算法

    1、广义：

        数据结构    指一组数据的存储结构

        算法        操作数据的一组方法


    2、狭义：

        某些著名的 数据结构和算法

        比如 队列、栈、堆、二分查找、动态规划


2、复杂度分析

    时间复杂度               // 执行时间

        全称是 渐进时间复杂度

        表示 算法的执行时间 与 数据规模 之间的 增长关系

    空间复杂度               // 占用空间

        全称是 渐进空间复杂度

        表示 算法的存储空间 与 数据规模 之间的 增长关系


    --------------------------------
    复杂度：
            也叫 渐进复杂度

        包括：
            时间复杂度 和 空间复杂度

        用来：
            分析 算法执行效率 与 数据规模 之间的 增长关系

        可以粗略地表示：

            越 高阶 复杂度的算法，执行效率越 低


        常见的复杂度并不多，从低阶到高阶有：

            O(1)、O(logⁿ)、O(n)、O(nlogⁿ)、O(n²)

            - 几乎所有的 数据结构和算法 的复杂度 都跑不出这几个


3、数组 和 链表

    1、可以说 最原始的数据结构 就2个：

        数组
            通过索引，前后串联           // 内存连续，一次性申请固定连续内存，拿到base_address，然后基于此做递增的 寻址计算  ->  索引

                                                // a[i]_address = base_address + i * data_type_size

                                                // ==> 拿到base_address时，每个索引位的 内存地址值 就已经确认了  -> 寻址公式 唯一的变量只剩 index

        链表
            通过指针，前后串联           // 内存不连续，寻址公式条件不存在  -->  无索引，前后通过 地址指针 连接


    2、其他数据结构，不过是基于 数组、链表 的二次封装，或 二者的组合：

        队列      // 数组、链表

        栈        // 数组、链表

        散列表     // 数组、链表


        二叉树、堆、图...         // 数组、链表



4、用途：

    存
        插入、删除

    取
        查询


5、线性 与 非线性       // 一维 、 多维

    线性              // 一维

        数组、链表、队列、栈...


    非线性            // 二维、图...

        二叉树、堆、图



6、树

    1、树的 基本定义：


        树 节点：

            根节点

                没有父节点的节点

            父节点

            子节点

            叶子节点

                没有子节点的节点

            兄弟节点


        树 属性：

            高度（Height）

                下 -> 上              0 开始

            深度（Depth）

                上 -> 下              0 开始

            层（Level）

                上 -> 下              1 开始




    2、二叉树               // 最常用 的树                   时间：O(n)


        1、基本定义：

            节点：

                每个节点  最多 两个“叉”

                    左子节点 和 右子节点

            分类：

                1、普通二叉树


                2、满二叉树                                // 满二叉树 又是 完全二叉树  的一种特殊情况

                    每个节点都有 左右两个子节点

                3、完全二叉树

                    最后一层的叶子节点 都靠左排列


        2、存储：

            1、链式 存储法                     // 常用  -> 大部分二叉树   都是通过 链式存储 来实现的

                基于 指针或引用  的  二叉链式存储法


                每个节点有三个字段：

                    data

                        存储数据

                    left、right                  // 空间换时间        ->  额外存储 左右子节点 指针

                        指向左右子节点的 指针


            2、数组 顺序存储法                    // 适用 -> 完全二叉树        ===>  仅浪费 0号位

                基于 数组 的顺序存储法

                    1、完全二叉树：

                        根节点      ->  数组下标 1 开始          // 仅“浪费” 1个 下标为0 的存储位置

                        左子节点        2i             // i 为父节点 索引位  -->  初始根节点 从 i=1 开始
                        右子节点        2i + 1


                        优点：

                            1、仅“浪费” 1个 下标为0 的存储位置：

                                如果某棵二叉树是一棵 完全二叉树

                                那用数组存储 无疑是最节省内存的一种方式


                            2、数组的存储方式 不需要像 链式存储法那样，要 存储额外的 左右子节点的指针

                                这是 完全二叉树 单独拎出来的原因

                                也是 完全二叉树要求 最后一层的子节点都靠左 的原因


                    2、非完全二叉树

                        会浪费比较多的 数组存储空间



        3、遍历（查找）：               // 前、中、后序  ->  节点 与 左右子节点  遍历打印的 先后顺序


            1、如何将 所有节点 都遍历打印出来

                1、前序遍历

                    节点  ->  左  ->  右

                2、中序遍历

                    左  ->  节点  ->  右

                3、后序遍历

                    左  ->  右  ->  节点


            2、递归：

                1、前序遍历的递推公式：

                    preOrder(r) = print r  ->  preOrder(r->left)  ->  preOrder(r->right)

                2、中序遍历的递推公式：

                    inOrder(r) = inOrder(r->left)  ->  print r  ->  inOrder(r->right)

                3、后序遍历的递推公式：

                    postOrder(r) = postOrder(r->left)  ->  postOrder(r->right)  ->  print r



                实际上，二叉树的 前、中、后序遍历 就是一个递归的过程

                    写递推公式的关键就是

                        如果要解决问题 A，就假设子问题 B、C 已经解决

                        然后再来看如何利用 B、C 来解决 A


            3、时间复杂度

                O(n)

                查看 前、中、后序遍历 的顺序图，可以看出来

                    每个节点最多会被访问两次

                    所以遍历操作的时间复杂度，跟节点的个数 n 成正比

                    也就是说 二叉树遍历 的时间复杂度是 O(n)





7、查询 与 插删                           // 时间 、 空间

    1、底层基础：

        1、查：

            基于 数组索引  的 O(1) 查询：                         // 查：O(1)   、  插删：O(n)

                内存连续 -> 寻址公式，支持索引 -> 随机访问


        2、插、删：

            基于 链表 的 O(1) 插删：                             // 查：O(n)   、  插删：O(1)

                内存不连续  ->  无"位置"一说  ->  只需变更前后元素 指针 指向          // 双向链表 应用更广泛  ->  记录有 前后元素



    2、基于 数组和链表 的组合 ———— 实现 快速的 查+插+删：

        查 + 插、删：                  // 空间换时间


            1、散列表                                       // 时间：O(1)   、  空间：O(1)

                数据结构：

                    数组 + 链表（hash冲突）

                查：
                    hash  ->  index  ->  链表遍历

                维护：

                    hash冲突，链表维护

                区间查：

                    无序 -> 不支持 区间查找

            2、跳表                                        // 时间：O(logn)   、  空间：O(logn)

                数据结构：

                    链表 + 索引

                空间：
                    多级索引

                查：
                    二分查找

                维护：
                    索引维护，复杂度上升

                区间查：

                    有序 -> 支持 区间查找



            3、二叉树






            4、红黑树                                       // 时间：O(logn)   、  空间：O(logn)

                数据结构：

                    二叉树






        跳表、红黑树      查、插、删    ->  时间 O(logn)     空间 O(n)

            1960s   红黑树
            1970s   B+树
            1990s   跳表          后发优势 ==>  实现简单         // 动态数据结构，实现不会简单到哪去，但是比起红黑树，还是要简单的多

















