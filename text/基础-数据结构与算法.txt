------------------------------------------------------------
基本数据结构与算法
------------------------------------------------------------

1、数据结构 与 算法

    1、广义：

        数据结构    指一组数据的存储结构

        算法        操作数据的一组方法


    2、狭义：

        某些著名的 数据结构和算法

        比如 队列、栈、堆、二分查找、动态规划


2、复杂度分析

    时间复杂度               // 执行时间

        全称是 渐进时间复杂度

        表示 算法的执行时间 与 数据规模 之间的 增长关系

    空间复杂度               // 占用空间

        全称是 渐进空间复杂度

        表示 算法的存储空间 与 数据规模 之间的 增长关系


    --------------------------------
    复杂度：
            也叫 渐进复杂度

        包括：
            时间复杂度 和 空间复杂度

        用来：
            分析 算法执行效率 与 数据规模 之间的 增长关系

        可以粗略地表示：

            越 高阶 复杂度的算法，执行效率越 低


        常见的复杂度并不多，从低阶到高阶有：

            O(1)、O(logⁿ)、O(n)、O(nlogⁿ)、O(n²)

            - 几乎所有的 数据结构和算法 的复杂度 都跑不出这几个


3、数组 和 链表

    1、可以说 最原始的数据结构 就2个：

        数组
            通过索引，前后串联           // 内存连续，一次性申请固定连续内存，拿到base_address，然后基于此做递增的 寻址计算  ->  索引

                                                // a[i]_address = base_address + i * data_type_size

                                                // ==> 拿到base_address时，每个索引位的 内存地址值 就已经确认了  -> 寻址公式 唯一的变量只剩 index

        链表
            通过指针，前后串联           // 内存不连续，寻址公式条件不存在  -->  无索引，前后通过 地址指针 连接


    2、其他数据结构，不过是基于 数组、链表 的二次封装，或 二者的组合：

        队列      // 数组、链表

        栈        // 数组、链表

        散列表     // 数组、链表


        二叉树、堆、图...         // 数组、链表



4、用途：

    存
        插入、删除

    取
        查询


5、线性 与 非线性       // 一维 、 多维

    线性              // 一维

        数组、链表、队列、栈...


    非线性            // 二维、图...

        二叉树、堆、图




6、查询 与 插删                           // 时间 、 空间

    1、底层基础：

        1、查：

            基于 数组索引  的 O(1) 查询：                         // 查：O(1)   、  插删：O(n)

                内存连续 -> 寻址公式，支持索引 -> 随机访问


        2、插、删：

            基于 链表 的 O(1) 插删：                             // 查：O(n)   、  插删：O(1)

                内存不连续  ->  无"位置"一说  ->  只需变更前后元素 指针 指向          // 双向链表 应用更广泛  ->  记录有 前后元素



    2、基于 数组和链表 的组合 ———— 实现 快速的 查+插+删：

        查 + 插、删：                  // 空间换时间


            1、散列表                                       // 时间：O(1)   、  空间：O(1)

                数据结构：

                    数组 + 链表（hash冲突）

                查：
                    hash -> index  / 链表遍历

                维护：

                    hash冲突，链表维护

                区间查：

                    无序 -> 不支持 区间查找

            2、跳表                                        // 时间：O(logn)   、  空间：O(logn)

                数据结构：

                    链表 + 索引

                空间：
                    多级索引

                查：
                    二分查找

                维护：
                    索引维护，复杂度上升

                区间查：

                    有序 -> 支持 区间查找



            3、红黑树                                       // 时间：O(logn)   、  空间：O(logn)

                数据结构：

                    二叉树






        跳表、红黑树      查、插、删    ->  时间 O(logn)     空间 O(n)

            1960s   红黑树
            1970s   B+树
            1990s   跳表          后发优势 ==>  实现简单         // 动态数据结构，实现不会简单到哪去，但是比起红黑树，还是要简单的多

















