========================================================================================================================
事务
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这句话能具体说明吗?

    就是语句开始执行前 创建一个read-view

------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
磁盘、IO、随机读写、顺序读写
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
磁盘读取时间基本概念

    寻道时间    表示磁头在不同磁道之间移动的时间。
    旋转延迟    表示在磁道找到时，中轴带动盘面旋转到合适的扇区开头处。
    传输时间    表示盘面继续转动，实际读取数据的时间。

    7200转/min
        旋转一周需要8.33ms，寻道约10ms
        所以整个磁盘读取时间在一个磁道上是10ms级的

------------------------------------------------------------------------------------------------------------------------
随机读写 与 顺序读写

    顺序写 磁头几乎不用换道，或者换道的时间很短
    随机写 会导致磁头不停地换道，造成效率的极大降低

    -------------------
    顺序读写    读取一个大文件

    随机读写    读取多个小文件


------------------------------------------------------------------------------------------------------------------------
顺序读写 比 随机读写 快

    传输时间

        顺序读写：主要时间花费在了传输时间，而这个时间两种读写可以认为是一样的。

        随机读写：需要多次寻道和旋转延迟，而这个时间可能是传输时间的许多倍。

    预读          // 类比 有序数组(连续空间) 对CPU缓存友好

        顺序读写：磁盘会预读，预读即在读取的起始地址连续读取多个页面
                （现在不需要的页面也读取了，这样以后用时就不用再读取，当一个页面用到时，大多数情况下，它周围的页面也会被用到）

        随机读写：因为数据没有在一起，将预读浪费掉了

    文件系统的overhead
        读写一个文件之前，得一层层目录找到这个文件，以及做一堆属性、权限之类的检查。

    查找磁盘可用空间的耗时
        小文件，这些时间消耗的占比就非常大了

------------------------------------------------------------------------------------------------------------------------
随机关注IOPS，顺序关注吞吐量

    随机读写的话，每次IO操作的 寻址时间和旋转延时 都不能忽略不计，而这两个时间的存在也就 限制了IOPS的大小；

    而顺序读写，可以忽略不计 寻址时间和旋转延时，主要花费在 数据传输的时间上。


------------------------------------------------------------------------------------------------------------------------
局部预读性原理         // 相同的还有 有序数组(空间连续) 的读取

    当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。
    每一次IO读取的数据我们称之为一页(page)

    具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO

    这个理论对于索引的数据结构设计非常有帮助。


------------------------------------------------------------------------------------------------------------------------
访问磁盘和内存索引涉及磁盘(sata，ssd，nvm)读写性能，以及内存读写性能，可否给一些数值方便直观认识?

    我估计你要的是这个：

    This group of numbers is from a presentation Jeff Dean gave at a Engineering All-Hands Meeting at Google.

    L1 cache reference                                      0.5 ns
    Branch mispredict                                         5 ns
    L2 cache reference                                        7 ns
    Mutex lock/unlock                                       100 ns
    Main memory reference                                   100 ns
    Compress 1K bytes with Zippy                         10,000 ns
    Send 2K bytes over 1 Gbps network                    20,000 ns
    Read 1 MB sequentially from memory                  250,000 ns
    Round trip within same datacenter                   500,000 ns
    Disk seek                                        10,000,000 ns
    Read 1 MB sequentially from network              10,000,000 ns
    Read 1 MB sequentially from disk                 30,000,000 ns
    Send packet CA->Netherlands->CA                 150,000,000 ns
------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
索引、B+树、树高、IO次数
========================================================================================================================
                                                   // B树、B+树详解  - https://www.cnblogs.com/lianzhilei/p/11250589.html
------------------------------------------------------------------------------------------------------------------------
B树 - 树高 - IO次数

    索引查询的数据 主要受限于硬盘的I/O速度，查询I/O 次数越少，速度越快，所以B树的结构才应运而生；

    B树的每个节点的元素 可以视为一次I/O读取，树的高度 表示最多的I/O次数；

    在元素总数量相同的情况下，每个节点的 元素个数越多（子节点个数越多），高度越低，查询所需的I/O次数越少；

        假设，一次硬盘I/O数据为8K，索引用 int(4字节)类型 数据建立，理论上一个节点 最多可以为2000个元素，

        2000^3 = 80亿，80亿条的数据只需3次I/O（理论值），可想而知，B树做为索引的查询效率有多高；

    另外也可以看出同样的总元素个数，查询效率和树的高度密切相关

------------------------------------------------------------------------------------------------------------------------
B树(B-Tree) 与 B+树(B-Plus Tree)           // B的意思为：平衡

    B树  内部节点中的元素 存储了指针和数据。
    B+树 内部节点中的元素 只存储了指向子节点的指针，只作为索引，所以相对于B树 内部节点占用的空间更小。

    B树
        子结点 存储了 data

    B+树     // 结构近似 跳表      ->      多级索引 + 链表(data)

        子结点      -> 多级索引    ——> 未存储 data ，仅作为 叶子结点 的索引

        叶子结点    ->  链表       ——> 有序链表，存储有数据


------------------------------------------------------------------------------------------------------------------------
为什么说 B+树 比 B树 更适合数据库索引？

    1、B+树的磁盘  读写代价更低

        B+树的内部结点 并没有指向 关键字具体信息的指针。

        因此其内部结点 相对B树更小，

        如果把 所有同一内部结点的关键字 存放在同一盘块中，那么盘块所能容纳的 关键字数量也越多。

        一次性读入内存 中的需要查找的关键字 也就越多，相对来说 IO读写次数 也就降低了。


    2、B+树查询效率  更加稳定

        由于 非叶子结点 并不是最终指向文件内容的结点，而只是 叶子结点中关键字 的索引。

        所以 任何关键字的查找 必须走一条 从root结点到叶子结点 的路。

        所有关键字查询的 路径长度相同，导致每一个数据的查询 效率相当。


    3、B+树便于  范围查询（最重要的原因，范围查找是数据库的常态）       // B树的范围查找用的是 中序遍历，而B+树用的是 链表遍历

        B树 在提高了IO性能的同时 并没有解决元素遍历效率低下的问题，

        正是为了解决这个问题，B+树应用而生。

        B+树 只需要去遍历叶子节点 就可以实现整棵树的遍历。

        而且在数据库中 基于范围的查询 是非常频繁的，而 B树 不支持 这样的操作 或者说效率太低。


------------------------------------------------------------------------------------------------------------------------
二叉树的搜索效率最高，实际上 MySQL索引 却并不使用二叉树

    索引 的存储：

        索引是以 树形 存储在磁盘中     ->   持久化了 完整的 搜索树 结构

            更新数据时，同步更新 索引B+树，并持久化到磁盘

            读取时，搜索树已提前创建，通过IO，直接走 树搜索 即可

    数据 存储的过程：

        1、写一份保存到磁盘

        2、写一份保存在索引      ->   以 B+树的结构 保存在磁盘


------------------------------------------------------------------------------------------------------------------------
索引的由来，为何选取 多叉(B+树)，而不用效率最高的 二叉？

    表数据 结构化存储在 磁盘，我们不仅要存，还要取

    成千上万的数据，要快速查找，类比现实经验，图书馆海量图书的图书索引
    数据库也提出了 数据库索引

    且，索引必须是实时维护、同步更新
    提前生成的，不可能每次查的时候，再去生成...

    索引既要满足  ->  高效查询
    同时还要满足 实时维护、同步更新   ->  高效写

    索引存储 数据结构 的选取    ===>   二叉搜索树  ->  读写 O(logN)
    但是二叉的子节点过少 -> 导致树高过高 -> IO次数过多 -> 查询效率 最终还是低下
    索引，实际数据库索引 一般都选择 多叉树 -> 降低树高 -> 减少IO次数 -> 提高查询效率

    MySQL  ->  B+树


------------------------------------------------------------------------------------------------------------------------
B+树

    多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。
    二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。
    其原因是，索引不止存在内存中，还要写到磁盘上。



------------------------------------------------------------------------------------------------------------------------
B+树      // 一个结点  =  一个页

    构造索引 所用到的数据结构

    在实际设计中：
        我们把 一个结点 设为一个页

    为什么这么干呢：
        因为磁盘预读是以页为单位的
        所以这样的话 一页就代表访问一次磁盘，也就是代表 一次I/O操作



------------------------------------------------------------------------------------------------------------------------
B树： 我们假设如果是4阶的，那么每个结点最多3个关键字，最少两个（根节点最少1个）
    也就是说，我们最多也就要访问3次磁盘就可以完成访存，而传统的访存需要每一个关键字都进行访存，可以看出B树的优势
    注意B树的非叶结点不单单只有key值，还有key对应数据在磁盘的具体地址

B+树： 相对与B树而言，B+树的非叶结点值只存有key值，不含有卫星数据
    比较而言就会有更大的空间，就可以存更多的key值，就会显得更加“矮胖”，矮了操作数就相对会更少一些
    同时由于B+树增加了一个最小关键字的根结点，所以顺序访问更加便捷



------------------------------------------------------------------------------------------------------------------------
索引
    1. 主键索引的叶子结点存储了整一行的内容（聚簇索引），使用主键可以快速获取到整行的数据。

    2. 非主键索引的叶子结点存储的是主键的值，所以主键字段占用空间不宜过大。
        同时，其查找数据的过程称为“回表”，需要先查找自己得到主键值，再在主键索引上边查找数据内容。

    3. 索引的实现由存储引擎来决定，InnoDB使用B+树（N叉树，比如1200叉树），把整颗树的高度维持在很小的范围内
        同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。

    4. B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗
        所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一。

    5. 在Key-Value的场景下，只有一个索引且是唯一索引，则适合直接使用业务字段作为主键索引。


------------------------------------------------------------------------------------------------------------------------
索引只能定位到page，page内部怎么去定位行数据

    内部有个 有序数组，二分法

------------------------------------------------------------------------------------------------------------------------
主键、普通索引的重建：

    二级索引重建 应该 先建索引 再做删除，如果有查询用到这个索引，此时索引已被删除，会导致业务抖动

    主键重建 不能采用drop这种方式去按操作，因为所有数据 都是以主键组织的，
    删了主键后，InnoDB会自己找一个主键组织数据，再次添加主键又会重新组织数据，
    重建表的次已达二次，我们可以直接Optimiz这个表


------------------------------------------------------------------------------------------------------------------------
没有主键的表，有一个普通索引，怎么回表？
    没有主键的表，InnoDB会默认创建一个Rowid做主键

------------------------------------------------------------------------------------------------------------------------
“N叉树”的N值在MySQL中是可以被人工调整的么？

    面试中题面越简单的问题越暗藏凶险，可见一斑...
    可以按照调整key的大小的思路来说；
    如果你能指出来5.6以后可以通过page大小来间接控制应该能加分吧
    面试回答不能太精减，计算方法、前缀索引什么的一起上😄

------------------------------------------------------------------------------------------------------------------------
索引维护

    B+树为了维护索引的有序性，所以需要做索引维护
        页分裂
            页分裂使空间利用率降低了50%
            一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%

        页合并
            当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程

------------------------------------------------------------------------------------------------------------------------
自增主键的使用场景

    1、主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小
    2、业务字段做主键场景：
        1、只有一个索引
        2、该索引必须是唯一索引 这是典型的kv场景
            由于没有其他索引，估不用考虑其它索引叶子节点大小的问题，故将该值设为主键索引

------------------------------------------------------------------------------------------------------------------------
之前看过一遍文章，一直有疑惑：
一个innoDB引擎的表，数据量非常大，根据二级索引搜索 会比主键搜索快
文章阐述的原因是：主键索引和数据行 在一起，非常大 搜索慢
我的疑惑是：通过普通索引找到主键ID后，同样要跑一边主键索引，还望老师解惑...

    问出这个问题表示你今天的文章看明白了👍
    看完明天的（下），我估计你就有答案了


------------------------------------------------------------------------------------------------------------------------
请教下，文中说 非主键索引 会存储主键的值，而文中举例的 非主键索引值 刚好没有重复
问下，如果记录表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,1)、(300,1)、(500,1) 和 (600,1)
那么 非主键索引 k=1的节点，应该记录100，200，300，500，600的值，是这样理解么？

    -   不是，非主键索引上 有5个值，分别是：

            （1，100），（1，200）... （1，600）


------------------------------------------------------------------------------------------------------------------------
如果插入的数据 是在主键树叶子结点 的中间，后面的所有页 如果都是满的状态，
是不是会造成 后面的每一页 都会去进行 页分裂操作，直到最后一个页 申请新页 移过去最后一个值

    不会不会，只会分裂 它要写入的那个页面
    每个页面之间 是用指针串的，改指针就好了，不需要 后面的全部挪动

------------------------------------------------------------------------------------------------------------------------
还有之前看到过说是 插入数据 如果是在 某个数据满了页的首尾，
为了减少数据移动和页分裂，会先去 前后两个页 看看是否满了，如果没满 会先将数据放到前后两个页上，不知道是不是有这种情况？

    对，为了增加空间利用率


------------------------------------------------------------------------------------------------------------------------
非聚集索引上 为啥 叶子节点的value 不是地址，这样可以 直接定位到整条数据，而不用 再次对整棵树 进行查询

    这个叫作“堆组织表”，MyISAM就是这样的，各有利弊
    你想一下如果修改了数据的位置的情况，InnoDB这种模式是不是就方便些

------------------------------------------------------------------------------------------------------------------------
如果我新建一张表，不加任何约束，也就是没有主键。
    当插入一定量的数据库后，我再给一个字段加上主键，那么这个主键会包含一行所有的数据吗？

    - 加主键 就会重建整张表

        没有指定主键约束，InnoDB也会有一个默认主键rowId

        加主键，就相当于删除掉原有的主键索引，然后再添加新的主键


------------------------------------------------------------------------------------------------------------------------
如果业务里只有很少的等值连接查询,是否可以把AHI关掉？

    AHI不是hash索引的意思，这个结构是帮innodb 快速找到叶子结点，所以对于range 查询也有优化作用的

------------------------------------------------------------------------------------------------------------------------
通过explain extend看到 in 会被转换为 or
    但是mysql里in是会先将()列表里面排序，然后在进行二分查找的方式去匹配是否满足，时间复杂度为O(logn)
    请问这里是in里面得值一个个取出来，然后再去索引的叶子节点上利用二分查找法去匹配该值？
    or的时间复杂度为O(n)，我理解的是根据or上的值去索引扫描到叶子节点得到该值，然后返回根节点继续扫描得到第二个值。
    如果按照我的理解那么or的效率应该比in高啊,请问老师是哪里出错了？

    -   不是，这样其实就已经是拿到结果了，不论是 a in () 还是 “a=X or a=Y”
        你说的这个过程就没有用上a的索引了
        只是在拿到值以后做的判断

------------------------------------------------------------------------------------------------------------------------
什么情况下创建索引才有意义？
    有这个索引带来的查询收益，大于维护索引的代价，就该建😄
    对于可能变成大表的表，实际上如果不建索引会导致全表扫描，这个索引就是必须的

------------------------------------------------------------------------------------------------------------------------
如何查看索引占用多少空间？
    可以估算出来的，根据表的行数和索引的定义。

------------------------------------------------------------------------------------------------------------------------
查看索引数的结构，比如多少个层，多少节点？
    同上，估算
    如果要精确的，就要解数据文件，这个工具可以看看 https://github.com/jeremycole/innodb_diagrams

------------------------------------------------------------------------------------------------------------------------
如何查看索引的利用率。比如我创建了一个索引，是否可以有记录这个索引被调用了多少次？
    performance_schema.table_io_waits_summary_by_index_usage能看到一些信息



------------------------------------------------------------------------------------------------------------------------

