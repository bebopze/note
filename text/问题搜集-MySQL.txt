在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这句话能具体说明吗?

    就是语句开始执行前 创建一个read-view


访问磁盘和内存索引涉及磁盘(sata，ssd，nvm)读写性能，以及内存读写性能，可否给一些数值方便直观认识?

    我估计你要的是这个：

    This group of numbers is from a presentation Jeff Dean gave at a Engineering All-Hands Meeting at Google.

    L1 cache reference 0.5 ns
    Branch mispredict 5 ns
    L2 cache reference 7 ns
    Mutex lock/unlock 100 ns
    Main memory reference 100 ns
    Compress 1K bytes with Zippy 10,000 ns
    Send 2K bytes over 1 Gbps network 20,000 ns
    Read 1 MB sequentially from memory 250,000 ns
    Round trip within same datacenter 500,000 ns
    Disk seek 10,000,000 ns
    Read 1 MB sequentially from network 10,000,000 ns
    Read 1 MB sequentially from disk 30,000,000 ns
    Send packet CA->Netherlands->CA 150,000,000 ns




索引
    1. 主键索引的叶子结点存储了整一行的内容（聚簇索引），使用主键可以快速获取到整行的数据。

    2. 非主键索引的叶子结点存储的是主键的值，所以主键字段占用空间不宜过大。
        同时，其查找数据的过程称为“回表”，需要先查找自己得到主键值，再在主键索引上边查找数据内容。

    3. 索引的实现由存储引擎来决定，InnoDB使用B+树（N叉树，比如1200叉树），把整颗树的高度维持在很小的范围内
        同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。

    4. B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗
        所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一。

    5. 在Key-Value的场景下，只有一个索引且是唯一索引，则适合直接使用业务字段作为主键索引。



索引只能定位到page，page内部怎么去定位行数据

    内部有个 有序数组，二分法


主键、普通索引的重建：

    二级索引重建 应该 先建索引 再做删除，如果有查询用到这个索引，此时索引已被删除，会导致业务抖动

    主键重建 不能采用drop这种方式去按操作，因为所有数据 都是以主键组织的，
    删了主键后，InnoDB会自己找一个主键组织数据，再次添加主键又会重新组织数据，
    重建表的次已达二次，我们可以直接Optimiz这个表



没有主键的表，有一个普通索引，怎么回表？
    没有主键的表，InnoDB会默认创建一个Rowid做主键


“N叉树”的N值在MySQL中是可以被人工调整的么？

    面试中题面越简单的问题越暗藏凶险，可见一斑...
    可以按照调整key的大小的思路来说；
    如果你能指出来5.6以后可以通过page大小来间接控制应该能加分吧
    面试回答不能太精减，计算方法、前缀索引什么的一起上😄




索引维护

    B+树为了维护索引的有序性，所以需要做索引维护
        页分裂
            页分裂使空间利用率降低了50%
            一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%

        页合并
            当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程


自增主键的使用场景

    1、主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小
    2、业务字段做主键场景：
        1、只有一个索引
        2、该索引必须是唯一索引 这是典型的kv场景
            由于没有其他索引，估不用考虑其它索引叶子节点大小的问题，故将该值设为主键索引


之前看过一遍文章，一直有疑惑：
一个innoDB引擎的表，数据量非常大，根据二级索引搜索 会比主键搜索快
文章阐述的原因是：主键索引和数据行 在一起，非常大 搜索慢
我的疑惑是：通过普通索引找到主键ID后，同样要跑一边主键索引，还望老师解惑...

    问出这个问题表示你今天的文章看明白了👍
    看完明天的（下），我估计你就有答案了



请教下，文中说 非主键索引 会存储主键的值，而文中举例的 非主键索引值 刚好没有重复
问下，如果记录表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,1)、(300,1)、(500,1) 和 (600,1)
那么 非主键索引 k=1的节点，应该记录100，200，300，500，600的值，是这样理解么？

    -   不是，非主键索引上 有5个值，分别是：

            （1，100），（1，200）... （1，600）


如果插入的数据 是在主键树叶子结点 的中间，后面的所有页 如果都是满的状态，
是不是会造成 后面的每一页 都会去进行 页分裂操作，直到最后一个页 申请新页 移过去最后一个值

    不会不会，只会分裂 它要写入的那个页面
    每个页面之间 是用指针串的，改指针就好了，不需要 后面的全部挪动

还有之前看到过说是 插入数据 如果是在 某个数据满了页的首尾，
为了减少数据移动和页分裂，会先去 前后两个页 看看是否满了，如果没满 会先将数据放到前后两个页上，不知道是不是有这种情况？

    对，为了增加空间利用率



非聚集索引上 为啥 叶子节点的value 不是地址，这样可以 直接定位到整条数据，而不用 再次对整棵树 进行查询

    这个叫作“堆组织表”，MyISAM就是这样的，各有利弊
    你想一下如果修改了数据的位置的情况，InnoDB这种模式是不是就方便些


如果我新建一张表，不加任何约束，也就是没有主键。
    当插入一定量的数据库后，我再给一个字段加上主键，那么这个主键会包含一行所有的数据吗？

    - 加主键 就会重建整张表

        没有指定主键约束，InnoDB也会有一个默认主键rowId

        加主键，就相当于删除掉原有的主键索引，然后再添加新的主键



如果业务里只有很少的等值连接查询,是否可以把AHI关掉？

    AHI不是hash索引的意思，这个结构是帮innodb 快速找到叶子结点，所以对于range 查询也有优化作用的


通过explain extend看到 in 会被转换为 or
    但是mysql里in是会先将()列表里面排序，然后在进行二分查找的方式去匹配是否满足，时间复杂度为O(logn)
    请问这里是in里面得值一个个取出来，然后再去索引的叶子节点上利用二分查找法去匹配该值？
    or的时间复杂度为O(n)，我理解的是根据or上的值去索引扫描到叶子节点得到该值，然后返回根节点继续扫描得到第二个值。
    如果按照我的理解那么or的效率应该比in高啊,请问老师是哪里出错了？

    -   不是，这样其实就已经是拿到结果了，不论是 a in () 还是 “a=X or a=Y”
        你说的这个过程就没有用上a的索引了
        只是在拿到值以后做的判断


什么情况下创建索引才有意义？
    有这个索引带来的查询收益，大于维护索引的代价，就该建😄
    对于可能变成大表的表，实际上如果不建索引会导致全表扫描，这个索引就是必须的

如何查看索引占用多少空间？
    可以估算出来的，根据表的行数和索引的定义。

查看索引数的结构，比如多少个层，多少节点？
    同上，估算
    如果要精确的，就要解数据文件，这个工具可以看看 https://github.com/jeremycole/innodb_diagrams

如何查看索引的利用率。比如我创建了一个索引，是否可以有记录这个索引被调用了多少次？
    performance_schema.table_io_waits_summary_by_index_usage能看到一些信息





