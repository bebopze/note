--------------------------------------------------
1、入门
--------------------------------------------------


1、算法

    掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样.

    实现同一个RPC框架，人与人之间的差别

        - 高手之间的竞争其实就在细节

            算法      是不是够优化
            数据存取   的效率是不是够高
            内存      是不是够节省


2、什么数据结构？什么是算法？

    从广义上讲

        数据结构  就是 指一组数据的存储结构
        算法     就是 操作数据的一组方法

            - 图书馆储藏书籍


    从狭义上讲

        是指 某些著名的 数据结构和算法，比如 队列、栈、堆、二分查找、动态规划 等


3、数据结构 和 算法  是 相辅相成 的

    数据结构是为算法服务的，算法要作用在特定的数据结构之上。

    因此，我们无法孤立 数据结构 来讲 算法，也无法孤立 算法 来讲 数据结构。



4、重点

    数据结构与算法 中最重要的概念

        — 复杂度分析

            时间复杂度            - 执行时间

                全称是 渐进时间复杂度， 表示 算法的 执行时间 与 数据规模 之间的 增长关系。

            空间复杂度            - 占用空间

                全称是 渐进空间复杂度， 表示 算法的 存储空间 与 数据规模 之间的 增长关系。


    20个 最常用的、最基础 数据结构与算法：

        10个 数据结构：  数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；

        10个 算法：     递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。


5、学习
    1. 边学边练，适度刷题
    2. 多问、多思考、多互动
    3. 打怪升级学习法
    4. 知识需要沉淀，不要想试图一下子掌握所有



6、复杂度分析

    1、事后统计法

    2、粗略地估计算法

        1、大 O 复杂度表示法                            // 正比、趋势                                    //  O   ->  成 正比

            算法的执行效率

                粗略地讲，就是 算法代码 执行的时间


                假设每个语句的执行时间是 unit_time

                    int cal(int n) {
                       int sum = 0;                 // 1    unit_time
                       int i = 1;                   // 1    unit_time
                       for (; i <= n; ++i) {        // n    unit_time
                         sum = sum + i;             // n    unit_time
                       }
                       return sum;
                    }


                    // 总执行时间：   1 * 2 + n * 2  =  （2n + 2）个 单位时间 unit_time


            规律：

                所有代码的执行时间 T(n)   与   每行代码的执行次数 n   成正比

                T(n) = O ( f(n) )

                    T(n) 表示  代码执行的时间；

                    n    表示  数据规模的大小；

                    f(n) 表示  每行代码执行的 次数总和.        ->   因为这是一个公式，所以用 f(n) 来表示

                    O    表示  代码的执行时间 T(n)  与  f(n) 表达式 成正比



                变化趋势

                    大 O 时间复杂度 实际上 并不具体表示 代码真正的执行时间，而是表示 代码执行时间 随 数据规模增长 的 变化趋势。

                    所以，也叫作 渐进时间复杂度（asymptotic time complexity），简称 时间复杂度。



                n 很大时  ->  低阶、常量、系数  ->  不左右增长趋势  -->  忽略   ==>   只需要保留 最大量级

                    n 很大时，你可以把它想象成 10000、100000，
                    而公式中的 低阶、常量、系数 三部分并不左右增长趋势，所以都可以忽略。
                    我们只需要记录一个 最大量级 就可以了.


                    如果用  大 O 表示法  表示 上面代码的 时间复杂度，就可以记为：

                        (2n + 2)                ->      T(n) = O(2n+2)          ->      T(n) = O(n)

                        T(n) = (2n²+2n+3)       ->      T(n) = O(2n²+2n+3)      ->      T(n) = O(n²)



    3、时间复杂度分析

        1. 只关注 循环执行次数最多 的一段代码

            我们在分析一个算法、一段代码的时间复杂度的时候，只关注 循环执行次数最多 的那一段代码 就可以了.


        2. 加法法则：总复杂度 等于 量级最大 的那段代码 的复杂度

            int cal(int n) {

                // 100次
                for (; p < 100; ++p) {
                }

                // n
                for (; q < n; ++q) {
                }

                // n²
                for (; i <= n; ++i) {
                    for (; j <= n; ++j) {
                    }
                }
            }


            3个循环 的 循环次数 分别为：

                100次

                    常数  ->  忽略

                    只要是一个已知的数，跟 n 无关，照样也是 常量级 的执行时间.

                    复杂度，它表示的是一个算法执行效率与数据规模增长的变化趋势。
                    所以不管常量的执行时间多大，我们都可以忽略掉。
                    因为它本身对增长趋势并没有影响。

                n次

                n²次

                    n² > n


            --> 忽略常量100，  比较 n² > n      ==>  总复杂度 = n²

            -->  T1(n) = O(f(n)) ,  T2(n) = O(g(n))

            -->  那么 T(n) = T1(n) + T2(n) = max( O(f(n)) , O(g(n)) ) = O( max( f(n) , g(n) ) )





        3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


            int cal_3(int n) {
                int ret = 0;
                int i = 1;
                // n
                for (; i < n; ++i) {
                    // n
                    ret = ret + f(i);
                }
                return ret;
            }

            int f(int n) {
                int sum = 0;
                int i = 1;
                for (; i < n; ++i) {
                    sum = sum + i;
                }
                return sum;
            }


            -->    T(n) = T1(n) * T2(n) = O(n*n) = O(n²)



7、常见的复杂度量级
                                                                         函数图（ 时间复杂度 -> 耗时 ）

    常量阶         O(1)                                                       水平不变
    对数阶         O(logⁿ)                                                    平缓上升
    线性阶         O(n)                                                       正比上升
    线性对数阶      O(nlogⁿ)                                                   快速上升
    平方阶         O(n²)  、 立方阶O(n³)  ...  k次方阶O(n^k)                    陡峭上升

    指数阶         O(2ⁿ)                                                      指数级   上升
    阶乘阶         O(n!)                                                      超指数级 上升



    非多项式量级                          // 低效

            O(2ⁿ) 和 O(n!)               ->  指数级递增  ->  超级 低效!!!

            当数据规模 n 越来越大 时，非多项式量级算法的执行时间会 急剧增加，求解问题的执行时间会 无限增长。

            所以，非多项式时间复杂度的算法 其实是 非常低效 的算法。



    多项式量级

        O(1)                            // 常量、无循环

            - 常量阶

            O(1) 只是 常量级 时间复杂度的一种表示方法，并不是指只执行了一行代码。

            只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。
            或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。


            这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。

                int i = 8;
                int j = 6;
                int sum = i + j;


        O(logⁿ)、O(nlogⁿ)

            - 对数阶

            O(logⁿ)
                忽略对数的“底”，统一表示为 O(logⁿ)

                    log3ⁿ = log3² * log2ⁿ     ->  忽略常数       ->   log2ⁿ

                    log4ⁿ/log5ⁿ/.../log100ⁿ   =  常数 * log2ⁿ    ->   log2ⁿ

                    ===>   忽略对数的“底”，  log2ⁿ -->   统一表示为 O(logⁿ)



            O(nlogⁿ)
                乘法法则

                    场景：
                        归并排序、快速排序


        O(m+n)、O(m*n)

            由 两个数据的规模 决定

            我们无法事先评估 m 和 n 谁的量级大，
            所以我们在表示复杂度的时候，就 不能 简单地利用 加法法则，省略掉其中一个。
            所以，上面代码的时间复杂度就是 O(m+n)。


                int cal(int m, int n) {

                    int sum_1 = 0;
                    int i = 1;

                    // m
                    for (; i < m; ++i) {
                        sum_1 = sum_1 + i;
                    }


                    int sum_2 = 0;
                    int j = 1;

                    // n
                    for (; j < n; ++j) {
                        sum_2 = sum_2 + j;
                    }

                    return sum_1 + sum_2;
                }

            循环次数：

                m、n         无法判定大小      -->  加法规则 失效

                -->     T1(m) + T2(n) = O(f(m) + g(n))




8、空间复杂度分析

    时间复杂度 全称是  渐进时间复杂度（asymptotic time complexity），  表示 算法的执行时间  与  数据规模  之间的 增长关系

    类比一下

    空间复杂度 全称是  渐进空间复杂度（asymptotic space complexity），表示  算法的存储空间  与  数据规模  之间的 增长关系



    常见的空间复杂度：

        O(1)、O(n)、O(n²)

        像 O(logⁿ)、O(nlogⁿ) 这样的 对数阶 复杂度 平时都用不到

        而且，空间复杂度分析 比 时间复杂度分析 要简单很多






总结

    复杂度：
        也叫 渐进复杂度

    包括：
        时间复杂度 和 空间复杂度

    用来：
        分析 算法执行效率 与 数据规模 之间的 增长关系

    可以粗略地表示：
        越 高阶 复杂度的算法，执行效率越 低

    常见的复杂度并不多，从低阶到高阶有：

        O(1)、O(logⁿ)、O(n)、O(nlogⁿ)、O(n²)

        - 几乎所有的 数据结构和算法 的复杂度 都跑不出这几个



时间复杂度

    1、最好情况  时间复杂度（best case time complexity）                            =====>  O(1)

        - 极端  好运

    2、最坏情况  时间复杂度（worst case time complexity）                           =====>  O(n)

        - 极端  霉运

    3、平均情况  时间复杂度（average case time complexity）                         =====>  O(n)

        最好、最坏情况 时间复杂度 对应的都是 极端情况下 的代码复杂度，发生的概率其实并不大。

        为了更好地表示 平均情况 下的复杂度，我们需要引入另一个概念：平均情况 时间复杂度。



        要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0 ～ n-1 位置中  和  不在数组中。

        我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，

        即：

            总遍历数                (1 + 2 + 3 + ... + n) + n               n(n + 3)                  n² + 3n
        -———————————————    =     ————————————————————————-——     =    ————————————————-    =   ———————————-—————    --->  去除：系数、低阶、常量  ->   O(n)
            总情况数                        n + 1                           2(n + 1)                  2n + 2



    4、均摊  时间复杂度（amortized time complexity）                                  =====>      O(1)

        - 均摊时间复杂度 就是一种 特殊的 平均时间复杂度


        n = 10

            1~9     ->      不走循环    ->      1次          ==>     1 ~ n-1     ->    不走循环      ->      1次

            10      ->      循环       ->      10次          ==>      n          ->     循环        ->      n次


            总执行数                ( 1 x (n-1)  +  n x 1 )             2n - 1
        -———————————————    =     ————————————————————————    =    —————————————————     --->  去除：系数、低阶、常量       ->   O(1)
            总情况数                         n                             n



    场景：

        大部分情况下，我们 并不需要 区分 最好、最坏、平均 三种复杂度。

        平均复杂度 只在 某些特殊情况下 才会用到，

        均摊时间复杂度 应用的场景 比它 更加特殊、更加有限。


    结论：

        最好      ->      O(1)

        最坏      ->      O(n)

        平均      ->      O(n)

                                        第 1 位       ->      执行 1 步
                                        第 2 位       ->      执行 2 步
                                        第 3 位       ->      执行 3 步
                                          ...         ->        ...                                       =======>  O(n)
                                        第 n 位       ->      执行 n 步


        均摊      ->      O(1)

                                        第 1 位           ->      执行 1 步
                                        第 2 位           ->      执行 1 步
                                        第 3 位           ->      执行 1 步
                                          ...             ->         ...                                  =======>  O(1)
                                        第 n - 1 位       ->      执行 1 步
                                        -----------------------------------------------------
                                        第 n 位           ->  触发 遍历循环      ->   执行 n 步







