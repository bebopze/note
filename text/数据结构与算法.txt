----------------------------------------------------------------------------------------------------
2、基础
----------------------------------------------------------------------------------------------------
10 个 数据结构：  数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
10 个 算法   ：   递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
------------------------------------------------------------------------------------------------------------------------


------------------------------------------------- 数据结构 --------------------------------------------------------------

1、数组                            // 线性表、下标、连续内存空间、相同类型数据、随机访问

    定义：
        数组（Array）是一种 线性表 数据结构。它用一组 连续的内存空间 ，来存储一组具有相同类型的数据

    最基础的数据结构：

            每一种编程语言中，基本 都会有数组 这种数据类型

    线性 与 非线性

        线性表
            数据排成 像一条线 一样的结构，每个线性表上的数据 最多只有 前和后 两个方向

            应用：
                数组、链表、队列、栈

        非线性表
            在非线性表中，数据之间并 不是 简单的前后关系

            应用：
                二叉树、堆、图


    连续的内存空间 和 相同类型的数据：

        优点：随机访问     ->  快速 查

                下标 ->  寻址公式   -> 直接定位      ->  O(1)

        缺点：增、删       ->  低效 插删

                为了保证 连续性    ->  需要做大量的 数据搬移 工作


    数组 和 链表 的区别：

        数组 支持 随机访问，根据下标随机访问 的时间复杂度为 O(1)

        链表 适合插入、删除，时间复杂度 O(1)


    随机访问：

        计算机读取数据：

            计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据.

            随机访问数组中的某个元素时，通过寻址公式，计算出该元素存储的内存地址：

                a[i]_address = base_address + i * data_type_size

                    ->   data_type_size ：数组元素类型的大小          int -> 4个字节


    低效的“插入”和“删除”：

        插入：
            尾插：O(1)     头插：O(n)     平均：O(n)

        删除：
            尾删：O(1)     头删：O(n)     平均：O(n)

            JVM 标记清除 垃圾回收算法：
                每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作。

    容器：

        ArrayList                   // 对 数组操作 的封装

            1、封装数组操作：

                数组 插、删 -->  数据搬移

            2、动态扩容

                也是一种封装

                扩容耗时 -> 预先指定合理大小

    数组场景：
        1、基本类型
        2、预知数组大小
        3、多维数组

        4、底层开发  ->  追求极致性能

            业务开发 -> 容器  -> 便利


    数组下标从0开始：

        最主要：
            历史原因        ->      C 语言  -> “始作俑者”

        数组内存模型

            “下标” ->  “偏移（offset）”

            寻址公式：
                0开始     ->     a[k]_address = base_address + k * type_size
                1开始     ->     a[k]_address = base_address + (k-1) * type_size      ->  每次寻址  多一次 k-1 运算


    扩展：

        JVM标记清除算法：

            大多数主流虚拟机采用可达性分析算法来判断对象是否存活，
            在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。
            只有当标记工作完成后，清理工作才会开始。

            不足：
                1.效率问题
                    标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。

                2.空间问题
                    会产生不连续的内存空间碎片。

        二维数组内存寻址：

            对于 m * n 的数组，a[i] [j] (i < m,j < n)的地址为：

                address = base_address + ( i * n + j) * type_size



2、链表                            // 非连续 的内存空间、指针、插删


    不连续 的内存空间

        数组：     申请100M  ->  剩余内存150M，但无连续的100M   ->  申请失败

        链表       指针     ->  一组零散的内存块               ->  串联


    3种链表结构：

        1、单链表

            data+next  ->   data+next  ->   ...  ->  data + NULL

            随机 插、删       O(1)
            随机 查          O(n)



        2、双向链表                          // 更高效  ->  应用更广   ->   空间 换 时间

            prev+data+next  ->   prev+data+next  ->   ...  ->  prev+data + NULL

            用空间换时间：

                删   ->   要知道其 前+后 节点


                    1、给定值           ==>  先查 -> 再删

                        先遍历查 O(n)   ->  删

                        单、双  无区别   ->  O(n)


                    2、给定地址值

                        双   ->   元素     ->      记录有 前后指针   ->  删                           ->   O(1)

                        单   ->   元素     ->      未记录 前指针     ->  从头遍历   ->   删            ->   O(n)

            应用：
                LinkedHashMap



        3、循环链表

            特殊的单链表          ->      环形 链表


        双向 + 循环 --> 双向循环 链表



    数组 VS 链表：

        数组
            简单易用，连续的内存空间 -> 可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高

            大小固定，一经声明就要占用整块连续内存空间   ->  “动态”扩容 -> 申请新的内存空间 -> 拷贝

        链表
            在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读

            链表本身没有大小的限制，天然地支持 动态扩容



    应用场景     LRU 缓存淘汰算法                                              // 常用策略 -> FIFO、LFU、LRU

            - 最近最少使用策略 LRU（Least Recently Used）




    -------------------

    “指针”/“引用”

        一个意思，都是 存储所指对象 的 内存地址

        将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，
        或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量


        p->next=q
            p结点 中的 next指针  存储了 q结点 的内存地址

        p->next=p->next->next
            p结点 的 next指针  存储了 p结点 的 下下一个节点 的内存地址



    head == null

        哨兵  ->  解决“边界问题”的，不直接参与业务逻辑


3、栈                         // 一端、后进先出、先进后出、进栈、出栈

    “栈”结构
        后进者先出，先进者后出             ===>    放盘子 -> 取盘子

    场景：
        当某个数据集合 只涉及在一端 插入和删除 数据，并且满足 后进先出、先进后出 的特性      ->  首选：“栈”

    阉割版 的 数组/链表

        栈是一种“操作受限”的线性表

            - 只支持两种基本操作：入队 和 出队


            功能上：数组/链表 完全可以实现 “栈”的操作

            可控性：数组/链表 暴露了太多操作接口     ->  不可控 -> 出错


    应用：
        函数调用栈

        表达式求值

        括号匹配

        浏览器前进和后退


    为什么 函数调用 要用 “栈” 来保存临时变量呢？用其他数据结构不行吗？

        其实，我们 不一定非要用 栈 来保存 临时变量，只不过如果这个函数调用 符合 后进先出 的特性，用 栈 这种数据结构 来实现，是 最顺理成章 的选择。

        从调用函数进入被调用函数，对于数据来说，变化的是什么呢？ 是 作用域。
        所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。
        而要实现这个，用栈就非常方便。
        在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。



4、队列                            // 先进先出、尾进头出、入队、出队

    “队列”结构：
        先进先出

    有限操作：

        入队 enqueue()    ->      放一个数据到队列尾部

        出队 dequeue()    ->      从队列头部取一个元素


    阉割版 的 数组/链表

        “操作受限”的 线性表 数据结构

        只支持两种基本操作：入队 和 出队


    顺序队列 和 链式队列

    循环队列
        消除 “数据搬移”

    应用：
        阻塞队列
            生产者 - 消费者

        并发队列
            基于数组的循环队列，利用 CAS 原子操作，可以实现非常 高效的 并发队列。

            这也是 循环队列 比 链式队列 应用更加广泛 的原因


    资源有限场景

        基于阻塞 -> 请求排队

            阻塞队列

        非阻塞 -> 直接拒绝

    -----------------
    队列也是一种“操作受限”的线性表，只支持两种基本操作：入队和出队。

    队列的应用非常广泛
        特别是一些具有某些额外特性的队列，比如 循环队列、阻塞队列、并发队列。
        它们在很多偏底层的系统、框架、中间件的开发中，起着关键性的作用。
        比如 高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

    关于如何实现无锁并发队列
        可以使用 cas + 数组 的方式实现

    队列的其他应用
        分布式消息队列，如 kafka 也是一种队列


5、跳表（Skip List）                         // 快速 插/删/查 -> O(logn) 、 动态 数据结构 、 红黑树

    跳表
        链表 加 多级索引 的结构

    Redis

    索引层   ->    跳

        空间 换 时间

        索引结点只需要存储关键值和几个指针，并不需要 存储对象   ->  额外空间可以忽略

        复杂度   ->   索引维护


    总结：
        跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。

        跳表是一种动态数据结构，支持快速地插入、删除、查找操作，时间复杂度 都是 O(logn)。

        跳表的空间复杂度是 O(n)
        不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

        虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。
        所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。



5、散列表





6、二叉树


7、堆



9、图


10、Trie 树






---------------------------------------------------- 算法 ---------------------------------------------------------------

1、递归

    陷入“递归”的 思维误区

        这或许就是 计算机思维
        我们很难想象10后面10个0到到底有多大，但是计算机恰好可以
        我们可以把苹果一切两半，但是无法想象切分50次的样子


    为什么使用递归？递归的优缺点？

        优点：代码的表达力很强，写起来简洁。
        缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。


    递归常见问题及解决方案
        警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
        警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。

    递归 改写为 非递归代码

        笼统的讲，所有的递归代码 都可以 改写为 迭代循环 的非递归写法

        因为 递归 本身就是 借助栈 来实现的，只不过我们使用的栈是 系统或者虚拟机本身提供的，我们没有感知罢了。
        如果我们 自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样 任何递归代码 都可以改写成 看上去不是递归代码 的样子。

        具体：
            抽象出递推公式、初始值和边界条件，然后用迭代循环实现

        本质：
            递归     ->   系统栈、虚拟栈
            迭代循环  ->  自己实现一个内存栈

            这种思路实际上是将 递归 改为了 “手动”递归，本质并没有变，
            而且也并没有解决前面讲到的某些问题，徒增了 实现的 复杂度。



2、排序

    O(n²)

        1、冒泡排序（Bubble Sort）                         // 比较、交换        -->     理论

            移位 -> 3 行代码

        2、插入排序（Insertion Sort）                      // 动态排序         -->     应用

            移位 -> 1 行代码         ==>     优于 冒泡


            有些编程语言中的排序函数的实现原理会用到插入排序算法

        3、选择排序（Selection Sort）                      //                 -->     理论




    O(nlogⁿ)

        4、归并排序（Merge Sort）                          // 分治、递归、递推公式、merge() 合并函数、  稳定 -> 空间复杂度 高

            致命“弱点”
                不是 原地排序 算法   ->    空间复杂度 比较 高    ->    O(n)         -> 占内存，用的少


        5、快速排序（Quick Sort）                          // 分治、分区、递推公式、partition() 分区函数

            最坏  ->  O(n²)

            平均  ->  O(nlogⁿ)


            快排核心思想：
                分治 和 分区

            快排的思想：
                如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）


        ---------------------------------
        分治思想

            分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。

            分治算法一般都是用递归来实现的。

            分治是一种解决问题的处理思想，递归是一种编程技巧。


    O(n)

        6、桶排序（Bucket sort）                          // 范围不大、数据划分

            会用到“桶”
            核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。
            桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

            适用场景：

                针对范围不大的数据，将数据划分成不同的桶来实现排序。

                    比较适合用在 外部排序 中

                        所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。





        7、计数排序（Counting sort）                        // 范围不大、数据划分

            桶排序的一种特殊情况

            适用场景：

                针对范围不大的数据，将数据划分成不同的桶来实现排序。

                计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
                而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。


        8、基数排序（Radix sort）                          // 高低位、递进

            适用场景：

                基数排序要求数据可以划分成高低位，位之间有递进关系。
                比较两个数，我们只需要比较高位，高位相同的再比较低位。
                而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。

                基数排序对要排序的数据是有要求的，
                需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
                除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。



        -----------------------
        线性排序（Linear sort）

            桶、计数、基数排序 之所以能做到 线性的时间复杂度，
            主要原因是，这三个算法是 非基于比较 的排序算法，都不涉及 元素之间的 比较操作。




    -----------------------------------
    排序算法选择：
        小规模 数据进行排序，可以选择时间复杂度是 O(n²) 的算法
        大规模 数据进行排序，时间复杂度是 O(nlogⁿ) 的算法更加高效
        所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogⁿ) 的排序算法 来实现 排序函数

    应用：
        Java    ->      堆       ->  O(nlogⁿ)

        C       ->      快排     ->  O(n²)




    总结：如何实现一个通用的高性能的排序函数？

    一、如何选择合适的排序算法？


        1.排序算法一览表

            时间复杂度                    稳定排序    原地排序
            冒泡排序 O(n^2)                 是          是
            插入排序 O(n^2)                 是          是
            选择排序 O(n^2)                 否          是
            快速排序 O(nlogⁿ)               否          是
            归并排序 O(nlogⁿ)               是          否
            桶排序 O(n)                     是          否
            计数排序 O(n+k)，k是数据范围      是          否
            基数排序 O(dn)，d是纬度           是          否


    2.为什选择快速排序？
        1）线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。
        2）为了兼顾任意规模数据的排序，一般会首选时间复杂度为 O(nlogⁿ) 的排序算法来实现排序函数。
        3）同为 O(nlogⁿ)的 快排和归并 排序相比，归并排序不是原地排序算法，所以最优的选择是快排。


    二、如何优化快速排序？

        导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。

        如何优化分区点的选择？有2种常用方法，如下：

            1.三数取中法
                ① 从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。
                ② 如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。

            2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。


        警惕快排的递归发生堆栈溢出，有2中解决方法，如下：
            ① 限制递归深度，一旦递归超过了设置的阈值就停止递归。
            ② 在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。


    三、通用排序函数实现技巧

        1.数据量不大时，可以采取用时间换空间的思路
        2.数据量大时，优化快排分区点的选择
        3.防止堆栈溢出，可以选择在堆上手动模拟调用栈解决
        4.在排序区间中，当元素个数小于某个常数时，可以考虑使用O(n²)级别的插入排序
        5.用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致


    四、思考

        1. Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？       // Arrays.sort

            1. 对于基本类型的数组
                Java 采用的是 双枢轴快速排序（DualPivotQuicksort -> since 1.7）
                在此之前，Java 采用的是 普通的快速排序，双枢轴快速排序 是对 普通快速排序 的优化

            2. 对于对象类型
                Java 采用的算法是 TimSort（ -> since 1.7）
                在此之前，Java 采用的是 归并排序
                TimSort 算法实际上是对 归并排序 的 一系列优化

            3. 在这些排序算法中，如果数组长度比较小，它们还会采用 效率更高的 插入排序（< 47）

        2. 查看了Java的 Arrays.sort

            -> DualPivotQuicksort.sory();

                1. 若数组元素个数总数小于47，使用插入排序
                2. 若数据元素个数总数在47~286之间，使用快速排序。应该是使用的优化版本的三值取中的优化版本
                3. 若大于286的个数，使用归并排序

                    // 底层实现的代码校验比较多


3、二分查找



    一、什么是二分查找

        二分查找针对的是一个 有序的数据集合，
        每次通过跟 区间中间 的元素对比，将待查找的区间 缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0

    二、时间复杂度分析

        1. 时间复杂度

            假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。
            所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。
            当n/(2^k)=1时，k的值就是总共缩小的次数，也是查找的总次数。
            而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是O(k)。
            通过n/(2^k)=1，可求得k=log2n，所以时间复杂度是O(logn)。

        2. 认识 O(logn)

            ① 这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？
            ② 因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32
            ③ 由此可见，O(logn)有时就是比O(1000)，O(10000)快很多


    三、如何实现二分查找

        1. 循环实现

            注意事项：
            ① 循环退出条件是：start<=end，而不是start<end。
            ② mid的取值，使用mid=start + (end - start) / 2，而不用mid=(start + end)/2，因为如果start和end比较大的话，求和可能会发生int类型的值超出最大范围。
                为了把性能优化到极致，可以将除以2转换成 位运算，即start + ((end - start) >> 1)，因为相比除法运算来说，计算机处理位运算要快得多。
            ③ start和end的更新：start = mid - 1，end = mid + 1，若直接写成start = mid，end=mid，就可能会发生死循环。

        2. 递归实现

    四、使用条件（应用场景的局限性）

        1. 二分查找依赖的是顺序表结构，即数组。   // 链表 -> 无index，无法随机访问 -> 遍历查询 O(n)
        2. 二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。
        3. 数据量太小不适合二分查找，与直接遍历相比效率提升不明显。
            但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。
        4. 数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间。

    五、思考

        1. 如何在1000万个整数中快速查找某个整数？
            ① 1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理；
            ② 用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn)
            ③ 在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn)

        2. 如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？
            如果你自己推导一下，你就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。

            假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异)：
                第一次，查找中间点，需要移动指针n/2次；
                第二次，需要移动指针n/4次；
                第三次，需要移动指针n/8次；
                ......
                以此类推，一直到1次为值

            总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + ...+ 1，这显然是个等比数列，根据等比数列求和公式：sum = n - 1

            最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同

            但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢


        3. 如何编程实现“求一个数的平方根”？要求精确到小数点后6位？



    实现：
        十个二分九个错
            尽管第一个二分查找算法于 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。

        变体：
            1、查找第一个值等于给定值的元素
            2、查找最后一个值等于给定值的元素
            3、查找第一个大于等于给定值的元素
            4、查找最后一个小于等于给定值的元素

        细节：
            终止条件、区间上下界更新方法、返回值选择

        凡是用 二分查找 能解决的，绝大部分我们更倾向于用 散列表 或者 二叉查找树

        场景：
            求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题。
            如上面几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。


4、搜索


5、哈希算法


6、贪心算法


7、分治算法


8、回溯算法


9、动态规划


10、字符串匹配算法









----------------------------------------------------
高级排序


1、拓扑排序

2、最短路径

3、位图

4、概率统计

5、向量空间

6、B+树

7、搜索

8、并行算法




---------------
n ㏒ ª ₂²ⁿ ᴺ ɴ
𝓃𝘯log₂ⁿ
log


𝘯²
𝘯(log₂ⁿ)
n
log₂ⁿ
1