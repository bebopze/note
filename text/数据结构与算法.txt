----------------------------------------------------------------------------------------------------
2、基础
----------------------------------------------------------------------------------------------------

1、数组                            // 线性表、下标、连续内存空间、相同类型数据、随机访问

    定义：
        数组（Array）是一种 线性表 数据结构。它用一组 连续的内存空间 ，来存储一组具有相同类型的数据

    最基础的数据结构：

            每一种编程语言中，基本 都会有数组 这种数据类型

    线性 与 非线性

        线性表
            数据排成 像一条线 一样的结构，每个线性表上的数据 最多只有 前和后 两个方向

            应用：
                数组、链表、队列、栈

        非线性表
            在非线性表中，数据之间并 不是 简单的前后关系

            应用：
                二叉树、堆、图


    连续的内存空间 和 相同类型的数据：

        优点：随机访问     ->  快速 查

                下标 ->  寻址公式   -> 直接定位      ->  O(1)

        缺点：增、删       ->  低效 插删

                为了保证 连续性    ->  需要做大量的 数据搬移 工作


    数组 和 链表 的区别：

        数组 支持 随机访问，根据下标随机访问 的时间复杂度为 O(1)

        链表 适合插入、删除，时间复杂度 O(1)


    随机访问：

        计算机读取数据：

            计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据.

            随机访问数组中的某个元素时，通过寻址公式，计算出该元素存储的内存地址：

                a[i]_address = base_address + i * data_type_size

                    ->   data_type_size ：数组元素类型的大小          int -> 4个字节


    低效的“插入”和“删除”：

        插入：
            尾插：O(1)     头插：O(n)     平均：O(n)

        删除：
            尾删：O(1)     头删：O(n)     平均：O(n)

            JVM 标记清除 垃圾回收算法：
                每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作。

    容器：

        ArrayList                   // 对 数组操作 的封装

            1、封装数组操作：

                数组 插、删 -->  数据搬移

            2、动态扩容

                也是一种封装

                扩容耗时 -> 预先指定合理大小

    数组场景：
        1、基本类型
        2、预知数组大小
        3、多维数组

        4、底层开发  ->  追求极致性能

            业务开发 -> 容器  -> 便利


    数组下标从0开始：

        最主要：
            历史原因        ->      C 语言  -> “始作俑者”

        数组内存模型

            “下标” ->  “偏移（offset）”

            寻址公式：
                0开始     ->     a[k]_address = base_address + k * type_size
                1开始     ->     a[k]_address = base_address + (k-1) * type_size      ->  每次寻址  多一次 k-1 运算


    扩展：

        JVM标记清除算法：

            大多数主流虚拟机采用可达性分析算法来判断对象是否存活，
            在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。
            只有当标记工作完成后，清理工作才会开始。

            不足：
                1.效率问题
                    标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。

                2.空间问题
                    会产生不连续的内存空间碎片。

        二维数组内存寻址：

            对于 m * n 的数组，a[i] [j] (i < m,j < n)的地址为：

                address = base_address + ( i * n + j) * type_size



2、链表                            // 非连续 的内存空间、指针、插删


    不连续 的内存空间

        数组：     申请100M  ->  剩余内存150M，但无连续的100M   ->  申请失败

        链表       指针     ->  一组零散的内存块               ->  串联


    3种链表结构：

        1、单链表

            data+next  ->   data+next  ->   ...  ->  data + NULL

            随机 插、删       O(1)
            随机 查          O(n)



        2、双向链表                          // 更高效  ->  应用更广   ->   空间 换 时间

            prev+data+next  ->   prev+data+next  ->   ...  ->  prev+data + NULL

            用空间换时间：

                删   ->   要知道其 前+后 节点


                    1、给定值           ==>  先查 -> 再删

                        先遍历查 O(n)   ->  删

                        单、双  无区别   ->  O(n)


                    2、给定地址值

                        双   ->   元素     ->      记录有 前后指针   ->  删                           ->   O(1)

                        单   ->   元素     ->      未记录 前指针     ->  从头遍历   ->   删            ->   O(n)

            应用：
                LinkedHashMap



        3、循环链表

            特殊的单链表          ->      环形 链表


        双向 + 循环 --> 双向循环 链表



    数组 VS 链表：

        数组
            简单易用，连续的内存空间 -> 可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高

            大小固定，一经声明就要占用整块连续内存空间   ->  “动态”扩容 -> 申请新的内存空间 -> 拷贝

        链表
            在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读

            链表本身没有大小的限制，天然地支持 动态扩容



    应用场景     LRU 缓存淘汰算法                                              // 常用策略 -> FIFO、LFU、LRU

            - 最近最少使用策略 LRU（Least Recently Used）




    -------------------

    “指针”/“引用”

        一个意思，都是 存储所指对象 的 内存地址

        将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，
        或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量


        p->next=q
            p结点 中的 next指针  存储了 q结点 的内存地址

        p->next=p->next->next
            p结点 的 next指针  存储了 p结点 的 下下一个节点 的内存地址



    head == null

        哨兵  ->  解决“边界问题”的，不直接参与业务逻辑


3、栈                         // 一端、后进先出、先进后出、进栈、出栈

    “栈”结构
        后进者先出，先进者后出             ===>    放盘子 -> 取盘子

    场景：
        当某个数据集合 只涉及在一端 插入和删除 数据，并且满足 后进先出、先进后出 的特性      ->  首选：“栈”

    阉割版 的 数组/链表

        栈是一种“操作受限”的线性表

            - 只支持两种基本操作：入队 和 出队


            功能上：数组/链表 完全可以实现 “栈”的操作

            可控性：数组/链表 暴露了太多操作接口     ->  不可控 -> 出错


    应用：
        函数调用栈

        表达式求值

        括号匹配

        浏览器前进和后退


    为什么 函数调用 要用 “栈” 来保存临时变量呢？用其他数据结构不行吗？

        其实，我们 不一定非要用 栈 来保存 临时变量，只不过如果这个函数调用 符合 后进先出 的特性，用 栈 这种数据结构 来实现，是 最顺理成章 的选择。

        从调用函数进入被调用函数，对于数据来说，变化的是什么呢？ 是 作用域。
        所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。
        而要实现这个，用栈就非常方便。
        在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。



4、队列                            // 先进先出、尾进头出、入队、出队

    “队列”结构：
        先进先出

    有限操作：

        入队 enqueue()    ->      放一个数据到队列尾部

        出队 dequeue()    ->      从队列头部取一个元素


    阉割版 的 数组/链表

        “操作受限”的 线性表 数据结构

        只支持两种基本操作：入队 和 出队


    顺序队列 和 链式队列

    循环队列
        消除 “数据搬移”

    应用：
        阻塞队列
            生产者 - 消费者

        并发队列
            基于数组的循环队列，利用 CAS 原子操作，可以实现非常 高效的 并发队列。

            这也是 循环队列 比 链式队列 应用更加广泛 的原因


    资源有限场景

        基于阻塞 -> 请求排队

            阻塞队列

        非阻塞 -> 直接拒绝

    -----------------
    队列也是一种“操作受限”的线性表，只支持两种基本操作：入队和出队。

    队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如 循环队列、阻塞队列、并发队列。
    它们在很多偏底层的系统、框架、中间件的开发中，起着关键性的作用。
    比如 高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

    关于如何实现无锁并发队列
        可以使用 cas + 数组的方式实现

    队列的其他应用
        分布式消息队列，如 kafka 也是一种队列


5、递归

6、排序

7、二分查找

8、跳表

9、散列表




1、哈希算法

2、二叉树

3、红黑树

4、递归树

5、堆和堆排序

6、堆的应用

7、图的表示

8、深度和广度优先搜索

    字符串匹配

    Trie树

    AC自动机


9、贪心算法

10、分治算法

11、回溯算法

12、动态规划




-------------
高级排序


1、拓扑排序

2、最短路径

3、位图

4、概率统计

5、向量空间

6、B+树

7、搜索

8、并行算法

