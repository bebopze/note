----------------------------------------------------------------------------------------------------
2、基础
----------------------------------------------------------------------------------------------------
10 个 数据结构：  数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
10 个 算法   ：   递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
------------------------------------------------------------------------------------------------------------------------


------------------------------------------------- 数据结构 --------------------------------------------------------------

1、数组                            // 线性表、下标、连续内存空间、相同类型数据、随机访问

    定义：
        数组（Array）是一种 线性表 数据结构。它用一组 连续的内存空间 ，来存储一组具有相同类型的数据

    最基础的数据结构：

            每一种编程语言中，基本 都会有数组 这种数据类型

    线性 与 非线性

        线性表
            数据排成 像一条线 一样的结构，每个线性表上的数据 最多只有 前和后 两个方向

            应用：
                数组、链表、队列、栈

        非线性表
            在非线性表中，数据之间并 不是 简单的前后关系

            应用：
                二叉树、堆、图


    连续的内存空间 和 相同类型的数据：

        优点：随机访问     ->  快速 查

                下标 ->  寻址公式   -> 直接定位      ->  O(1)

        缺点：增、删       ->  低效 插删

                为了保证 连续性    ->  需要做大量的 数据搬移 工作


    数组 和 链表 的区别：

        数组 支持 随机访问，根据下标随机访问 的时间复杂度为 O(1)

        链表 适合插入、删除，时间复杂度 O(1)


    随机访问：

        计算机读取数据：

            计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据.

            随机访问数组中的某个元素时，通过寻址公式，计算出该元素存储的内存地址：

                a[i]_address = base_address + i * data_type_size

                    ->   data_type_size ：数组元素类型的大小          int -> 4个字节


    低效的“插入”和“删除”：

        插入：
            尾插：O(1)     头插：O(n)     平均：O(n)

        删除：
            尾删：O(1)     头删：O(n)     平均：O(n)

            JVM 标记清除 垃圾回收算法：
                每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作。

    容器：

        ArrayList                   // 对 数组操作 的封装

            1、封装数组操作：

                数组 插、删 -->  数据搬移

            2、动态扩容

                也是一种封装

                扩容耗时 -> 预先指定合理大小

    数组场景：
        1、基本类型
        2、预知数组大小
        3、多维数组

        4、底层开发  ->  追求极致性能

            业务开发 -> 容器  -> 便利


    数组下标从0开始：

        最主要：
            历史原因        ->      C 语言  -> “始作俑者”

        数组内存模型

            “下标” ->  “偏移（offset）”

            寻址公式：
                0开始     ->     a[k]_address = base_address + k * type_size
                1开始     ->     a[k]_address = base_address + (k-1) * type_size      ->  每次寻址  多一次 k-1 运算


    扩展：

        JVM标记清除算法：

            大多数主流虚拟机采用可达性分析算法来判断对象是否存活，
            在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。
            只有当标记工作完成后，清理工作才会开始。

            不足：
                1.效率问题
                    标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。

                2.空间问题
                    会产生不连续的内存空间碎片。

        二维数组内存寻址：

            对于 m * n 的数组，a[i] [j] (i < m,j < n)的地址为：

                address = base_address + ( i * n + j) * type_size



2、链表                            // 非连续 的内存空间、指针、插删


    不连续 的内存空间

        数组：     申请100M  ->  剩余内存150M，但无连续的100M   ->  申请失败

        链表       指针     ->  一组零散的内存块               ->  串联


    3种链表结构：

        1、单链表

            data+next  ->   data+next  ->   ...  ->  data + NULL

            随机 插、删       O(1)
            随机 查          O(n)



        2、双向链表                          // 更高效  ->  应用更广   ->   空间 换 时间

            prev+data+next  ->   prev+data+next  ->   ...  ->  prev+data + NULL

            用空间换时间：

                删   ->   要知道其 前+后 节点


                    1、给定值           ==>  先查 -> 再删

                        先遍历查 O(n)   ->  删

                        单、双  无区别   ->  O(n)


                    2、给定地址值

                        双   ->   元素     ->      记录有 前后指针   ->  删                           ->   O(1)

                        单   ->   元素     ->      未记录 前指针     ->  从头遍历   ->   删            ->   O(n)

            应用：
                LinkedHashMap



        3、循环链表

            特殊的单链表          ->      环形 链表


        双向 + 循环 --> 双向循环 链表



    数组 VS 链表：

        数组
            简单易用，连续的内存空间 -> 可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高

            大小固定，一经声明就要占用整块连续内存空间   ->  “动态”扩容 -> 申请新的内存空间 -> 拷贝

        链表
            在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读

            链表本身没有大小的限制，天然地支持 动态扩容



    应用场景     LRU 缓存淘汰算法                                              // 常用策略 -> FIFO、LFU、LRU

            - 最近最少使用策略 LRU（Least Recently Used）




    -------------------

    “指针”/“引用”

        一个意思，都是 存储所指对象 的 内存地址

        将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，
        或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量


        p->next=q
            p结点 中的 next指针  存储了 q结点 的内存地址

        p->next=p->next->next
            p结点 的 next指针  存储了 p结点 的 下下一个节点 的内存地址



    head == null

        哨兵  ->  解决“边界问题”的，不直接参与业务逻辑


3、栈                         // 一端、后进先出、先进后出、进栈、出栈

    “栈”结构
        后进者先出，先进者后出             ===>    放盘子 -> 取盘子

    场景：
        当某个数据集合 只涉及在一端 插入和删除 数据，并且满足 后进先出、先进后出 的特性      ->  首选：“栈”

    阉割版 的 数组/链表

        栈是一种“操作受限”的线性表

            - 只支持两种基本操作：入队 和 出队


            功能上：数组/链表 完全可以实现 “栈”的操作

            可控性：数组/链表 暴露了太多操作接口     ->  不可控 -> 出错


    应用：
        函数调用栈

        表达式求值

        括号匹配

        浏览器前进和后退


    为什么 函数调用 要用 “栈” 来保存临时变量呢？用其他数据结构不行吗？

        其实，我们 不一定非要用 栈 来保存 临时变量，只不过如果这个函数调用 符合 后进先出 的特性，用 栈 这种数据结构 来实现，是 最顺理成章 的选择。

        从调用函数进入被调用函数，对于数据来说，变化的是什么呢？ 是 作用域。
        所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。
        而要实现这个，用栈就非常方便。
        在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。



4、队列                            // 先进先出、尾进头出、入队、出队

    “队列”结构：
        先进先出

    有限操作：

        入队 enqueue()    ->      放一个数据到队列尾部

        出队 dequeue()    ->      从队列头部取一个元素


    阉割版 的 数组/链表

        “操作受限”的 线性表 数据结构

        只支持两种基本操作：入队 和 出队


    顺序队列 和 链式队列

    循环队列
        消除 “数据搬移”

    应用：
        阻塞队列
            生产者 - 消费者

        并发队列
            基于数组的循环队列，利用 CAS 原子操作，可以实现非常 高效的 并发队列。

            这也是 循环队列 比 链式队列 应用更加广泛 的原因


    资源有限场景

        基于阻塞 -> 请求排队

            阻塞队列

        非阻塞 -> 直接拒绝

    -----------------
    队列也是一种“操作受限”的线性表，只支持两种基本操作：入队和出队。

    队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如 循环队列、阻塞队列、并发队列。
    它们在很多偏底层的系统、框架、中间件的开发中，起着关键性的作用。
    比如 高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

    关于如何实现无锁并发队列
        可以使用 cas + 数组的方式实现

    队列的其他应用
        分布式消息队列，如 kafka 也是一种队列



5、散列表





6、二叉树


7、堆


8、跳表


9、图


10、Trie 树






---------------------------------------------------- 算法 ---------------------------------------------------------------

1、递归

    陷入“递归”的 思维误区

        这或许就是 计算机思维
        我们很难想象10后面10个0到到底有多大，但是计算机恰好可以
        我们可以把苹果一切两半，但是无法想象切分50次的样子


    为什么使用递归？递归的优缺点？

        优点：代码的表达力很强，写起来简洁。
        缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。


    递归常见问题及解决方案
        警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
        警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。

    递归 改写为 非递归代码

        笼统的讲，所有的递归代码 都可以 改写为 迭代循环 的非递归写法

        因为 递归 本身就是 借助栈 来实现的，只不过我们使用的栈是 系统或者虚拟机本身提供的，我们没有感知罢了。
        如果我们 自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样 任何递归代码 都可以改写成 看上去不是递归代码 的样子。

        具体：
            抽象出递推公式、初始值和边界条件，然后用迭代循环实现

        本质：
            递归     ->   系统栈、虚拟栈
            迭代循环  ->  自己实现一个内存栈

            这种思路实际上是将 递归 改为了 “手动”递归，本质并没有变，
            而且也并没有解决前面讲到的某些问题，徒增了 实现的 复杂度。



2、排序

    O(n²)

        1、冒泡排序（Bubble Sort）                         // 比较、交换        -->     理论

            移位 -> 3 行代码

        2、插入排序（Insertion Sort）                      // 动态排序         -->     应用

            移位 -> 1 行代码         ==>     优于 冒泡


            有些编程语言中的排序函数的实现原理会用到插入排序算法

        3、选择排序（Selection Sort）                      //                 -->     理论




    O(nlogⁿ)

        4、归并排序（Merge Sort）                          // 分治、递归、递推公式、merge() 合并函数、  稳定 -> 空间复杂度 高

            致命“弱点”
                不是 原地排序 算法   ->    空间复杂度比较高    ->    O(n)


        5、快速排序（Quick Sort）                          // 分治、分区、递推公式、partition() 分区函数

            最坏  ->  O(n²)

            平均  ->  O(nlogⁿ)


            快排核心思想：
                分治 和 分区

            快排的思想：
                如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）


        ---------------------------------
        分治思想

            分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。

            分治算法一般都是用递归来实现的。

            分治是一种解决问题的处理思想，递归是一种编程技巧。


    O(n)

        6、桶排序（Bucket sort）                          // 范围不大、数据划分

            会用到“桶”
            核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。
            桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

            适用场景：

                针对范围不大的数据，将数据划分成不同的桶来实现排序。

                    比较适合用在 外部排序 中

                        所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。





        7、计数排序（Counting sort）                        // 范围不大、数据划分

            桶排序的一种特殊情况

            适用场景：

                针对范围不大的数据，将数据划分成不同的桶来实现排序。

                计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
                而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。


        8、基数排序（Radix sort）                          // 高低位、递进

            适用场景：

                基数排序要求数据可以划分成高低位，位之间有递进关系。
                比较两个数，我们只需要比较高位，高位相同的再比较低位。
                而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。

                基数排序对要排序的数据是有要求的，
                需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
                除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。



        -----------------------
        线性排序（Linear sort）

            桶、计数、基数排序 之所以能做到 线性的时间复杂度，
            主要原因是，这三个算法是 非基于比较 的排序算法，都不涉及 元素之间的 比较操作。



3、二分查找




4、搜索


5、哈希算法


6、贪心算法


7、分治算法


8、回溯算法


9、动态规划


10、字符串匹配算法









----------------------------------------------------
高级排序


1、拓扑排序

2、最短路径

3、位图

4、概率统计

5、向量空间

6、B+树

7、搜索

8、并行算法

