1、数据结构

    String              K-V                                         ->  缓存、计数器、分布式锁、分布式session

    Hash                对象Map                                     ->  对象数据、缓存

    List                双端链表    有序                             ->  栈、队列、MQ

    Set                 去重        无序                             ->  去重、交集、并集、diff

    Sorted Set          去重        有序集合（分数）                  ->  排行榜


2、过期策略

    定期删除

        每100ms   ->   随机抽取 部分设置TTL的key    ->    check TTL

    惰性删除

        访问key    ->  check  ->   是否设置了TTL  +  是否已过期


3、内存淘汰机制

    no-enviction        不淘汰，新写入报错                               // 默认策略

    allkeys-lru         最近最少使用的 key                               // 最常用
    volatile-lru        最近最少使用的 TTL key

    allkeys-lfu         使用频率最低的 key
    volatile-lfu        使用频率最低的 TTK key

    allkeys-random      随机移除某个 key
    volatile-random     随机移除某个 TTL key

    volatile-ttl        TTL将要过期的 key


4、LRU算法

    简易LRU

        1、链表

        2、最新访问的数据  ->  放入链表头


    变体  ==>  分区  ->  young  +  old

        1、新加载的数据  ->  放入old

        2、old区存活1s以上  +  再次访问   ->      才放入 young区头部


5、持久化

    RDB     周期性的持久化            ->   默认：每5min刷盘一次        // 快照 + 异步刷盘

    AOF     对每条写入命令作为日志    ->   写入log文件                 // 每隔1s ->  异步fsync


    应用：

        RDB + AOF

            RDB  ->  冷备份   =>   AOF损坏的时候 -> 用RDB恢复

            AOF  ->  保证数据不丢失，作为数据恢复的第一选择



6、缓存

    用途：
        高性能     ==>      不变值缓存下来

        高并发     ==>      内存操作  ->  单机并发量 轻松一秒几万十几万


    Redis优势：

        单线程     ->      避免了频繁上下文切换，以及并发竞争

        内存       ->      读写快

        IO多路复用

        复杂数据结构


        -------------------------------------------------------------------------------------------------
        Redis 选择使用单线程模型处理客户端的请求，主要还是因为：

            CPU 不是 Redis 服务器的瓶颈

            使用多线程模型带来的性能提升  ->  并不能抵消它带来的开发成本和维护成本

            系统的性能瓶颈也主要在网络 I/O 操作上


        而 Redis 引入多线程操作也是出于性能上的考虑

            对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间，也能减少对 Redis 主线程阻塞的时间，提高执行的效率。


        -------------------------------------------------------------------------------------------------
        Redis的性能瓶颈：

            网络I/O操作     ==>     引入多线程

                Redis 的多线程部分

                    只是用来处理  网络数据的read/write 和 协议解析

                    处理 大键值的delete（非阻塞式 释放内存）            ->  减少阻塞主线程


                执行命令仍然是单线程

                    不想因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等的并发问题




7、缓存雪崩、缓存穿透、缓存击穿

    缓存雪崩：
        缓存挂了  ->  流量打到DB  ->  DB被打挂


        解决方案：

            Redis 高可用                 ->      主从 + 哨兵、Redis cluster  ->  避免全盘崩溃

            本地缓存 + 限流降级           ->      避免 MySQL 被打死

            Redis 持久化                 ->      一旦重启，自动从磁盘上加载数据，快速恢复缓存数据


    缓存穿透：
        恶意攻击  ->  批量访问DB中 不存在的数据


        解决方案：
            回种空值        ->      K - null


    缓存击穿：
        缓存key失效的瞬间  ->  大量请求一起访问（集中式高并发）  ->  全部直接打到了DB        // （大量集中请求）击穿了缓存 ->  就像是在一道屏障上凿开了一个洞


        解决方案：

            1、若缓存的数据是基本不会发生更新的                                          // 静态数据 / 基本不变     ->  永不过期

                则可尝试 将该热点数据设置为  ->  永不过期


            2、若缓存的数据更新不频繁，且 缓存刷新的整个流程耗时较少                       // 更新不频繁 / 更新耗时短  ->  互斥锁

                则可以采用基于 Redis、zookeeper 的分布式互斥锁、或本地互斥锁

                以保证
                    仅少量的请求  ->  能请求数据库并重新构建缓存

                    其余线程     ->  则在锁释放后能访问到新缓存


            3、若缓存的数据更新频繁 或 缓存刷新的流程耗时较长                             // 更新频繁 / 更新耗时长   =>  定时线程 -> 提前重建缓冲 / 缓存续期

                可以利用定时线程  ->  在缓存过期前，主动地重新构建缓存 或 延后缓存的过期时间  -> 以保证所有的请求能一直访问到对应的缓存



8、缓存与数据库 的双写一致性


    1、读

        1、先读缓存

        2、缓存没有的话  ->  就读数据库  ->  然后取出数据后放入缓存，同时返回响应


    2、写

        1、更新DB

        2、删除cache



    冲突原因：

        多个操作  ->  非原子操作  ==>  并发环境下，又没有保证同步


    3、追求 强一致性

        1、不要用缓存        // 用缓存 -> 就默许了 数据可能存在不一致

        2、互斥锁            // 同步

        3、内存队列          // 串行化



9、并发竞争

    多客户端请求  ->    并发竞争   ->    顺序性问题、原子性问题


        1、Lua脚本

        2、zk分布式锁

        3、乐观锁（时间戳字段）

            更新DB缓存

                1、Mysql加时间戳字段

                2、查数据 -> 也查出 时间戳字段

                3、更新cache  =>  check比较   ->   cache数据 和 DB数据  时间戳大小     =>  DB时间戳大 -> 更新覆盖




10、高可用、高并发

    高可用     ->      主从（master - slave）  +   哨兵（监听master 是否正常  ->  主备切换）

    高并发     ->      集群 / 读写分离(master写 + slaves读)



11、主从架构

    主从              // master - slave

    读写分离           // master -> 写，slaves -> 读



    Redis replication 的核心机制

        一主多从

        异步复制

            复制ing   ->  不阻塞maser 、 也不阻塞slave -> 用旧的数据提供 读

            复制ok    =>  删除旧数据 + 加载新数据  ->   暂停对外服务


        读写分离
            master  ->  写

            slaves  ->  读           // 扩展slave   ->   提高读的吞吐量


        断点续传
            backlog + offset


        过期key处理

            master  ->  key过期     ==>   模拟DEL指令 发送给slave       // slave不会执行 过期检测（ 定期删除[随机 + 耗性能] + 惰性删除[耗性能] ）


    heartbeat

        主从节点 相互发送心跳

            master 默认每隔10秒 发送一次 heartbeat

            slave node 每隔1秒 发送一个 heartbeat


12、哨兵


    哨兵：
        类似内置zk   ->   监听 master/slave  是否正常    ==>   master挂了 ->  主备切换  +  选举新master


    功能：

        集群监控   ->   负责监控 master 和 slave 进程是否正常工作

        消息通知   ->   如果某个 Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员

        故障转移   ->   如果 master node 挂掉了，会自动转移到 slave node 上

        配置中心   ->   如果故障转移发生了，通知client 新的master地址


    主备切换：
        分布式选举   ==>      需大部分sentinel都认可


    自动发现机制
        哨兵互相之间的发现，是通过 Redis 的 pub/sub 系统实现的

    configuration 传播
        pub/sub


    slave -> master 选举算法

    slave 配置的自动纠正




    主备切换 - 数据丢失

        1、异步复制导致的数据丢失

        2、脑裂导致的数据丢失     ==>     选举新master ~ 完成主备切换   中间态   ->   两个"master"   =>  特别是 client 此时依然会连接 旧master




13、部署

    集群（分担读写流量 - 高并发）  +  主从（高可用）

        10台机器   ->      5组（master - slave）                      // master -> 提供服务(读写) 、 slave -> 数据备份(高可用 - master替补)

        单机 5万QPS  10G内存   ->      5组集群 25万QPS  50G内存        // 配置：32G + 8核 + 1T        Redis实例 10G    // 超过10G 可能会有问题



