------------------------------------------------------------------------------------------------------------------------
物理层（部署运维）


    架构体系演进

        物理机（不隔离）    ->    虚拟化（隔离 - 系统资源占用严重）    ->    容器化（共享内核 + 隔离）    ->    云原生（对容器[应用]抽象 - 标准化调用）


    发展思想

        分布式思想       ->      抽象、职责 分离        ->      各司其职（独立组件）  +  标准化（通用适配）


    发展方向

        标准化（通用）   +   组件化（单一职责）


------------------------------------------------------------------------------------------------------------------------
应用层

    想象    ->    原始通信时代    ->    TCP时代



    ->    第一代微服务

                分布式系统特有的通信语义又出现了

                    如：熔断策略、负载均衡、服务发现、认证和授权、quota限制、trace、监控

                于是服务根据业务需求 来实现一部分所需的通信语义



    ->    第二代微服务

                为了避免每个服务都需要自己实现一套分布式系统通信的语义功能

                    随着技术的发展，一些面向微服务架构的开发框架出现了

                    如：Twitter的Finagle、Facebook的Proxygen、Spring Cloud等等

                这些框架实现了分布式系统通信需要的各种通用语义功能：

                    如：负载均衡和服务发现等

                    因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统



    ->    第一代Service Mesh

                第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：

                    其一，虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身

                        在实际应用中，去追踪和解决框架出现的问题也绝非易事


                    其二，开发框架通常只支持一种或几种特定的语言

                        回过头来看最开始对微服务的定义，一个重要的特性就是 语言无关

                            但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系

                            想因地制宜的用多种语言实现架构体系中的不同模块也很难做到


                    其三，框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手

                        同时，框架库的升级也无法对服务透明，服务会因为和业务无关的lib库升级而被迫升级



                因此，以Linkerd、Envoy、NginxMesh为代表的 代理模式（边车模式）应运而生，这就是第一代Service Mesh

                    它将 分布式服务的通信 抽象为单独一层

                        在这一层中  ->  实现 负载均衡、服务发现、认证授权、监控追踪、流量控制等 分布式系统所需要的功能

                    作为一个 和服务对等的 代理服务   ->   和服务部署在一起

                        接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求


                    这样上边所说的三个问题也迎刃而解



                相信现在，大家已经理解何所谓Service Mesh，也就是服务网格了。它看起来确实就像是一个由若干服务代理所组成的错综复杂的网格。



    ->    第二代Service Mesh

                第一代Service Mesh  ->  由一系列独立运行的单机代理服务构成


                第二代Service Mesh                                                 // 以Istio为代表

                    为了提供统一的上层运维入口   ==>   演化出了 集中式的控制面板

                        所有的单机代理组件  ->  通过和控制面板交互  ->  进行网络拓扑策略的更新 和 单机数据的汇报



                --------------------------------------------------------------------------------------------------------
                一言以蔽之：Service Mesh是微服务时代的TCP协议


                    基础设施层+请求在这些拓扑中可靠穿梭          ->          类比TCP

                    网络代理                                  ->          实现形态

                    对应用透明                                ->          关键特点        解决 以Spring Cloud为代表的第二代微服务框架 所面临的三个本质问题


                --------------------------------------------------------------------------------------------------------
                历史总是惊人的相似。
                为了解决端到端的字节码通信问题，TCP协议诞生，让多机通信变得简单可靠；
                微服务时代，Service Mesh应运而生，屏蔽了分布式系统的诸多复杂性，让开发者可以回归业务，聚焦真正的价值。



    --------------------------------------------------------------------------------------------------------------------
    总结一下，Service Mesh具有如下优点：

        屏蔽分布式系统通信的复杂性(负载均衡、服务发现、认证授权、监控追踪、流量控制等等)，服务只用关注业务逻辑；
        真正的语言无关，服务可以用任何语言编写，只需和Service Mesh通信即可；
        对应用透明，Service Mesh组件可以单独升级；


    当然，Service Mesh目前也面临一些挑战：

        Service Mesh组件以代理模式计算并转发请求，一定程度上会降低通信系统性能，并增加系统资源开销；
        Service Mesh组件接管了网络流量，因此服务的整体稳定性依赖于Service Mesh，同时额外引入的大量Service Mesh服务实例的运维和管理也是一个挑战；

------------------------------------------------------------------------------------------------------------------------
微服务  ->  容器化 ->  DevOps  ->  云原生体系  -> ...

    一切的一切  只有一个目的   ==>   应用端 专注业务开发


    现实是：理想是丰满的

    解决1个问题的同时  ->  会带来10个新问题

    越往后发展  ->  为了解决1个问题  ->  里面已经带来了100、1000个新问题

    新技术、新名词、各种听起来炫酷屌炸天的新名称满天飞   ->   真的解决问题了吗？   ->   成本/收益比是否越来越低呢？



------------------------------------------------------------------------------------------------------------------------
微服务  ->  Service Mesh  ->  云原生                  ==>     应用(业务)   与   服务治理/语言    ->   松耦合


    微服务

        应用  +  服务治理  +  语言（Java）             ->      耦合


    Service Mesh

        应用  -  sidecar（通信代理  +  服务治理）       ->      应用 与 服务治理/语言   松耦合


    云原生

        应用  -  Cloud Native技术栈生态                ->      应用 与 服务治理/语言   松耦合     +   服务治理 生态强大（上百个社区项目支持）




------------------------------------------------------------------------------------------------------------------------
Linux   ->   VM   ->   Docker   ->   k8s


硬件   ->   虚拟机（重量化）   ->   容器（轻量化）   ->   容器管理平台（上千个容器的编排/管理/调用 是个大问题）

------------------------------------------------------------------------------------------------------------------------
EventLoop  +  Coroutine





------------------------------------------------------------------------------------------------------------------------
C10K

