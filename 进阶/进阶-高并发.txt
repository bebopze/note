1、如何设计一个高并发系统？

    系统拆分                                    // 分布式（分区）

        Dubbo / Spring Cloud     ==>   每个子系统  ->  单独的库

    服务治理（Spring Cloud / Service Mesh）     // 熔断、降级、限流、认证鉴权、黑白名单、分布式追踪

    缓存
        读多写少  ->  缓解 并发读

    MQ
        必须写DB的操作 + 大量请求     ->      放入MQ    ->   异步处理               // 削峰  ->  平衡DB的脆弱性

    ElasticSearch

        es 是分布式的，可以随便扩容        // 分布式 天然就可以支撑高并发

        一些比较简单的查询、统计类的操作，还有一些全文搜索类的操作，可以考虑用 es 来承载

    读写分离

        大部分场景  ->  读多写少

            master  ->  写

            slave   ->  读     // 读流量多的时候  ->  扩容slave



    分库分表        // DB层   ->   分库分表（分布式DB - 分区 - 高扩展） + 主从（读写分离）  +  主备（高可用）


        即使做了 Cache、MQ  ->  依然还是有大量请求  集中打到DB   ==>  DB层搭建 高并发 + 高可用


            分库分表  ==>  32个库(机器) 、 每个库(机器) - 32张表     // 1024张表     可支撑 10亿级数据量

            一主多从  ==>  读写分离     // 分担 读请求压力

            主备     ==>   高可用



2、为什么要进行系统拆分？

    单体

        坏处：

            耦合

            循环依赖

            后期难以维护

            牵一发而动全身

                只改动一个小点  ->  就需要全部重新发布

                改动一处  ->  容易引发意隐藏的bug


            无法针对性扩容    ->   只能集群 - 整体扩容   // 浪费系统资源


        好处：
            排查问题方便

            前期发布上线快速

            开发方便



    微服务

        好处：

            解耦

            单库  ->  数据隔离

            单独针对压力大的服务扩容

            服务治理    // 熔断、降级、限流

            单一职责

            易维护


        坏处：

            复杂度上升

            分布式事务

            系统可用性降低

            运维复杂

            排查问题困难  - 调用链过长

