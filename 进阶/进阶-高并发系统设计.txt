========================================================================================================================
基础
========================================================================================================================


------------------------------------------------------------------------------------------------------------------------
高并发系统设计 的三种通用方法：

    1、Scale-out（扩展）
        数据库一主多从、分库分表、存储分片

    2、缓存

        整个计算机体系中  ->  磁盘是最慢的一环

    3、异步

        调用方法执行完毕后，再通过  回调、事件通知 等方式   ->   将结果 反馈给调用方

        场景：
            12306  ->   查询余票、下单、退票

            1、接收请求 ==> 先返回suc（告知用户请求成功，系统正在后台处理）

            2、后台处理成功后   ==>   微信/短信/邮箱/站内信 通知用户    或    用户自己刷新页面 获取异步处理结果


------------------------------------------------------------------------------------------------------------------------
架构分层


应用：
    OSI网络模型  七层
    TCP/IP协议   四层
    Linux 文件系统


好处：
    1、简化系统设计   ->   让不同的人专注做某一层次的事情
    2、高复用
    3、横向扩展


缺点：
    复杂度



------------------------------------------------------------------------------------------------------------------------
如何提升系统性能


三高：
    高并发、高性能、高可用


高并发系统设计的 三大目标：

    高性能、高可用、可扩展



========================================================================================================================
数据库
========================================================================================================================

池化技术：
    减少频繁创建数据库连接的性能损耗

------------------------------------------------------------------------------------------------------------------------
数据库优化方案：

    查询请求增加时     ->   做主从分离

    写入数据量增加时   ->   如何实现分库分表

------------------------------------------------------------------------------------------------------------------------
发号器：

    保证分库分表后ID的全局唯一性

        1、Snowflake 算法落地

        2、美团Leaf（分布式ID生成系统）             // QPS近5万

        3、微信序列号生成器                        // QPS1000万以上

        4、百度开源的UidGenerator                 // （仅支持单机部署）使用Snowflake算法，单机QPS可达600万


        ------------------------------------
        2、UUID的问题：

            1、生成的ID 最好具有单调递增性，也就是有序的     // 在系统设计时，ID 有可能成为排序的字段

            2、ID 有序也会提升数据的写入性能               // B+树 是有序的    ==>   有序 ->  顺序写

            3、它不具备业务含义                           // ID按自定义规则   ==>   生成时间、哪个机房的发号器、哪个业务服务...

            4、32位 字符串  ->  耗费空间


            场景：
                生成 Request ID 来标记单次请求           // 不依赖于任何第三方系统，所以在性能和可用性上都比较好




------------------------------------------------------------------------------------------------------------------------
NoSQL                   在高并发场景下，数据库 和 NoSQL 互补



    存储服务：

        1、读写能力

            提升它的读写性能  ->   尤其是 读性能   ==>  NoSQL

        2、扩展能力

            增强它在存储上的扩展能力  ->  从而应对 大数据量 的存储需求


    ---------------------------------------------------------------------
    NoSQL

        读多写少的产品：
            微信朋友圈、微博、淘宝                 // 查询QPS 远远大于 写入QPS



        分类：

            KV存储
                Redis、LevelDB

            列式存储
                Hbase、Cassandra

            文档型
                 MongoDB、CouchDB

            Elasticsearch
                倒排索引


        优点：

            性能
                将对磁盘的随机写转换成顺序写

                内存数据库 高效读

            在某些场景下
                全文搜索

            扩展性
                天生支持分布式、支持数据冗余、数据分片

        缺点：


------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
缓存
========================================================================================================================


------------------------------------------------------------------------------------------------------------------------
数据查询瓶颈
------------------------------------------------------------------------------------------------------------------------

缓存（cache）：
    存储数据的组件，它的作用是  ->  让对数据的请求更快地返回

    应用：
        HTTP 协议
        抖音 一次后台提前缓存几个视频


缓冲区（buffer）：
    一块临时存储数据的区域，这些数据 后面会被传输到 其他设备上      ->   批量提交


缓存分类：

    静态缓存        ->      负载均衡层

    分布式缓存      ->      应用层和数据库层之间

    热点本地缓存    ->      应用层


缓存的不足：

    读多写少

    复杂度

    数据不一致

    内存并不是无限

    运维成本



重点：

    1、将请求尽量挡在上层   ->   因为越往下层，对于并发的承受能力越差

    2、缓存命中率

        是我们对于缓存最重要的一个监控项，越是热点的数据，缓存的命中率就越高



