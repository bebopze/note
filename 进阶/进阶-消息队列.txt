1、为什么使用消息队列？

    场景有很多

    比较核心的有 3个：

        解耦                          // Pub/Sub 发布订阅

            BCD系统 都需要 A系统的 一份关键数据    ==>    丢到MQ   谁要谁自己去取   ->    再来几个EFG  也不用改动


        异步                      // 数据同步

            A接收一个请求 本地写数据(3ms)   ->   同时需要在 BCD系统也写入(300/400/500ms)   ->   （同步）慢   ==>   丢到 MQ  ->  BCD 异步写入



        削峰                      // 业务高峰期

            业务短暂搞活动   ->  请求数量突然暴增  ==>   丢到MQ    ->   异步处理     ==>    结果 ->  异步通知/站内信/客户端刷新拉取


2、消息队列有什么优点和缺点？

    优点：
        解耦、异步、削峰

    缺点：                         // 引入一个东西 ->  来解决一个问题的同时  ==>  会带来10个新的问题

        系统可用性降低       ->  MQ挂了

        复杂性               ->  MQ的维护、消息发送问题（超时、失败、重试、重复）、消费问题（失败、顺序、幂等）...

        一致性               ->  数据同步延迟、ABC成功 -> C失败





3、Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？

    ActiveMQ        万级                              ms级            主从架构      低概率丢失     Java       功能完备

    RabbitMQ        万级                              μs级（最快）    主从架构      基本不丢       erlang     高并发，低延时

    Kafka           10万级      topic几十/几百级      ms级           分布式架构      0丢失         Java       简单的MQ功能        大数据-实时计算/日志采集

    RocketMQ        10万级      topic几百/几千级      ms级           分布式架构      0丢失         Java       MQ功能较为完善      分布式，扩展性好




4、如何保证消息队列的高可用？

    RabbitMQ                            // 传统 消息队列      ==>    一个queue  ->  完整data

        单机

        普通集群模式（无高可用性）       ==>      数据单点存储     ->      A需要用到时，到B上 主动拉取   ->  B挂了，数据就丢了

        镜像集群模式（高可用性）         ==>      消息同步         ->      每个实例都有一份


        缺点：
            消息需要同步到所有机器     ->      带宽压力、性能开销
            非分布式                  ->      无扩展性            // 无法针对queue_1、queue_2 分别扩展  ->  每个机器 都包含所有queue的完整数据


    Kafka                               // 分布式 消息队列   ==>   分多个broker存储  =>   一个broker -> 存储部分data


        天然的分布式消息队列      ==>     一个 topic 的数据，是分散放在多个机器上的，每个机器只放一部分数据


        topic  ==>  分区存储（去中心化）  ->   topic data1/partition1/broker1   topic data2/partition2/broker2    topic data3/partition3/broker3



        高可用             // 0.8+版本

            broker（leader - follower）


        写数据

            写leader  ->  follower主动pull数据   =>  follower同步ok  ->  返回leader ack确认  ==>  所有follower ok - ack  ->  leader返回生产者ok

        消费
            读leader     ==>     所有follower都同步ok   ->  返回ack   =>  才会被读到



        优点：

            分布式     ->      可针对 指定partition-broker 扩展



5、如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？



6、如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？


7、如何保证消息的顺序性？


8、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？



9、如果让你写一个消息队列，该如何进行架构设计？说一下你的思路。


