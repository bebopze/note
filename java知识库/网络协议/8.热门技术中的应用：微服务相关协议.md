## 8. 热门技术中的应用：微服务相关协议


#### 8.1  RPC协议综述：远在天边，近在眼前

```
    
    ⼩结：
    
        远程调⽤看起来⽤ Socket 编程就可以了，其实是很复杂的：
            
            要解决协议约定问题、传输问题和服务发现问题。
        
        
        ⼤⽜ Bruce Jay Nelson 的论⽂、早期 ONC RPC 框架，以及	NFS 的实现，给出了解决这三⼤问题的示范性实现：
        
            也即协议约定要公⽤协议描述⽂件，并通过这个⽂件⽣成	Stub 程序；
            
            RPC 的传输⼀般需要⼀个状态机，需要另外⼀个进程专⻔做服务发现。
    
        
    
    QA：
        
        1. 在这篇⽂章中，mount 的过程是通过系统调⽤，最终调⽤到 RPC 层。
        
            ⼀旦	mount 完毕之后，客户端就像写⼊本地⽂件⼀样写⼊ NFS 了，这个过程是如何触发 RPC 层的呢？
            
            
            回复：
                
                rpc调用是在进行读写操作时，调用的操作系统的读写接口，
                
                nfs对接口做了实现，实现的代码里封装了rpc。
                
                
                --
                
                应用在读写文件时，会创建文件描述符，NFS Client会将文件描述符的操作代理成RPC请求。
                
                
        
        2. ONC RPC 是早期的 RPC 框架，你觉得它有哪些问题呢？
        
            需要调用双方有接口描述文件，有文件就需要双方要做信息交换，所以客户端和服务端不是完全透明的
            
            -- 
            
            XDR有严格的格式限制，两端必须完全匹配，无法支持灵活数据格式的传递。
        
        
        
        3. 我们目前的分布式系统采用以下方式：
            
            我们实现了一种中间件，每个进程（客户端）要与其他进程通信，
            
            就要到中间件注册（注册了自己进程的一个ID，任务名称，还有一个消息队列），
            
            然后将消息用google的protobuf封装进行传输（因为这种序列化的效率高）。
            
            在其他进程中接收到消息，会解析消息id，然后根据定义好的格式去取内容。
            
            这样也算RPC调用吧？
        
        
            回复: 是的
            
            
               
        
```


#### 8.2  基于XML的SOAP协议：不要说NBA，请说美国职业篮球联赛

```
    
    ⼩结：
    
        原来的⼆进制 RPC 有很多缺点：
        
            格式要求严格，修改过于复杂，不⾯向对象
         
            
        于是产⽣了 基于⽂本 的调⽤⽅式 —— 基于 XML 的 SOAP
        
        
        SOAP 有三⼤要素：
            
            协议约定⽤ WSDL、传输协议⽤ HTTP、服务发现⽤	UDDL。
    
        
    
    QA：
        
        1. webservice soap的初始目标：服务自描述，其实就是没有达成，UDDI早已默默死掉
        
            回复: 是的，但是作为rpc历史上不能不说的一个环节，也要讲一下
        
        
        2. 这个二进制格式，怎么转换为xml这种格式呢？过程是怎么解析的呢？
            
            不会有二进制转换成为xml，是由对象转换成为xml
            
            
        
```



#### 8.3  基于JSON的RESTful接口协议：我不关心过程，请给我结果

```
    
    ⼩结：
    
        SOAP 过于复杂，⽽且设计是⾯向动作的：
        
            因⽽往往因为架构问题导致 并发量上不去。
        
        
        
        RESTful 不仅仅是⼀个 API，⽽且是⼀种架构模式：
        
            主要⾯向资源，提供⽆状态服务，有利于横向扩展应对⾼并发。
        
            
        
    QA：
        
        1. 在讨论 RESTful 模型的时候，举了一个库存的例子，但是这种方法有很大问题，那你知道为什么要这样设计吗？
           
            此方法的问题在于，不是解决问题，而是将数据状态进行了转移，将状态交给存储，
           
            这样业务将可以无状态化运行，这种设计可以很好的解决扩展的问题。
           
            因为无状态，可以进行负载均衡！使用集群化来解决单机的问题。
            
            
               
        2. 基于文本的 RPC 虽然解决了二进制的问题，但是它本身也有问题，你能举出一些例子吗？
           
            1、效率问题：
            
                程序与文本之间转换效率低，因而不适合内部大数据交换，因为文本利于阅读，对外采用较好
           
            2、相比于二进制rpc，传输需要的带宽更大：
            
                二进制的rpc因为可以使用专用的客户短和服务器代码，可以更好的压缩数据，以提供更大的吞吐量
            
            
        
        3. 文本传输最终都会转化为二进制流啊，为什么文本要比二进制rpc占用带宽？
        
            数字2如果用int传输用几个bit，如果是字符串呢？


```



#### 8.4  二进制类RPC协议：还是叫NBA吧，总说全称多费劲

```
    
    ⼩结：
    
        RESTful API 对于接⼊层和 Controller 层之外的调⽤，已基本形成事实标准。
                
        但是随着内部服务之间的调⽤越来越多，性能也越来越重要，于是	Dubbo 的 RPC 框架有了⽤武之地。
        
        
        Dubbo：
            
            通过注册中⼼解决服务发现问题，通过 Hessian2 序列化解决协议约定的问题，通过 Netty 解决⽹络传输的问题。
        
        
        在更加复杂的微服务场景下：
        
            Spring Cloud 的 RESTful ⽅式在内部调⽤也会被考虑，主要是JAR 包的依赖和管理问题。
    
        
    
    QA：
        
        1. spring cloud的restful方式虽然基于json，但是服务端在发送数据之前会将DTO对象转换为JSON，客户端收到JSON之后还会转换为DTO。
        
            这时会在客户端和服务端分别创建各自的DTO对象，会出现代码的重复，如果共享jar，又出现jar管理的问题。
            
            
            回复: 是的，我们是各自定义
            
            
            
        2. Dubbo 和 SpringCloud 各有优缺点？
            
            1、 Dubbo只实现了服务治理，而Spring Cloud子项目分别覆盖了微服务架构下的众多部件。
            
                Spring Cloud使用HTTP协议REST API
            
            2、 Dubbo使用RPC通讯协议
            
                Dubbo通信性能略胜于Spring Cloud
            
            3、 Dubbo通过接口的方式相互依赖，强依赖关系，需要严格的版本控制，对程序无入侵
            
                Spring Cloud 无接口依赖，定义好相关的json字段即可，对程序有一定入侵性
           
           
        3. 跨语言的RPC调用协议？
           
            Thrift是Facebook提供的跨语言轻量级RPC消息和数据交换框架；
            
            Ptotocol Buffers是Google提供的一个开源序列化框架，类似于XML、JSON这样的数据表示语言
            
            
        
        
        4. dubbo 是这个rpc框架包括服务发现，服务均衡负载，接口层面监控。对于rpc中的扩展点比较多。后面会用servicemesh , 传输协议较多选择
           
            spring cloud 是一个完整微服务框架，包括rpc框架,整体链路监控，熔断降级，网关，配置中心，安全验证。主要用http协议传输
           
            
        5. 对于跨语言的，首先要定义非编程语言相关的协议，例如http，protobuf ，
            
            然后需要每个语言需要写相关客户端，
            
            至于复杂程度，就要看服务发现，均衡负载是在客户端实现还是另外写一个代理
            
            
            
```



#### 8.5  跨语言类RPC协议：交流之前，双方先来个专业术语表

```
    
    ⼩结：
    
        GRPC 是⼀种⼆进制，性能好，跨语⾔，还灵活，同时可以 进⾏服务治理 的多快好省的 RPC 框架，
        
        唯⼀不⾜就是还是要写协议⽂件。
        
        
        GRPC 序列化 使⽤ Protocol Buffers，⽹络传输使⽤ HTTP 2.0，服务治理可以使⽤基于 Envoy 的 Service Mesh。
        
        
        
    
    QA：
        
        1. 在讲述 Service Mesh 的时候，我们说了，希望 Envoy 能够在服务不感知的情况下，将服务之间的调用全部代理了，你知道怎么做到这一点吗？
        
        
            在Service Mesh模式中，每个服务都配备了一个代理sidecar（Envoy代理），用于服务之间的通信。
            
            这些代理通常与应用程序一起部署，代理不会被应用程序感知。这些代理组织起来形成服务网格。
            
            Envoy 是 Service Mesh 中一个非常优秀的sidecar的来源实现。
            
        
        
            --
            
            容器系统中，是通过 sidecar 模式来解决的，服务容器都是直接和 envoy sidecar 互通，
            
            envoy 的配置变化，网络拓扑的改变对服务容器都是不可感知的。
            
            service mesh 还更进一步的发展，istio 和 conduit，他们都是在 sidecar 基础上，
            
            又加了一个总的数据控制平面，来加强 service mesh 的掌控能力。
            
            
            --
            
            Envoy就是lstio的核心支持，越来越觉得kubernetes真的是集大成者，
            
            服务治理，面向未来的声明式API架构，资源调度与编排，网络的多种优秀方案。
            
            怪不得可以在极端的时间里力压docker。
            
            
            
            
        
    
        
        
    
```


