### 3. 底层网络知识详解：最重要的传输层


###### 3.1  UDP协议：因性善而简单，难免碰到“城会玩”

```
    
    ⼩结：
    
        如果将 TCP ⽐作成熟的社会⼈，UDP 则是头脑简单的⼩朋友：
        
            TCP 复杂，UDP 简单；
            
            TCP 维护连接，UDP 谁都相信；
        
            TCP 会坚持知进退；UDP 愣头⻘⼀个，勇往直前；
            
        
        UDP 虽然简单，但它有简单的⽤法：
        
            它可以⽤在环境简单、需要多播、应⽤层⾃⼰控制传输的地⽅。
            
            例如 DHCP、VXLAN、QUIC 等。
        
        
            
    QA：
        
        1. 我们可以把发送端和接收端比作河流的两端，把传输的数据包比作运送的石料。
        
            TCP 是先搭桥（即建立连接）再一车一车地运（即面向数据流），确保可以顺利到达河对岸，
            
            当遇到桥上运输车辆较多时可以自行控制快慢（即拥堵控制）；
            
            
            UDP 则是靠手一个一个地扔（即无连接、基于数据报），不管货物能否顺利到达河对岸，也不关心扔的快慢频率。
        
        
        
        2. 所谓的建⽴连接：
        
            是为了在客户端和服务端维护连接，⽽建⽴⼀定的数据结构来维护双⽅交互的状态，
            
            ⽤这样的数据结构来保证所谓的⾯向连接的特性。
            
            
        3. TCP 提供可靠交付：
        
            通过 TCP 连接传输的数据，⽆差错、不丢失、不重复、并且按序到达。
            
            我们都知道 IP 包是没有任何可靠性保证的，⼀旦发出去，就像⻄天取经，⾛丢了、被妖怪吃了，都只能随它去。
            
            但是 TCP 号称能做到那个连接维护的程序做的事情，这个下两节我会详细描述。
            
            
            ⽽UDP继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。
            
            
        4. TCP 是⾯向字节流的：
        
            发送的时候发的是⼀个流，没头没尾。IP 包可不是⼀个流，⽽是⼀个个的 IP 包。
            
            之所以变成了流，这也是 TCP ⾃⼰的状态维护做的事情。
            
            
            ⽽UDP 继承了 IP 的特性，基于数据报的，⼀个⼀个地发，⼀个⼀个地收。    
        
        
        5. TCP 是可以有拥塞控制的：
                        
            它意识到包丢弃了或者⽹络的环境不好了，就会根据情况调整⾃⼰的⾏为，看看是不是发快了，要不要发慢点。
                            
            UDP 就不会，应⽤让我发，我就发，管它洪⽔滔天。
                        
        
        6. TCP 其实是⼀个有状态服务：
                
                    通俗地讲就是有脑⼦的，⾥⾯精确地记着发送了没有，接收到没有，
                    发送到哪个了，应该接收哪个了，错⼀点⼉都不⾏。
                    
                    ⽽ UDP 则是⽆状态服务：
                    
                        通俗地说是没脑⼦的，天真⽆邪的，发出去就发出去了。
                        
                    
                    我们可以这样⽐喻：
                    
                        如果 MAC 层定义了本地局域⽹的传输⾏为，IP 层定义了整个⽹络端到端的传输⾏为
                    
                    这两层基本定义了这样的基因：
                    
                        ⽹络传输是以包为单位的，⼆层叫帧，⽹络层叫包，传输层叫段。
                        
                        我们笼统地称为包。
                        
                        包单独传输，⾃⾏选路，在不同的设备封装解封装，不保证到达。
                        
                        基于这个基因，⽣下来的孩⼦ UDP 完全继承了这些特性，⼏乎没有⾃⼰的思想。
                        
                        
                    
```


###### 3.2  TCP协议（上）：因性恶而复杂，先恶后善反轻松

```
    
    ⼩结：
    
        TCP 包头很复杂，但是主要关注五个问题：
        
            顺序问题，稳重不乱；
            
            丢包问题，承诺靠谱；
            
            连接维护，有始有终；
            
            流量控制，把握分寸；
            
            拥塞控制，知进知退。
        
        
        连接的建⽴是经过三次握⼿，断开的时候四次挥⼿
        
        
        
        建立连接-三次握⼿：
        
```
   ![](image/3__01__TCP建立连接状态图.jpg)
   
```
        断开连接-四次挥⼿：
```
   ![](image/3__02__TCP断开连接状态图.jpg)
```
             
    
    
    QA：
        
        1. 如果是建立链接了，数据传输过程链接断了，客户端和服务器端各自会是什么状态？
            
            或者我可以这样理解么，所谓的链接根本是不存在的，
           
            双方握手之后，数据传输还是跟udp一样，只是tcp在维护顺序、流量之类的控制
           
           
            回复: 
           
                是的，连接就是两端的状态维护，中间过程没有所谓的连接，一旦传输失败，一端收到消息，才知道状态的变化


        2. 流量控制和拥塞控制什么区别？
        
            一个是对另一端的，一个是针对网络的
            
            
        3. 为什么要三次握手？
        
        
            三次握手的目的是 建立可靠的通信信道：
           
           
                说到通讯，简单来说就是数据的发送与接收，
               
                而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
           
           
            第一次握手：Client 什么都不能确认；Server 确认了对方发送正常
           
            第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常
           
            第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常
           
           
            所以三次握手 就能确认 双发收发功能都正常，缺一不可。
        
        
        
        4. 我们做一个基于tcp的“物联网”应用（中国移动网络），
        
            如上面所说tcp层面已经会自动重传数据了，业务层面上还有必要再重传吗？如果是的话，业务需要多久重传一次？
           
                         
            答：TCP的重传是网络层面和粒度的，业务层面需要看具体业务，比如发送失败可能对端在重启，
            
                一个重启时间是1min，那就没有必要每秒都发送检测啊.
           
           
        5. ‘序号的起始序号随时间变化，...重复需要4个多小时’，老师这个重复时间怎么计算出来的呢？
            
            每4ms加1，如果有两个TCP链接都在这个4ms内建立，是不是就是相同的起始序列号呢？
            
            
            答：序号的随时间变化，主要是为了区分同一个链接发送序号混淆的问题，两个链接的话，端口或者IP肯定都不一样了.
            
            
        6. 报文最大生存时间（MSL）和IP协议的路由条数（TTL）什么关系呢，报文当前耗时怎么计算？TCP层有存储相应时间？
            
            答：都和报文生存有关，前者是时间维度的概念，后者是经过路由跳数，不是时间单位.
        
        
        
        
        
        7. 对于同一个技术点，技术的原理是一样的，可是每个人都有自己的理解，
            
            和自己独有的知识关联，因为每个人过往所积累的知识体系有所不同。
            
            
            我对TCP，甚至整个网络知识，喜欢用「信息论」中的一些理论去推演它们。
            
            我觉得在现在和未来的时代，「信息论」是一把利器。
            
            
            信息论中，有个很重要的思想：
                
                要想消除信息的不确定性，就得引入信息。
                
                将这个思想应用到TCP中，很容易理解TCP的三次握手和四次挥手的必要性：
                
                    它们的存在以及复杂度，就是为了消除不确定性，这里我们叫「不可靠性」吧。
                    
            
            拿三次握手举例：        
                
                为了描述方便，将通信的两端用字母A和B替代。A要往B发数据，A要确定两件事：
            
                    1. B在“那儿”，并且能接受数据 —— B确实存在，并且是个“活人”，能听得见
                    2. B能回应 —— B能发数据，能说话 
                
                
                为了消除这两个不确定性，所以必须有前两次握手：
                
                    即A发送了数据，B收到了，并且能回应——“ACK”
               
            
                同样的，对于B来说，它也要消除以上两个不确定性，通过前两次握手：
                
                    B知道了A能说，但是不能确定A能听，这就是第三次握手的必要性。
           
            
            当然你可能会问，增加第四次握手有没有必要？
           
                从信息论的角度来说，已经不需要了，因为它的增加也无法再提高「确定性」
    
    
    
        8. Tcp三次握手设计被恶意利用，造就了DDOS.
        
        
        9. 四次挥手是不是可以做成三次，把第二步和第三步的ACK和FIN一起发？
            
            因为b可能还有一些事情没做完，需要做完了才能结束
        
        
            
            
        10. 流量控制 是 照顾通信对象
            拥塞控制 是 照顾通信环境  
            
            
            顺序问题，seq。
            丢包问题，重传机制。
            流量控制，虚拟发送窗口。
            拥塞控制，到达拥塞点之前指数增长，到达后线性增长。 
            
        
        
        11. 这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢？
        
            当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为半关闭。
            
            能举例说明一下B不能用直接关闭的场景吗？
            
            
            回复: B可以直接关闭，就会主动发FIN
        
        
        
        12. TCP的链接和断开，都是客户端发起的吗？
        
            发起的是客户端，关闭双方都可以
        
        
        13. 小孩快乐很简单
            成人简单很快乐
            
        
        
            
```


###### 3.3  TCP协议（下）：西行必定多妖孽，恒心智慧消磨难

```
    
    ⼩结：
    
        顺序问题、丢包问题、流量控制：
            
            都是通过 滑动窗⼝ 来解决的
            
            
            这其实就相当于你领导和你的 ⼯作备忘录：
        
                布置过的⼯作要有编号，⼲完了有反馈，活不能派太多，也不能太少；
            
        
        拥塞控制：
        
            是通过 拥塞窗⼝ 来解决的
            
            
            相当于往管道⾥⾯倒⽔，快了容易溢出，慢了浪费带宽，要摸着⽯头过河，找到最优值。
            
        
    
    QA：
        
        1. 设备缓存会导致延时？
        
            假如经过设备的包都不需要进入缓存，那么得到的速度是最快的。
            
            进入缓存且等待，等待的时间就是额外的延时。
            
            BBR就是为了避免这些问题：
            
                充分利用带宽；
                
                降低buffer占用率。
                
                
        
        2. 降低发送packet的速度，为何反而提速了？
        
            标准TCP拥塞算法是遇到丢包的数据时快速下降发送速度，因为算法假设丢包都是因为过程设备缓存满了。
            
            快速下降后重新慢启动，整个过程对于带宽来说是浪费的。
            
            通过packet速度-时间的图来看，从积分上看，BBR充分利用带宽时发送效率才是最高的。
            
            可以说BBR比标准TCP拥塞算法更正确地处理了数据丢包。对于网络上有一定丢包率的公网，BBR会更加智慧一点。
            
            回顾网络发展过程，带宽的是极大地改进的，而最小延迟会受限与介质传播速度，不会明显减少。BBR可以说是应运而生。
        
        
        3. BBR如何解决延时？
        
            S1：慢启动开始时，以前期的延迟时间为延迟最小值Tmin。
            
                然后监控延迟值是否达到Tmin的n倍，达到这个阀值后，判断带宽已经消耗尽且使用了一定的缓存，进入排空阶段。
                
            S2：指数降低发送速率，直至延迟不再降低。这个过程的原理同S1
            
            S3：协议进入稳定运行状态。交替探测带宽和延迟，且大多数时间下都处于带宽探测阶段。
            
        
        4. 这么说起来，我们经常发现下载速度是慢慢的增加到顶峰，然后就在那个值的附近徘徊，原因就是tcp的流量控制喽???
        
        
        5. 不太清楚累积应答，比如接收端收到了包1、2、3、4，它的应答应该是5吗？也就是说中间的包就不用应答了吗？
        
            回复: 是的
        
        6. TCP协议栈，保证包一定到吗？
        
            不能保证，只是尽力重试，再重试...
        
        
        7. TCP可靠的连接会不会影响到业务层？
        
            比如超时重传导致了服务端函数调用2次，那岂不是业务都要考虑幂等性了？？？我很懵逼，果然是懂得越多越白痴...    
        
        
            回复：
                
                不会
            
                重传的包不会交给应用层！！！
            
            
        8. 拥塞控制的窗口跟流量控制的窗口一回事吗，还是流量控制的窗口的出来后就会进入拥塞控制窗口？
        
            是一个窗口
        
        
           
```


###### 3.4  套接字Socket：Talk is cheap, show me the code

```
    
    ⼩结：
    
        你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调⽤哪些函数；
        
        写⼀个能够⽀撑⼤量连接的⾼并发的服务端不容易，需要多进程、多线程，⽽ epoll 机制 能解决 C10K 问题。
    
        
    
    QA：
        
        1. Epoll和IOCP还是有本质区别的：
        
            IOCP  是 封装了IO操作的
            epoll 只是 一个事件通知机制
            
            
            意味着IOCP的IO操作也可以由内核完成，因此IOCP算异步IO，
            
            而基于epoll的仍然是同步IO，于IOCP相对应的不是epoll而是AIO。
        
        
        2. 还可以讲的更本质一些：
            
            不论是同步还是异步，阻塞还是非阻塞，都是用某种方法创建了某种结构，
        
            而不同的是，是谁在执行内部的方法，是谁写了标志，是谁触发了事件，是谁在操作io，是谁在等待，是谁在返回。
            
            换句话说就是，本来我在做的事情，让你来做吧，本来你在做的事情，让我来做吧。
        
        
        
        3. 对socket这块一直理解比较抽象，什么情况下需要socket编程？我印象中从来没写过
        
           回复: 很多地方啊，可能都是框架做好了，但是看框架的源代码，还是能看到的    
         
        
           
        4. Epoll里的红黑树是为了快速查找监听的socket吗 我看下面有一个监听链表了
            
            回复: 是的
        
           
        5. UDP的socket的调用过程中，为什么没有listen呢，要不应用程序怎么监听此端口？
        
            要不怎么把UDP的包发往监听此端口的应用程序呢？
            
            基于UDP的方式会不会因为连接数过多，造成服务器处理压力增大从而延迟增高呢？
            
            因为他们共用一个端口，而不是像TCP那样会复制一个套接字随机分配一个端口用于数据接受和发送。
            
            我不知道我说的对不对，希望老师能够解答一下困惑。
           
           
            回复: udp没有状态，所以不存在监听这个状态，
            
                内存里没有保存连接的任何信息，不占用资源，
                
                所以不存在连接数过多的压力，顶多是把网卡打满
                
                
        
            
        6. 这就是几种网络io的由来，bio，nio1，nio2  
        
        
        7. 这一章讲的就是http服务器干的事情，比如nginx
        
        
        8. Udp编程中，服务端只用一个socket收发所有客户端信息好，还是为每个客户端都分配一个socket好呢？
        
            一个
            
        
        
        9. 本篇所得：
        
            UDP基于数据报，TCP基于数据流。
            socket 为 服务端 与 客服端 之间的通讯插口。
            
            
            为了提高 通讯的效率 可以采用多进程的方法：
            
                1.外包项目，创建多进程，每个进程 控制一个 项目 
                
                2.在进程中 创建 线程，用线程控制项目，节省资源 
                
                3.用线程调整项目，可以做到 共享资源，让 线程的项目组 控制 项目 
                
                4.把轮询 改为 主动 通知，节省需要 记录的资源。
            
            
            
        10. 在内核中，为每个 Socket 维护两个队列。为什么是两个？
        
            一个已经建立连接，一个未建立连接        
        
        
        11. fork可能有三种不同的返回值：
                
                在父进程中，fork返回新创建子进程的进程ID；
                在子进程中，fork返回0；
                如果出现错误，fork返回一个负值；
                
        
        12. 为什么epoll维护保存打开的socket要用红黑树这个数据结构呢？
        
            查找快
            
            
        13. 当客户端发起connect函数连接时候，内核为客户端分配临时端口，这临时端口是做什么用的?为什么需要内核分配临时端口？
        
            如果没有端口，tcp包里的源端口没法填，
            
            中间的链路上没办法通过五元组标识一个连接，
            
            返回的结果不知道给哪个应用
            
            
        
        14. socket通信需要确定是基于UDP还是TCP，而且还得知道IP，那么socket是在网络模型中，那一层发起的呢？
        
            应用层发起的
            
            
            
```



