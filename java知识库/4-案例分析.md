### 4. 案例分析

###### 4.1 案例分析（一）：高性能限流器Guava RateLimiter

```
    

```



###### 4.2 案例分析（二）：高性能网络应用框架Netty
```
    
    Netty - ⽹络程序的标配：
        
        Netty 是⼀个⾼性能⽹络应⽤框架，应⽤⾮常普遍，⽬前在	Java领域⾥，Netty 基本上成为⽹络程序的标配了。
        Netty 框架功能丰富，也⾮常复杂，今天我们主要分析	Netty 框架中的线程模型，⽽线程模型直接影响着⽹络程序的性能。
        
        
        在介绍 Netty 的线程模型之前，我们⾸先需要把问题搞清楚，了解⽹络编程性能的瓶颈在哪⾥，
        然后再看 Netty 的线程模型是如何解决这个问题的。
        
    
        
    网络编程性能的瓶颈：
    
        阻塞式 I/O（BIO）：
        
            BIO 模型⾥，所有	read() 操作和 write() 操作 都会阻塞 当前线程 的，
            如果客户端已经和服务端建⽴了⼀个连接，⽽迟迟不发送数据，那么服务端的	read() 操作会⼀直阻塞，
            所以使⽤ BIO 模型，⼀般都会为每个 socket 分配⼀个独⽴的线程，
            这样就 不会因为 线程阻塞在⼀个 socket 上⽽影响对其他 socket 的读写。
            
            BIO 的线程模型如下图所示，每⼀个socket 都对应 ⼀个独⽴的线程；
            为了避免频繁创建、消耗线程，可以采⽤线程池，但是 socket 和线程之间的对应关系并不会变化。
        
        
        
        BIO 的线程模型：
        
            BIO 这种线程模型 适⽤于 socket连接 不是很多 的场景；
            
            
            百万连接：
            
                现在的互联⽹场景，往往需要服务器能够⽀撑⼗万甚⾄百万连接，
                
                ⽽ 创建⼗万甚⾄上百万个线程 显然 并不现实，所以	BIO线程模型 ⽆法解决 百万连接的问题。
            
            
            痛点 - 等待I/O就绪：
            
                如果仔细观察，你会发现互联⽹场景中，虽然连接多，
                
                但是 每个连接上的请求 并不频繁，所以 线程 ⼤部分时间 都在等待 I/O就绪。
                
                也就是说 线程⼤部分时间 都阻塞在那⾥，这完全是浪费，
                
                如果我们能够解决这个问题，那就不需要这么多线程了。
            
            
            线程模型优化：
                
                顺着这个思路，我们可以将线程模型优化为下图这个样⼦，
                
                可以⽤ ⼀个线程 来处理 多个连接 ，这样 线程的利⽤率 就 上来了，同时 所需的线程数量 也跟着 降下来 了。
                
                
                BIO 相关的 API 是⽆法实现的：
                
                    因为 BIO 相关的 socket 读写操作 都是阻塞式 的，⽽⼀旦调⽤了阻塞式 API，
                    
                    在 I/O就绪 前，调⽤线程 会 ⼀直阻塞，也就 ⽆法处理 其他的	socket 连接了。
                
                
            
        NIO：
        
            Java⾥还提供了 ⾮阻塞式（NIO）API，
            
            利⽤ ⾮阻塞式API 就能够实现 ⼀个线程处理多个连接 了。
            
            
            具体如何实现：
            
                现在普遍都是采⽤ Reactor 模式，包括 Netty 的实现。
                
                所以，要想理解 Netty的实现，就需要先了解⼀下 Reactor 模式。
            
            
            Reactor 模式：
            
                下⾯是 Reactor 模式的类结构图，
                
                
                Handle            ==>     ⽹络连接
                
                Event Handle      ==>     事件处理器         
                
                    handle_event()      ==>     处理 I/O 事件：
                        
                        一个 Event Handle（事件处理器） 处理⼀个 I/O Handle（⽹络连接）
                
                    get_handle()        ==>     返回 这个 I/O 的 Handle（⽹络连接）
                    
                    
                    Synchronous Event Demultiplexer      ==>     操作系统 提供的 I/O 多路复⽤API
                        
                        例如 POSIX 标准⾥的 select() 以及 Linux ⾥⾯的 epoll()
                        
                
                       
                详述：
                    其中 Handle 指的是 I/O句柄，在 Java⽹络编程⾥，它 本质上 就是 ⼀个⽹络连接。
                    
                    Event Handler 很容易理解，就是⼀个事件处理器，其中 handle_event() ⽅法 处理 I/O 事件，
                    
                    也就是每个 Event Handler 处理⼀个	I/O Handle；
                    
                    get_handle() ⽅法 可以返回 这个 I/O 的 Handle。
                    
                    Synchronous Event Demultiplexer 可以理解为 操作系统 提供的 I/O 多路复⽤API，
                    
                    例如 POSIX 标准⾥的 select() 以及 Linux ⾥⾯的 epoll()。
        
        
                
                Reactor 类：
                
                    Reactor 模式的核⼼⾃然是Reactor 这个类，
                    
                        register_handler() 注册 ⼀个事件处理器
                    
                        remove_handler()   删除 ⼀个事件处理器
                    
                        handle_events() ⽅式是核⼼，也是 Reactor 模式的发动机，
                            
                            这个⽅法的核⼼逻辑如下：
                            
                                ⾸先通过 同步事件 多路选择器 提供的 select() ⽅法 监听⽹络事件，
                                
                                当有 ⽹络事件 就绪 后，就 遍历 事件处理器 来 处理 该⽹络事件。
                                
                                由于 ⽹络事件 是 源源不断 的，
                                
                                所以在 主程序中 启动 Reactor 模式，需要以 while(true){} 的⽅式调⽤ handle_events() ⽅法。
                                
                                
                                
                            
                        
```