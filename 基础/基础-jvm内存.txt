========================================================================================================================
堆与栈                                 // 栈 ->  运行逻辑               堆 -> 共享内存（数据存储）
========================================================================================================================

堆与栈：

    栈   ->   运行时的单位

    堆   ->   存储的单位



堆栈分离：                           // 栈中 也可以 存储数据，为什么要把 堆和栈 区分出来？

    1、分治思想

        从软件设计的角度看：

            栈   ->   代表了   逻辑处理
            堆   ->   代表了   数据


        这样分开，使得处理逻辑更为清晰。

        分而治之 的思想

            这种隔离、模块化的思想在软件设计的方方面面都有体现


    2、共享

        堆中的内容  ->   可以被 多个栈(线程)共享         // 也可以理解为多个线程访问同一个对象

            1、这种共享提供了一种有效的     ->     数据交互方式（如：共享内存）

            2、堆中的 共享常量 和 缓存      ->    可以被所有栈访问，节省了空间


    3、动态增长

        栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分

        由于栈只能向上增长，因此就会限制住栈存储内容的能力。

        而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可


    4、面向对象

        面向对象 就是堆和栈的完美结合

            其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。
            但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。

        当我们把对象拆开，你会发现

            1、对象的属性其实就是数据，存放在堆中；

            2、而对象的行为（方法），就是运行逻辑，放在栈中。

        我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。





========================================================================================================================
堆中存什么？栈中存什么？                                                https://hllvm-group.iteye.com/group/wiki/2858-JVM
========================================================================================================================

存的什么：

    堆中存的是     ->     对象

    栈中存的是     ->     基本数据类型  和  堆中对象的引用


堆栈分离的好处：

    一个对象的大小是不可估计的，或者说是可以动态变化的

    但是在栈中，一个对象只对应了一个 4byte 的引用



为什么不把  基本类型  放堆中：

    1、需要空间比较少

        其占用的空间一般是 1~8个字节

    2、长度固定

        基本类型   ->   不会出现 动态增长的情况，长度固定     ->  因此 栈中存储 就够了

                       如果 把它存在堆中 是没有什么意义的    ->  还会浪费空间

    --------------------------------------------------
    可以这么说

        基本类型 和 对象的引用 都是存放在 栈中

        而且都是 几个字节的一个数

        因此在程序运行时，他们的处理方式是统一的

    --------------------------------------------------
    但是 基本类型、对象引用  和  对象本身  就有所区别了

        基本类型、对象引用       ->     栈 中的数据

        对象本身                ->     堆 中的数据

        ---------------------------------------------
        最常见  ->  Java中 参数传递 时的问题

            调用者     ->      传入的参数为   对象引用
            执行者     ->      使用的是       对象本身



对比：

    1、堆和栈中，栈是  ->  程序运行 最根本的东西

        程序运行   ->   可以没有堆，但是 不能没有栈

    2、堆是为栈  进行 数据存储服务                           // 本质上 堆是栈的 存储介质

        说白了，  堆  ->  就是一块共享的内存

    3、正是因为 堆和栈的 分离思想

        才使得  Java的垃圾回收  成为可能

            栈回收     ->      方法执行完，弹栈 回收

            堆回收     ->      栈回收   ->   堆中  被栈引用的对象   成为垃圾



========================================================================================================================
数据类型
========================================================================================================================

数据类型

    Java虚拟机中，数据类型可以分为两类：

        1、基本类型

            基本类型的变量   保存 原始值            // 即：它代表的值就是 数值本身


        2、引用类型

            引用类型的变量   保存 引用值           // “引用值”代表了  某个对象的引用（地址），而不是对象本身


基本类型包括：

    byte、short、int、long、char、float、double、boolean

    returnAddress

引用类型包括：

    类、接口、数组



========================================================================================================================
Java对象的大小
========================================================================================================================

1、基本类型

    大小固定

2、引用类型

    动态


    声明一个空Object 至少需要的空间     ==>    4 + 8 = 12 byte

        Object

            栈   ->   4 byte             //  Java栈中 保存引用的所需要的空间
            堆   ->   8 byte             //  Java堆中 对象的信息                ->    所有对象大小（堆）   都 > 8 byte


    基本类型的包装类

        1、继承自Object                 ->    12 byte

        2、Java对象大小是8的整数倍       ->   至少 16 byte

        3、这个内存占用是很恐怖的，它是使用 基本类型的N倍（N>2），有些类型的内存占用更是夸张（随便想下就知道了）

            可能的话应尽量少使用包装类

            在JDK5.0以后，因为加入了 自动类型装换，因此，Java虚拟机会在存储方面 进行相应的优化。




========================================================================================================================
对象引用类型
========================================================================================================================

对象引用类型：               //  强引用  >  软引用（SoftReference）  >  弱引用（WeakReference）  >  虚引用（PhantomReference）

    1、强引用

        就是我们一般声明对象时 虚拟机生成的引用

        强引用环境下

            1、垃圾回收时       ->     需要严格判断  当前对象是否被强引用

            2、如果被强引用     ->     则不会被垃圾回收


    2、软引用

        软引用一般被做为 缓存 来使用

        与强引用的区别是

            1、软引用在垃圾回收时，虚拟机会根据  当前系统的剩余内存   来决定是否对软引用进行回收

            2、 如果剩余内存  比较紧张      ->       则虚拟机会回收软引用所引用的空间

                如果剩余内存  相对富裕      ->       则不会进行回收

            3、换句话说，虚拟机在发生 OutOfMemory 时   ->   肯定是没有软引用存在的


    3、弱引用

        弱引用与软引用类似，都是作为 缓存 来使用

        但与软引用不同

            1、弱引用在进行垃圾回收时       ->      一定会被回收掉

            2、因此其生命周期              ->       只存在于 一个垃圾回收周期内


    4、虚引用

        “虚引用”顾名思义，就是    ->    形同虚设


        与其他几种引用都不同

            1、虚引用  并不会决定 对象的生命周期

            2、如果一个对象仅持有虚引用

                1、那么它就和没有任何引用一样

                2、在任何时候都可能 被垃圾回收器回收


对比：

    强引用不用说，我们系统一般在使用时都是用的强引用。

    而“软引用”和“弱引用”比较少见。

    他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。

    因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。

    因而，他们常见的是被使用在桌面应用系统的缓存。




========================================================================================================================
垃圾回收 ———— 回收什么
========================================================================================================================

内存分区：

    线程共享    ->      方法区、堆

    线程私有    ->      Java方法栈、native方法栈、PC寄存器


------------------------------------------------------------------------------------------------------------------------
垃圾回收：

    1、重灾区       ->      堆

        Java栈、native栈、方法区   引用的对象     ->    都存储在  堆


    2、方法区       ->      永久代         ->      常量池的常量回收 、 类的回收

        方法区，虽然方法区被称为“永久代”

        但是HotSpot虚拟机的设计团队选择把     ->     GC分代收集 扩展至了 方法区

        比如：
            常量池的常量回收、类的回收


    3、线程私有      ->      自动回收

        Java栈、native方法栈、PC计数器     ->    都是线程私有的    ->   用完之后会   自动释放


------------------------------------------------------------------------------------------------------------------------
堆引用：

    方法区  和   栈（Java方法栈、native方法栈）

    都只存了   堆对象的 引用       ->      指向 堆         ====>       真实对象  都统一存储在   ->   堆



堆回收：

    所谓的垃圾回收：

        方法区（remove）、栈（弹栈）     ->     断开了对   堆中对象的引用

        这些  被断开引用的对象           ->     就是废弃对象    ->    就是垃圾


    所以，垃圾回收     ->      主要就是回收  堆内存



栈回收：

    线程私有    ->    方法执行完毕，自动弹栈    -->    自动回收



方法区 回收：

    GC分代收集  扩展至  方法区

        常量池的常量回收、类的回收



========================================================================================================================
垃圾回收 ———— 怎么回收
========================================================================================================================

不同角度看：

    1、查找垃圾 方式

        引用计数

        可达性分析


    2、回收策略

        标记-清除

        标记-复制

        标记-整理


    3、分代回收

        新生代

        老年代

        永久代（方法区）


    4、系统线程

        串行（单线程）

        并行（多线程）

        并发（减少暂停）




------------------------------------------------------------------------------------------------------------------------
1、查找垃圾 方式
------------------------------------------------------------------------------------------------------------------------

1、引用计数                          // 古老

    原理：
        对象被     新增一个引用        ->      增加一个计数
                  删除一个引用        ->      减少一个计数

    垃圾判定：

        垃圾回收时，计数为0 的对象    ->  垃圾

    bug：
        无法解决 循环引用


2、可达性分析                       // 现代 主流

    原理
        通过 一系列称为 “GC Roots" 的对象 作为起始点，从这些结点开始向下搜索，搜索所走过的路径  称为 引用链（Reference Chain）

    垃圾判定：
        当一个对象  和  GC Roots  没有任何引用链 相连时      ->      此对象是没人用的       ===>      垃圾



    可作为 GC Roots 的对象：

        Java栈中                         引用的对象          -->      堆

        本地方法栈  JNI                   引用的对象          -->      堆

        方法区中   类静态属性（static）    引用的对象          -->      堆

        方法区中   常量（final）          引用的对象          -->      堆



    优点：
        解决了 循环引用



------------------------------------------------------------------------------------------------------------------------
2、回收策略                                                            https://hllvm-group.iteye.com/group/wiki/2861-JVM
------------------------------------------------------------------------------------------------------------------------

1、标记-清除（Mark-Sweep）

    此算法执行分两阶段：
        1、标记    ->      从引用根（GC Roots）节点开始     标记所有被引用的对象
        2、清除    ->      遍历 整个堆                     把未标记的对象清除

    缺点：
        1、此算法需要 暂停整个应用
        2、会产生内存碎片


2、标记-复制（Mark-Copying）

    原理：
        1、内存两等分     ->      内存划分两等分，每次只使用其中一个                   // 双倍空间  ->  空间利用率低

        2、标记          ->      从引用根（GC Roots）节点开始     标记所有被引用的对象
        3、复制          ->      遍历 当前使用区域                把标记的对象 复制到 另一区域

    优点：
        1、只复制被引用的对象      ->      复制成本小
        2、复制同时还能重新整理    ->      不会出现"碎片"

    缺点：
        双倍内存空间  ->  空间利用率低


3、标记-整理（Mark-Compact）

    思想：
        标记-清除   +   标记-复制

    过程：
        1、标记                   ->      从引用根（GC Roots）节点开始     标记所有被引用的对象
        2、清除 + 压缩(整理)       ->      遍历 整个堆                     清除未标记对象，并且把存活对象“压缩”到堆的其中一块，按顺序排放

    优点：
        1、避免了“标记-清除”的       碎片问题
        2、避免了“复制”算法的        空间问题



------------------------------------------------------------------------------------------------------------------------
3、分代回收
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1、增量收集（Incremental Collecting）

    实时 垃圾回收算法     ->     在应用进行的同时 进行垃圾回收

    // 不知道什么原因JDK5.0中的收集器没有使用这种算法的


2、分代收集（Generational Collecting）

    基于对 对象生命周期（二八法则） 分析后，得出的垃圾回收算法

        1、把对象分为年轻代、年老代、持久代

        2、对不同生命周期的对象     ->    使用不同的算法（上述[回收策略]中的一种）进行回收


    // 现在的垃圾回收器（从J2SE1.2开始）都是使用此算法



------------------------------------------------------------------------------------------------------------------------
4、系统线程
------------------------------------------------------------------------------------------------------------------------

1、串行收集                                                      // 单线程

    串行收集使用 单线程 处理所有垃圾回收工作

        无需多线程交互    ->   实现容易，效率比较高

    但是，其局限性也比较明显

        无法使用 多核处理器 的优势

    适用场景：

        1、单核处理器 机器

        2、小数据量（100M左右）情况下的  多处理器机器上


2、并行收集                                                     // 多线程

    并行收集使用 多线程 处理垃圾回收工作

        速度快，效率高

    而且理论上CPU数目越多，越能体现出并行收集器的优势


3、并发收集                                                     // 并发执行    +    不暂停（stop-the-world）

    并发收集：

        在运行中 回收垃圾       ->      不需要暂停（stop-the-world）


    串行/并行收集：

        进行垃圾回收时

            1、需要  暂停  整个运行环境    ->     只有  垃圾回收程序  在运行

            2、因此，系统在垃圾回收时      ->     会有明显的 卡顿（暂停）        // 而且 堆越大  ->  暂停时间越长


------------------------------------------------------------
stop-the-world




========================================================================================================================
分代
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
1、为什么要分代
------------------------------------------------------------------------------------------------------------------------

分代的 垃圾回收策略，是基于观察得出的事实：

    不同对象的生命周期      ->     是不一样的         // 二八法则


    ==>   不同生命周期的对象      ->     采取 不同的垃圾回收方式     ->    提高 回收效率



在Java程序运行的过程中，会产生大量的对象

    1、长生命周期对象

        其中 有些对象   ->    是与 业务信息相关，跟 业务直接挂钩    ->   因此  生命周期比较长

        比如：Http请求中的Session对象、线程、Socket连接

    2、短生命周期对象

        但是还有一些对象   ->    主要是 程序运行过程中 生成的   临时变量    ->   这些对象   生命周期会比较短

        比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。


试想，在不进行 对象存活时间区分 的情况下

    1、每次垃圾回收 都是对整个堆空间 进行回收，花费时间相对会长

    2、同时，因为每次回收 都需要遍历 所有存活对象

        但实际上，对于 生命周期长的对象 而言，这种遍历 是没有效果的

        因为可能进行了 很多次遍历，但是他们 依旧存在。


    3、因此，分代垃圾回收采用  分治的思想，进行 代的划分

        把不同生命周期的对象   ->   放在不同代上

        不同代上 采用最适合它的 垃圾回收方式 进行回收



------------------------------------------------------------------------------------------------------------------------
2、如何分代
------------------------------------------------------------------------------------------------------------------------

虚拟机中的共划分为三个代：

    新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）

        新生代和老年代 的划分   ->   是对垃圾回收 影响比较大的

        永久代                 ->   主要存放的是 Java类的类信息     ->     与垃圾回收 要收集的Java对象 关系不大




------------------------------------------------------------------------------------------------------------------------
新生代:
------------------------------------------------------------------------------------------------------------------------
    所有 新生成的对象  首先都是放在 年轻代 - Eden区

        Eden    +    Survivor(From)    +    Survivor(To)

    年轻代的目标

        尽可能快速的 收集掉那些 生命周期短 的对象

------------------------------------------------------------------------------------------------------------------------
老年代:
------------------------------------------------------------------------------------------------------------------------
    在 新生代中经历了N次（默认15次） 垃圾回收后   ->   仍然存活的对象    ->   就会被放到 老年代中


    老年代中存放的
        都是一些 生命周期较长 的对象

------------------------------------------------------------------------------------------------------------------------
永久代:
------------------------------------------------------------------------------------------------------------------------
    用于存放 静态文件   ->   如： Java类、方法等

        持久代对垃圾回收 没有显著影响

        但是有些应用可能 动态生成或者调用一些class

            例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

            持久代大小通过-XX:MaxPermSize=<N>进行设置。



------------------------------------------------------------------------------------------------------------------------
3、什么情况下 触发垃圾回收
------------------------------------------------------------------------------------------------------------------------

Minor GC 触发机制：

    新生代 - Eden区 空间不足       ->      触发 Minor GC                     // Survivor区 满   ->   不会引发GC

------------------------------------------------------------------------------------------------------------------------
Full GC 触发机制：

    1、老年代 空间不足

    2、方法区 空间不足            ===>     当永久代满时 也会引发 Full GC   ->   会导致 Class、Method 元信息 的卸载

    3、显示调用 System.gc()      ->     系统建议执行 Full GC，但是不必然执行

    4、通过 Minor GC 后，进入老年代的平均大小   大于   老年代的可用内存

    5、由   Eden + Survivor(From)   -->    Survivor(To)  复制时

        对象大小  大于  To 可用内存   ->   则  转存到 老年代

        且老年代的可用内存 小于 该对象大小





========================================================================================================================
GC                                                                  - https://www.zhihu.com/question/41922036
========================================================================================================================

GC 的各种名称概念   比较混乱

    说下我的理解：

        1、如果笼统一点，就是一切归咎   ->   历史原因


        2、其实就是 设计比较糟糕😰

            作者自己都没搞清楚      没有一个清晰的架构模型      就是边做边改而已


        3、或者说 设计争议比较大                 // 也是由于 JMM 确实复杂

            旧有的模型、模块    功能不断拿的 变化、废弃

            新的模型、新的名称  不断的提出


            ====>   造成大量  新旧 名称、概念、模块     功能上  的变化、模糊、甚至重叠      ->     相互覆盖 又带有些许变化


------------------------------------------------------------------------------------------------------------------------
几个概念：

    Young GC（新生代 GC）        ->      Minor GC

    Old   GC（老年代 GC）        ->      Full GC     、   Major GC



------------------------------------------------------------------------------------------------------------------------
针对HotSpot VM的实现，它里面的GC其实 准确分类只有两大种：


    1、Partial GC（部分GC）          ->       收集  堆的某一区域

        Young GC       只收集 young gen  的GC

        Old   GC       只收集 old   gen  的GC        ->      只有 CMS 的concurrent collection  是这个模式

        Mixed GC       收集整个 young gen  +  部分old gen   的GC        ->          只有 G1 有这个模式



    2、Full GC（完全GC）             ->       收集  整个堆

        包括 young gen、old gen、perm gen（如果存在的话）等所有部分的模式


------------------------------------------------------------------------------------------------------------------------
Major GC 通常是跟 Full GC  是等价的      ->    收集 整个GC堆

    但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了

    当有人说 “Major GC” 的时候，一定要问清楚他想要指的是上面的 Full GC 还是 old GC



========================================================================================================================
垃圾收集器
========================================================================================================================

串行处理器：                                                               // stop-the-world       单核CPU       JDK1.5之前默认

    适用情况：
        单CPU     或     数据量比较小（100M左右）  +   对响应时间无要求

    缺点：
        只能用于 小型应用


并行处理器：                                                                // stop-the-world       多核CPU  ->  提高吞吐量

    适用情况：
        多CPU    +   对吞吐量有高要求

    场景：
        后台处理、科学计算

    缺点：
        会暂停

        并行 ->  增加 线程通信 成本    ==>   相比于 单核串行GC，应用响应时间 可能加长


并发处理器：                                                                // 不暂停（减少 暂停）    ->    提高响应速度

    适用情况：
        多CPU    +   对响应时间有高要求

    场景：
        互联网应用
        Web服务器/应用服务器、电信交换、集成开发环境

------------------------------------------------------------------------------------------------------------------------

串行处理器                                                                     // 暂停         单核CPU

    新生代         Serial                                      复制

    老年代         Serial Old                                  标记-整理


并行处理器                                                                      // 暂停        多核CPU  ->  提高吞吐量

    新生代         Parallel Scavenge 、 ParNew                 复制

    老年代         Parallel Old                                标记-整理


并发处理器                                                                      // 不暂停（减少 暂停）   ->    提高响应速度

    老年代         CMS（Concurrent Mark-Sweep）                标记-清除

    all           G1                                          标记-整理  +  复制



------------------------------------------------------------------------------------------------------------------------
组合的选择

    单CPU或小内存，单机程序
        -XX:+UseSerialGC

    多CPU，需要最大吞吐量，如后台计算型应用
        -XX:+UseParalellGC     或     -XX:+UseParalellOldGC

    多CPU，追求低停顿时间、需快速响应，如互联网应用
        -XX:+UseParNewGC       或     -XX:+UseConcMarkSweepGC   /   -XX:+UseG1GC

------------------------------------------------------------------------------------------------------------------------
JVM给了三种选择：

    串行收集器、并行收集器、并发收集器


串行收集器   ->   只适用于 小数据量的情况

    选择主要针对  并行收集器 和 并发收集器

        默认情况下

        JDK5.0以前   ->   都是使用 串行收集器             如果想使用其他收集器  ->   需要在启动时 加入相应参数

        JDK5.0以后   ->   JVM会  根据当前系统配置  进行判断


------------------------------------------------------------------------------------------------------------------------
1、并行收集器         ->      吞吐量优先

    并行收集器主要

        以  到达一定的吞吐量  为目标

    适用于

        科学计算、后台处理


2、并发收集器         ->      响应时间优先

    并发收集器主要是

        1、保证系统的 响应时间

        2、减少  垃圾收集时的  停顿时间

    适用于

        应用服务器、电信领域等



========================================================================================================================
默认GC                                                                        // 参数可配
========================================================================================================================

Java 5          串行          Serial GC                       ->    Serial（新生代）             +   Serial Old（老年代）

Java 8          并行          Parallel GC                     ->    Parallel Scavenge（新生代）  +   Parallel Old（老年代）

Java 11         并发          G1


------------------------------------------------------------------------------------------------------------------------
命令
    java -XX:+PrintCommandLineFlags -version       ==>    -XX:+UseParallelGC

    java -XX:+PrintGCDetails -version






========================================================================================================================
新生代
========================================================================================================================

新生代：

    Eden    +    Survivor(From)    +    Survivor(To)

        Survivor 可以通过参数 配置N个

        动态分配的策略         ->      根据 生成对象的速率，以及 Survivor区的使用情况，动态调整 Eden区 和 Survivor区 的比例

                             ->      也可以通过参数 固定比例

Eden：
    新建对象   ->   都在 Eden区


堆内存（线程共享）申请的 并发bug：

    堆空间   ->   线程共享     ===>      new指令  ->  申请空间  的并发安全问题


    ===>    必须同步（加锁）     -->    否则，可能造成    ->    多个对象 共用同一段内存       // 两个司机（线程）  同时将车 停入同一个停车位


TLAB（Thread Local Allocation Buffer）：               // 线程本地分配缓冲区

    加锁，预申请一段 连续内存

        每个司机（线程）   ->    预先申请 多个停车位    ->    只允许该司机 停在自己的停车位上

        每个线程    ->      申请一段 连续的内存      ->      作为线程的 私有TLAB


        当然，这个操作必须     ===>    加锁


    实现：
        1、加锁
        2、两个指针      ->      TLAB头  +  TLAB尾

        3、new指令  <=  TLAB 内存     ==>   成功
        4、new指令  >   TLAB 内存     ==>   失败       ===>        触发 重新申请 一段更大的TLAB

        5、Eden区 空间耗尽    ->      触发 Minor GC         ===>     存活下来的对象  ->  移入Survivor区



Minor GC：

    1、Eden区 和 from指向的Survivor区 中的 存活对象    ->     会被复制到 to指向的Survivor区 中

    2、然后交换 from 和 to 指针         ->      以保证下一次 Minor GC 时，to指向的Survivor区  还是空的


    3、JVM 会记录 Survivor区中的对象 一共被来回复制了几次

        1、如果一个对象被复制的次数为 15，那么该对象     ->     将被晋升（promote）至 老年代

        2、如果单个 Survivor区 已经被占用了 50%        ->     那么较高复制次数的对象  也会被晋升至 老年代



    4、采用  标记-复制 算法

        理想情况下，Eden区的对象基本都死亡了        ->      需要 复制的数据 都非常少


    5、不用对 整个堆 进行垃圾回收

        但是  ->  老年代的对象  可能引用  新生代的对象        ===>        又要做 全堆 扫描？？？   ->  卡表


卡表：

    维护一个卡表          // HotSpot

        1、整个堆 被划分为一张张卡     ===>

        2、卡表存储了 每张卡的标识位   ->   表示 是否可能指向  新生代对象

        3、是  ->  脏卡


    Minor GC 可以不用 扫描整个老年代

        1、而是在卡表中 寻找脏卡

        2、将 脏卡中的对象 加入到 Minor GC 的 GC_Roots                       ->      完成脏卡扫描  ->  所有脏卡标识位 清零

        3、Minor GC      ->      存活对象的复制     ->    更新引用           ->      同时，又会更新 引用卡的标识位




========================================================================================================================
老年代
========================================================================================================================







========================================================================================================================

========================================================================================================================
