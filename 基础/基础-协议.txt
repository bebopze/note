1、Paxos算法

    在多个节点间确定某变量的值

        1、Basic Paxos 是通过 二阶段提交 的方式来达成共识的

            二阶段提交是达成共识的常用方式，如果你需要设计新的共识算法的时候，也可以考虑这个方式

        2、除了共识，Basic Paxos 还实现了容错

            在少于一半的节点出现故障时，集群也能工作

            它不像分布式事务算法那样，必须要所有节点都同意后才提交操作，因为“所有节点都同意”这个原则，在出现节点故障的时候会导致整个集群不可用

            也就是说，“大多数节点都同意”的原则，赋予了 Basic Paxos 容错的能力，让它能够容忍少于一半的节点的故障


        3、本质上而言，提案编号的大小  ->  代表着优先级                   // 按照发起的先后   ->   类似"时间戳"   ->   先来后到

            你可以这么理解，根据提案编号的大小，接受者保证三个承诺

            具体来说：

                1、如果准备请求的提案编号，小于等于接受者已经响应的准备请求的提案编号，那么接受者将承诺不响应这个准备请求

                2、如果接受请求中的提案的提案编号，小于接受者已经响应的准备请求的提案编号，那么接受者将承诺不通过这个提案

                3、如果接受者之前有通过提案，那么接受者将承诺，会在准备请求的响应中，包含已经通过的最大编号的提案信息



2、Raft算法

    1、Raft算法的特点、领导者选举

        1、Raft 算法和兰伯特的 Multi-Paxos 不同之处，主要有 2 点

            1、在Raft中，不是所有节点都能当选领导者，只有日志较完整的节点（也就是日志完整度不比半数节点低的节点），才能当选领导者；

            2、在Raft中，日志必须是连续的



        2、Raft算法通过任期、领导者心跳消息、随机选举超时时间、先来先服务的投票原则、大多数选票原则等

            1、保证了一个任期只有一位领导

            2、也极大地减少了选举失败的情况

            3、本质上，Raft 算法以领导者为中心，选举出的领导者，以“一切以我为准”的方式，达成值的共识，和实现各节点日志的一致



    2、在 Raft 中什么是日志、如何复制日志、以及如何处理不一致日志

        1、在Raft中，副本数据是以日志的形式存在的，其中日志项中的指令表示用户指定的数据

        2、兰伯特的 Multi-Paxos 不要求日志是连续的，但在 Raft 中日志必须是连续的

            而且在Raft中，日志不仅是数据的载体，日志的完整性还影响领导者选举的结果

            也就是说，日志完整性最高的节点才能当选领导者

        3、Raft 是通过以领导者的日志为准，来实现日志的一致的

        -----------------------------------------------------
        值的共识和日志的一致都是由领导者决定的，领导者的唯一性很重要



    3、成员变更的问题和单节点变更的方法

        1、成员变更的问题

            主要在于进行成员变更时

                可能存在新旧配置的 2个“大多数”，导致集群中同时出现两个领导者

            破坏了 Raft 的领导者的唯一性原则，影响了集群的稳定运行。

        2、单节点变更是利用“一次变更一个节点，不会同时存在旧配置和新配置 2 个‘大多数’”的特性，实现成员变更

        3、因为联合共识实现起来复杂，不好实现，所以绝大多数 Raft 算法的实现，采用的都是单节点变更的方法（比如 Etcd、Hashicorp Raft）

            其中，Hashicorp Raft 单节点变更的实现，是由 Raft 算法的作者迭戈·安加罗（Diego Ongaro）设计的，很有参考价值


----------------------------------------------------------------------------------------------------------------
有很多同学把 Raft 当成一致性算法，其实 Raft 不是一致性算法而是  共识算法

    是一个 Multi-Paxos 算法，实现的是   ->   如何就一系列值 达成共识

并且，Raft 能容忍少数节点的故障

    虽然 Raft 算法能实现强一致性，也就是线性一致性（Linearizability），但需要客户端协议的配合

    在实际场景中，我们一般需要根据场景特点，在一致性强度和实现复杂度之间进行权衡


    比如 Consul 实现了三种一致性模型：

        1、default：

            客户端访问领导者节点执行读操作，领导者确认自己处于稳定状态时（在 leader leasing 时间内），返回本地数据给客户端，否则返回错误给客户端

            在这种情况下，客户端是可能读到旧数据的

            比如此时发生了网络分区错误，新领导者已经更新过数据，但因为网络故障，旧领导者未更新数据也未退位，仍处于稳定状态


        2、consistent：

            客户端访问领导者节点执行读操作，领导者在和大多数节点确认自己仍是领导者之后返回本地数据给客户端，否则返回错误给客户端

            在这种情况下，客户端读到的都是最新数据


        3、stale：

            从任意节点读数据，不局限于领导者节点，客户端可能会读到旧数据

        ---------------------------------------------------------------------------------
        一般而言，在实际工程中，Consul 的 consistent 就够用了

            可以不用线性一致性，只要能保证写操作完成后，每次读都能读到最新值就可以了

            比如为了实现 冥等操作：

                我们使用一个编号 (ID) 来唯一标记一个操作，并使用一个状态字段（nil/done）来标记操作是否已经执行

                那么只要我们能保证设置了 ID 对应状态值为 done 后，能立即和一直读到最新状态值就可以了，也就通过防止操作的重复执行，实现了冥等性




总的来说，Raft 算法能很好地处理绝大部分场景的一致性问题

    我推荐你在设计分布式系统时，优先考虑 Raft 算法

    当 Raft 算法不能满足现有场景需求时，再去调研其他共识算法





