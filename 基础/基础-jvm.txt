========================================================================================================================
Java代码是怎么运行的                                                              // .java  ->  .class  ->  机器码
========================================================================================================================
1、高级语言的运行

    1、语法复杂、抽象程度较高       ->      无法直接运行在硬件     ===>   需要先 转换（翻译）

    2、主流思路：

        1、高级语言   --直接编译为-->   机器码                      // C++

        2、设计一个面向Java的虚拟机      ->          JVM            // Java

            ----------------------------------------------------
            人能识别的       JVM能识别的             硬件能识别的

            .java           .class                 机器码
            ----------------------------------------------------


2、Java代码 为何非要在虚拟机中运行

    1、C++和Java比较

        1、为什么不像 C++                  直接      ===>      源码         ->        机器码          ===>  一步 编译到位

        2、非要搞出个JVM，多一步 字节码的 中间转换      ===>      源码   ->  字节码   ->  机器码


    2、JVM优势

        1、跨平台               ->  可移植性                        // JVM  只接收 .class字节码

        2、托管环境
            1、自动内存管理
            2、垃圾回收               // GC
            3、动态检测
                数组越界、动态类型、安全权限

        ------------------------------------------------------------------------------------------
        JVM相当于一个托管                                          ->  使我们编程更方便，专注于业务开发
            所以你不会为了像C那样的内存管理而发愁
            虽然，手动内存管理会更精确一点，跨平台也需要不同平台的虚拟机才可以实现。


3、Java 翻译过程

    1、javac 编译器                         // 前端编译器    ->    因为其发生在 整个编译的前期

        xx.java     ->      xx.class            // java代码         ->    .class字节码

    2、加载到JVM 方法区

        .class字节码     ->    JVM 方法区

    3、解释器   /  JIT 即时编译器

        .class字节码     ->    机器码（硬件平台代码  ->  二进制代码）


4、Java虚拟机
    1、是一个  独立的进程
    2、执行    方法区的代码      // .class -> 机器码      然后执行


5、Java虚拟机 把 内存 分为

    1、两种形式

        堆、栈     ->    存储  运行时数据

    2、栈
        1、Java方法栈
        2、native方法栈

    3、线程共享
        方法区
        堆

    4、线程私有
        Java方法栈      ->      面向 Java 方法
        native方法栈    ->      面向本地方法（用 C++ 写的 native 方法）
        PC寄存器        ->      存放 各个线程执行位置


6、JVM 解释器 + 编译器

    1、功能：
        .class字节码   ->   机器码

    2、分类：

        1、解释执行

            边翻译，边执行                    // 编译单位：  一句        ->    .class字节码  语句(一句)

            优势：
                无需等待编译      // 慢

        2、即时编译

            先翻译，再执行                     // 编译单位： 方法        ->  热点代码

            优势：
                速度更快          // 快
                ---------------------------------------------------------------
                1、提前编译
                2、即时编译 拥有程序的 运行时信息，并且能够根据这个信息 做出相应的优化


    3、编译时机
        1、JVM  在运行程序的时候  才会去做的
        2、是   运行时的开销


    4、编译线程
        解释执行        ->      当前线程
        即时编译        ->      额外的编译线程


7、HotSpot

    解释执行    ->      每次执行的时候，实时翻译（机器码），实时执行      // 同声传译

    即时编译    ->      统计执行的频率，找出 热点代码，提前翻译          // 全文翻译


    混合

        1、解释执行 Java字节码

        2、将其中反复执行的 热点代码，以 方法 为单位  ->  即时编译

            翻译后的机器码   ->   直接运行在 底层硬件 之上


    多种 即时编译器        // C1、C2、Graal

        适配 Client/Server端 不同的程序     ->      在  编译时间  和  执行效率  之间做取舍



========================================================================================================================
Java 编译   从源代码 -> 机器码                                  https://blog.csdn.net/csywwx2008/article/details/100563162
========================================================================================================================
编译的本质

    1、起始                                            // .java

        随便你是什么语言

            Java、kotlin、Scala、Groovy、Clojure、Jython、JRuby、Ceylon、Eta、Haxe...           ->     都可以在JVM上运行


    2、中间态                                           // .class       ->          可有可无

        中间层VM OS  能接受的   字节码

            JVM   ->   只接受 .class字节码             ===>   JVM 不管你是什么语言，只要你能编译成 .class字节码    ->  你就能在 JVM 上运行


    3、目的（最终态）                                    // 机器码

        硬件接受的   机器码       ->     平台强相关      ===>   这也是   增加JVM中间层   的原因之一


------------------------------------------------------------------------------------------------------------------------

1、前置编译器     ->      javac

     Java源代码  编译为  Java字节码文件

2、JIT编译器

    最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将  Java字节码  编译为  本地机器代码


    从字节码到机器码：

        1、解释器

            解释执行字节码

        2、编译器

            JIT 编译器 将字节码 转化为 本地机器代码

            完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用


    编译模式：

        混合模式（Mixed Mode）            // 默认

            解释 + 编译（C1 + C2）
                  --------------
                  指定C1
                      -client
                  指定C2
                      -server

        解释模式（Interpreted Mode）

            -Xint

            所有代码都解释执行

        编译模式（Compiled Mode）

            -Xcomp

            此模式优先采用编译，但是无法编译时也会解释执行



3、AOT编译器

    将  源代码  直接编译为   本地机器码

    在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。


4、比较

    编译速度上       解释执行     >      AOT 编译器     >      JIT 编译器
    编译质量上       JIT 编译器   >     AOT 编译器      >      解释执行


5、配合使用

    在JVM 中，通过这几种不同方式的配合，使得 JVM 的    编译质量 和 运行速度   达到最优的状态。



========================================================================================================================
Java类 加载过程
========================================================================================================================
JVM 将  字节流 转化为 Java类  的过程：

    1、加载

        是指 查找字节流，并且据此 创建类 的过程

        加载需要借助

            类加载器

            在 Java 虚拟机中，类加载器 使用了 双亲委派模型

        双亲委派模型

            接收到加载请求时，会先将 请求转发给 父类加载器

    2、链接

        是指 将创建成的类 合并至 Java虚拟机中，使之能够执行的过程

        链接还分三个阶段

            验证、准备、解析

        其中，解析阶段为非必须的。

    3、初始化

        是为 标记为 常量值的字段 赋值，以及执行 < clinit > 方法的过程

        类的初始化仅会被执行一次，这个特性被用来实现  ->  单例的延迟初始化


========================================================================================================================
JVM 异常处理
========================================================================================================================

JVM的异常处理：

    1、抛出异常

        显式
            应用内      主动抛出   ->    throw

        隐式
            Java虚拟机  抛出      ->     数组索引越界异常     ===>      无法继续执行的异常状态，自动抛出异常


    2、捕获异常


Java异常类：

    Throwable

        1、Error
            执行状态已经 无法恢复，需要中止线程、甚至是中止虚拟机

        2、Exception
            程序可能 需要捕获，并且处理的异常

            RuntimeException
                程序虽然无法继续执行，但是还能抢救一下


异常实例的构造十分昂贵

    JVM 需要生成该异常的栈轨迹（stack trace）

        该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，
        包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。



RuntimeException 和 Error 属于 非检查异常

    其他的 Exception

        皆属于检查异常

        在触发时需要 显式捕获，或者在方法头用 throws 关键字声明



========================================================================================================================
反射
========================================================================================================================

反射：
    允许正在运行的 Java 程序观测，甚至是修改程序的动态行为

应用：
    IDE
    Java 调试器
    Spring 依赖反转（IoC）        ->    根据配置来加载不同的类


反射的实现：

    1、委派实现

        在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。

    2、动态实现

        在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。

        这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。


反射开销大：

    1、变长参数方法导致的 Object 数组

    2、基本类型的 自动装箱、拆箱

    3、还有 最重要的 方法内联



反射API：

    1、获取Class对象

        1、Class.forName

        2、对象的 getClass()

        3、类名 + .class


    2、一旦得到了 Class 对象，便可以正式地 使用反射功能了

        newInstance()
        isInstance(Object)
        Array.newInstance(Class,int)
        getFields()/getConstructors()/getMethods()
            带Declared   的不会返回父类的成员，但是会返回私有成员；
            不带Declared 的则相反

        Constructor/Field/Method.setAccessible(true)
        Constructor.newInstance(Object[])
        Field.get/set(Object)
        Method.invoke(Object, Object[])


========================================================================================================================
Java对象的 内存布局
========================================================================================================================

Java虚拟机 构造对象的方式，所构造对象的大小，以及对象的内存布局

    常见的 new 语句

        会被编译为 new 指令，以及对构造器的调用。

        每个类的构造器皆会直接或者间接调用父类的构造器，并且在同一个实例中初始化相应的字段。


Java虚拟机 引入了 压缩指针 的概念

    将原本的 64 位指针压缩成 32 位

    压缩指针要求 Java虚拟机 堆中对象 的起始地址 要对齐至 8 的倍数

    Java虚拟机 还会对每个类的字段 进行重排列，使得字段也能够 内存对齐


========================================================================================================================
垃圾回收
========================================================================================================================

JVM自动内存管理

    将原本需要由开发人员手动回收的内存，交给垃圾回收器来自动回收


免费的其实是最贵的

    不过既然是自动机制，肯定没法做到像手动回收那般精准高效

    而且还会带来不少与垃圾回收实现相关的问题



引用计数法 与 可达性分析




========================================================================================================================

========================================================================================================================




========================================================================================================================

========================================================================================================================

