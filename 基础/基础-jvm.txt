========================================================================================================================
Java代码是怎么运行的                                                              // .java  ->  .class  ->  机器码
========================================================================================================================
1、高级语言的运行

    1、语法复杂、抽象程度较高       ->      无法直接运行在硬件     ===>   需要先 转换（翻译）

    2、主流思路：

        1、直接转换      ===>    高级语言   --直接编译为-->   机器码                       // C++

        2、中间层        ===>    设计一个面向Java的虚拟机      ->          JVM            // Java

            ----------------------------------------------------
            人能识别的       JVM能识别的             硬件能识别的

            .java           .class                 机器码
            ----------------------------------------------------


2、Java代码 为何非要在虚拟机中运行

    1、C++和Java比较

        1、为什么不像 C++                    直接转换      ===>      源码         ->        机器码          ===>  一步 编译到位

        2、非要搞出个JVM，多一步 字节码的      中间转换      ===>      源码   ->  字节码   ->  机器码


    2、JVM优势

        1、跨平台               ->  可移植性                        // JVM  只接收 .class字节码

        2、托管环境
            1、自动内存管理
            2、垃圾回收               // GC
            3、动态检测
                数组越界、动态类型、安全权限

        ------------------------------------------------------------------------------------------
        JVM相当于一个托管                                          ->  使我们编程更方便，专注于业务开发
            所以你不会为了像C那样的内存管理而发愁
            虽然，手动内存管理会更精确一点，跨平台也需要不同平台的虚拟机才可以实现。


3、Java 翻译过程

    1、javac 编译器                         // 前端编译器    ->    因为其发生在 整个编译的前期

        xx.java     ->      xx.class            // java代码         ->    .class字节码

    2、加载到JVM 方法区

        .class字节码     ->    JVM 方法区

    3、解释器   /  JIT 即时编译器

        .class字节码     ->    机器码（硬件平台代码  ->  二进制代码）


4、Java虚拟机
    1、是一个  独立的进程
    2、执行    方法区的代码      // .class -> 机器码      然后执行


5、Java虚拟机 把 内存 分为

    1、两种形式

        堆、栈     ->    存储  运行时数据

    2、栈                                     // 一个方法  对应  一个栈帧
        1、Java方法栈
        2、native方法栈

    3、线程共享
        方法区
        堆

    4、线程私有
        Java方法栈             ->      面向 Java 方法
        native方法栈           ->      面向本地方法（用 C++ 写的 native 方法）
        PC计数器(寄存器)        ->      存放 线程执行位置                           // Program Counter Register


6、JVM 解释器 + 编译器

    1、功能：
        .class字节码   ->   机器码

    2、分类：

        1、解释执行

            边翻译，边执行                    // 编译单位：  一句        ->    .class字节码  语句(一句)

            优势：
                无需等待编译      // 慢

        2、即时编译

            先翻译，再执行                     // 编译单位： 方法        ->  热点代码

            优势：
                速度更快          // 快
                ---------------------------------------------------------------
                1、提前编译
                2、即时编译 拥有程序的 运行时信息，并且能够根据这个信息 做出相应的优化


    3、编译时机
        1、JVM  在运行程序的时候  才会去做的
        2、是   运行时的开销


    4、编译线程
        解释执行        ->      当前线程
        即时编译        ->      额外的编译线程


7、HotSpot

    解释执行    ->      每次执行的时候，实时翻译（机器码），实时执行      // 同声传译      ->       现场逐句 同步翻译

    即时编译    ->      统计执行的频率，找出 热点代码，提前翻译          // 全文翻译       ->      提前录制 全文磁带


    混合

        1、解释执行 Java字节码

        2、将其中反复执行的 热点代码，以 方法 为单位  ->  即时编译

            翻译后的机器码   ->   直接运行在 底层硬件 之上


    多种 即时编译器        // C1、C2、Graal

        适配 Client/Server端 不同的程序     ->      在  编译时间  和  执行效率  之间做取舍



========================================================================================================================
Java 编译   从源代码 -> 机器码                                  https://blog.csdn.net/csywwx2008/article/details/100563162
========================================================================================================================
编译的本质

    1、起始                                            // .java

        随便你是什么语言

            Java、kotlin、Scala、Groovy、Clojure、Jython、JRuby、Ceylon、Eta、Haxe...           ->     都可以在JVM上运行


    2、中间态                                           // .class       ->          可有可无

        中间层VM OS  能接受的   字节码

            JVM   ->   只接受 .class字节码             ===>   JVM 不管你是什么语言，只要你能编译成 .class字节码    ->  你就能在 JVM 上运行


    3、目的（最终态）                                    // 机器码

        硬件接受的   机器码       ->     平台强相关      ===>   这也是   增加JVM中间层   的原因之一


------------------------------------------------------------------------------------------------------------------------

1、前置编译器     ->      javac

     Java源代码  编译为  Java字节码文件

2、JIT编译器

    最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将  Java字节码  编译为  本地机器代码


    从字节码到机器码：

        1、解释器

            解释执行字节码

        2、编译器

            JIT 编译器 将字节码 转化为 本地机器代码

            完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用


    编译模式：

        混合模式（Mixed Mode）            // 默认

            解释 + 编译（C1 + C2）
                  --------------
                  指定C1
                      -client
                  指定C2
                      -server

        解释模式（Interpreted Mode）

            -Xint

            所有代码都解释执行

        编译模式（Compiled Mode）

            -Xcomp

            此模式优先采用编译，但是无法编译时也会解释执行



3、AOT编译器

    将  源代码  直接编译为   本地机器码

    在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。


4、比较

    编译速度上       解释执行     >      AOT 编译器     >      JIT 编译器
    编译质量上       JIT 编译器   >     AOT 编译器      >      解释执行


5、配合使用

    在JVM 中，通过这几种不同方式的配合，使得 JVM 的    编译质量 和 运行速度   达到最优的状态。



========================================================================================================================
Java类 加载过程
========================================================================================================================
JVM 将  字节流 转化为 Java类  的过程：

    1、加载

        是指 查找字节流，并且据此 创建类 的过程

        加载需要借助

            类加载器

            在 Java 虚拟机中，类加载器 使用了 双亲委派模型

        双亲委派模型

            接收到加载请求时，会先将 请求转发给 父类加载器

    2、链接

        是指 将创建成的类 合并至 Java虚拟机中，使之能够执行的过程

        链接还分三个阶段

            验证、准备、解析

        其中，解析阶段为非必须的。

    3、初始化

        是为 标记为 常量值的字段 赋值，以及执行 < clinit > 方法的过程

        类的初始化仅会被执行一次，这个特性被用来实现  ->  单例的延迟初始化


========================================================================================================================
JVM 异常处理
========================================================================================================================

JVM的异常处理：

    1、抛出异常

        显式
            应用内      主动抛出   ->    throw

        隐式
            Java虚拟机  抛出      ->     数组索引越界异常     ===>      无法继续执行的异常状态，自动抛出异常


    2、捕获异常


Java异常类：

    Throwable

        1、Error
            执行状态已经 无法恢复，需要中止线程、甚至是中止虚拟机

        2、Exception
            程序可能 需要捕获，并且处理的异常

            RuntimeException
                程序虽然无法继续执行，但是还能抢救一下


异常实例的构造十分昂贵

    JVM 需要生成该异常的栈轨迹（stack trace）

        该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，
        包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。



RuntimeException 和 Error 属于 非检查异常

    其他的 Exception

        皆属于检查异常

        在触发时需要 显式捕获，或者在方法头用 throws 关键字声明



========================================================================================================================
反射
========================================================================================================================

反射：
    允许正在运行的 Java 程序观测，甚至是修改程序的动态行为

应用：
    IDE
    Java 调试器
    Spring 依赖反转（IoC）        ->    根据配置来加载不同的类


反射的实现：

    1、委派实现

        在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。

    2、动态实现

        在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。

        这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。


反射开销大：

    1、变长参数方法导致的 Object 数组

    2、基本类型的 自动装箱、拆箱

    3、还有 最重要的 方法内联



反射API：

    1、获取Class对象

        1、Class.forName

        2、对象的 getClass()

        3、类名 + .class


    2、一旦得到了 Class 对象，便可以正式地 使用反射功能了

        newInstance()
        isInstance(Object)
        Array.newInstance(Class,int)
        getFields()/getConstructors()/getMethods()
            带Declared   的不会返回父类的成员，但是会返回私有成员；
            不带Declared 的则相反

        Constructor/Field/Method.setAccessible(true)
        Constructor.newInstance(Object[])
        Field.get/set(Object)
        Method.invoke(Object, Object[])


========================================================================================================================
Java对象  的  内存布局
========================================================================================================================

Java虚拟机 构造对象的方式，所构造对象的大小，以及对象的内存布局

    常见的 new 语句

        会被编译为 new 指令，以及对构造器的调用。

        每个类的构造器皆会直接或者间接调用父类的构造器，并且在同一个实例中初始化相应的字段。


Java虚拟机 引入了 压缩指针 的概念

    将原本的 64 位指针压缩成 32 位

    压缩指针要求 Java虚拟机 堆中对象 的起始地址 要对齐至 8 的倍数

    Java虚拟机 还会对每个类的字段 进行重排列，使得字段也能够 内存对齐




========================================================================================================================
垃圾回收
========================================================================================================================

垃圾回收

    找垃圾（统计、标记）    ->      回收垃圾（清除、压缩、复制）


JVM自动内存管理

    将原本需要由开发人员手动回收的内存，交给垃圾回收器来自动回收


免费的其实是最贵的

    不过既然是自动机制，肯定没法做到像手动回收那般精准高效

    而且还会带来不少与垃圾回收实现相关的问题



垃圾回收
    将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配

垃圾
    死亡对象 所占据的 堆空间



------------------------------------------------------------------------------------------------------------------------
1、寻找垃圾
------------------------------------------------------------------------------------------------------------------------
如何辨别一个对象是存是亡

    1、引用计数法             // 旧时代

        为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。

        计数器为 0，则说明该对象已经死亡，便可以被回收了。


        实现：

            +1
            -1

            截获所有的引用更新操作，并且相应地增减目标对象的引用计数器

        代价：

            需要额外的空间来存储计数器，以及繁琐的更新操作

        重大bug

            无法处理 循环引用对象



    2、可达性分析         // 新 -> 主流

        GC Roots
            由     堆外  --指向-->  堆内     的引用

        GC Roots 包括（但不限于）如下几种：

            1、Java方法栈桢 中的局部变量
            2、已加载类的静态变量
            3、JNI handles
            4、已启动且未停止的 Java 线程

        优点：

            可以解决  循环引用

            举例来说

                即便对象 a 和 b 相互引用，只要从GC Roots出发，无法到达 a或b

                那么可达性分析 便不会 将它们加入 存活对象合集之中



------------------------------------------------------------------------------------------------------------------------
2、垃圾分类(代)                                             堆  ->  新生代 + 老年代               方法区  ->  永久代
------------------------------------------------------------------------------------------------------------------------

1、分代回收 思想                      // 堆     ->      二八法则

    1、二八法则

        大部分Java对象  只存活   一小段时间                      ->     新生代     ==>   新建对象
        小部分Java对象  会存活   很长一段时间                    ->     老年代     ==>   存活时间够长的对象


    2、堆

        新生代                      // Eden区      +       Survivor(from + to)区

            存活时间短   ->  回收频繁    ->  耗时时间短的 GC算法

            Minor GC

        老年代
            存活时间长   ->  回收频次低   ->  耗时时间长点的 GC算法   没问题


    3、方法区

        永久代



2、堆分配 安全性问题            // 同步（加锁）    +    预申请（连续空间）

    why同步：

        堆内存     ->      线程共享           ==>      保证内存分配安全    ->    同步


    事故现象：

        不同步（加锁）  ->  多个对象   分配到同一块 堆空间           // 多辆车 停在 同一个停车位


    解决方案：                           // TLAB（Thread Local Allocation Buffer）

        加锁  +  预申请

            每个线程    向JVM  申请一段连续的内存    ->   作为 线程私有  TLAB

        实现：

            指针      ->      TLAB起始位置  +  TLAB末尾


3、触发GC

    1、Eden区 的空间耗尽       ->      触发一次 Minor GC

    2、




Minor GC                    // 标记 - 复制算法

    算法：

        1、Eden区  +  Survivor(from)区             ===>         存活下来的对象（少量  ->  多数都死亡了）    ->     Survivor(to)区

        2、Survivor（from/to）区  指针互换           ->          每次保证 to区 是空的

        3、GC复制 超过15次 的对象                    ->          老年代

        4、如果单个 Survivor区  已经被占用了 50%      ->          较高复制次数的对象 也会被晋升至   老年代

    优点：
        不用对整个堆  进行垃圾回收

    缺点：
        老年代的对象  可能引用  新生代的对象

            在标记存活对象的时候，我们需要扫描老年代中的对象        ->      全堆扫描


卡表

    1、将整个堆  划分为  一个个大小为512字节的卡

    2、维护一个卡表

        1、用来存储 每张卡 的一个标识位

        2、标识位代表对应的卡  是否可能存有  指向 新生代对象 的引用

        3、如果可能存在，这张卡  ->   脏的

    全堆扫描    ->      寻找脏卡

        1、Minor GC  可以不用扫描 整个老年代，而是 在卡表中 寻找脏卡

        2、脏卡中的对象  加入到   Minor GC 的 GC Roots

        3、当完成所有脏卡的扫描之后，JVM 将 所有脏卡的标识位 清零






------------------------------------------------------------------------------------------------------------------------
3、回收方式                                                              // 垃圾回收器
------------------------------------------------------------------------------------------------------------------------

1、针对 新生代：                       // 都是  标记 - 复制算法

    1、Serial                            单线程

    2、Parallel New                      Serial 的 多线程版本

    3、Parallel Scavenge                 并行  ->  高吞吐

        和 Parallel New 类似，但更加注重 吞吐率

        Parallel Scavenge 不能与 CMS 一起使用





2、针对 老年代：

    1、Serial Old                        标记 - 压缩算法               单线程

    2、Parallel Old                      标记 - 压缩算法               Serial Old 的 多线程版本

    3、CMS                               标记 - 清除算法               并发                        // 已废弃  ->  被 G1 替代

        1、除了少数几个操作需要 stop-the-world 之外，它可以在应用程序 运行过程中 进行垃圾回收

        2、在并发收集失败的情况下，Java 虚拟机 会使用 其他两个压缩型垃圾回收器 进行一次垃圾回收

        3、由于 G1 的出现，CMS 在 Java 9 中已被废弃



3、全新   ->  不分代

    G1（Garbage First）       ->      横跨  新生代和老年代  的垃圾回收器

        1、它已经打乱了前面所说的堆结构，直接将堆 分成 极其多个区域

        2、每个区域都可以充当   Eden区、Survivor区、老年代   中的一个

        3、标记 - 压缩算法

        4、和 CMS 一样，都能够在应用程序  运行过程中  并发地 进行垃圾回收

        5、G1 能够针对 每个细分的区域 来进行垃圾回收

            在选择进行垃圾回收的区域时，它会 优先回收 死亡对象较多 的区域

            这也是 G1 名字的由来



4、ZGC

    Java 11 引入了 ZGC，宣称暂停时间不超过 10ms          // 也有STW


------------------------------------------------------------------------------------------------------------------------
stop-the-world                                       // 即使是 并发GC   ->   也依然存在 STW

    Java 虚拟机中的垃圾回收器采用 可达性分析 来探索所有存活的对象

    它从一系列 GC_Roots 出发，边标记边探索所有被引用的对象。

    为了防止  在标记过程中  ->   堆栈的状态发生改变

        Java虚拟机 采取 安全点机制 来实现 stop-the-world 操作   ->   暂停 其他非垃圾回收线程

------------------------------------------------------------------------------------------------------------------------
回收死亡对象的内存共有三种方式，分别为：

    会造成内存碎片的清除、性能开销较大的压缩、以及 堆使用效率较低的复制



------------------------------------------------------------------------------------------------------------------------
小结：

1、垃圾回收

 核心工作就是 回收垃圾

2、那关键点回来了，什么是垃圾？这个垃圾需要分类嘛？怎么定位垃圾？怎么回收垃圾？回收垃圾的方法都有哪些？他们都有什么优缺点？另外，就是我们为什么要学习垃圾回收？

    站在JVM的视角来看

        垃圾             就是无用对象所占用的堆内存空间

        垃圾分类         不需要垃圾分类，识别垃圾并回收就行

        定位垃圾         是垃圾回收的关键点，无用的对象占用的堆空间即是垃圾，那就需要先定位无用的对象，这里的无用是 不再使用 的意思

                     咋判断呢？

                         两种方法

                             1、计数法

                             2、标记法

                         核心在于能定位出无用的对象，后出现的方法 往往 比早出现的 更好一点

                         这里也一样，标记法能解决计数法，解决不了的循环引用不能回收的问题

                         但是也存在其他的问题，误报和漏报的问题

                             误报浪费点垃圾回收的机会浪费点空间，漏报在多线程并发工作时可能会死JVM的

                             所以，比较严重

                             所以，JVM采用了简单粗暴的stop-the-world的方式来对待

                             所以，老年代的回收有卡顿的现象


        怎么回收垃圾      定位出垃圾，回收就是一个简单的事情了

                     当然也非常关键，把要回收的堆内存空间标记为可继续使用就行，下次有新对象能在此空间创建就行

        回收垃圾的方法

         1、清除法     简单，但易产生碎片，可能总空间够但分配不了的问题
         2、压缩法     能解决清除法的问题，但是复杂且耗性能
         3、复制法     折衷一些，堆使用效率较低的复制，但是空间利用率低












------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------