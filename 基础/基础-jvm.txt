========================================================================================================================
Java代码是怎么运行的                                                              // .java  ->  .class  ->  机器码
========================================================================================================================
1、高级语言的运行

    1、语法复杂、抽象程度较高       ->      无法直接运行在硬件     ===>   需要先 转换（翻译）

    2、主流思路：

        1、直接转换      ===>    高级语言   --直接编译为-->   机器码                       // C++

        2、中间层        ===>    设计一个面向Java的虚拟机      ->          JVM            // Java

            ----------------------------------------------------
            人能识别的       JVM能识别的             硬件能识别的

            .java           .class                 机器码
            ----------------------------------------------------


2、Java代码 为何非要在虚拟机中运行

    1、C++和Java比较

        1、为什么不像 C++                    直接转换      ===>      源码         ->        机器码          ===>  一步 编译到位

        2、非要搞出个JVM，多一步 字节码的      中间转换      ===>      源码   ->  字节码   ->  机器码


    2、JVM优势

        1、跨平台               ->  可移植性                        // JVM  只接收 .class字节码

        2、托管环境
            1、自动内存管理
            2、垃圾回收               // GC
            3、动态检测
                数组越界、动态类型、安全权限

        ------------------------------------------------------------------------------------------
        JVM相当于一个托管                                          ->  使我们编程更方便，专注于业务开发
            所以你不会为了像C那样的内存管理而发愁
            虽然，手动内存管理会更精确一点，跨平台也需要不同平台的虚拟机才可以实现。


3、Java 翻译过程

    1、javac 编译器                         // 前端编译器    ->    因为其发生在 整个编译的前期

        xx.java     ->      xx.class            // java代码         ->    .class字节码

    2、加载到JVM 方法区

        .class字节码     ->    JVM 方法区

    3、解释器   /  JIT 即时编译器

        .class字节码     ->    机器码（硬件平台代码  ->  二进制代码）


4、Java虚拟机
    1、是一个  独立的进程
    2、执行    方法区的代码      // .class -> 机器码      然后执行


5、Java虚拟机 把 内存 分为

    1、两种形式

        堆、栈     ->    存储  运行时数据

    2、栈                                     // 一个方法  对应  一个栈帧
        1、Java方法栈
        2、native方法栈

    3、线程共享
        方法区
        堆

    4、线程私有
        Java方法栈             ->      面向 Java 方法
        native方法栈           ->      面向本地方法（用 C++ 写的 native 方法）
        PC计数器(寄存器)        ->      存放 线程执行位置                           // Program Counter Register


6、JVM 解释器 + 编译器

    1、功能：
        .class字节码   ->   机器码

    2、分类：

        1、解释执行

            边翻译，边执行                    // 编译单位：  一句        ->    .class字节码  语句(一句)

            优势：
                无需等待编译      // 慢

        2、即时编译

            先翻译，再执行                     // 编译单位： 方法        ->  热点代码

            优势：
                速度更快          // 快
                ---------------------------------------------------------------
                1、提前编译
                2、即时编译 拥有程序的 运行时信息，并且能够根据这个信息 做出相应的优化


    3、编译时机
        1、JVM  在运行程序的时候  才会去做的
        2、是   运行时的开销


    4、编译线程
        解释执行        ->      当前线程
        即时编译        ->      额外的编译线程


7、HotSpot

    解释执行    ->      每次执行的时候，实时翻译（机器码），实时执行      // 同声传译      ->       现场逐句 同步翻译

    即时编译    ->      统计执行的频率，找出 热点代码，提前翻译          // 全文翻译       ->      提前录制 全文磁带


    混合

        1、解释执行 Java字节码

        2、将其中反复执行的 热点代码，以 方法 为单位  ->  即时编译

            翻译后的机器码   ->   直接运行在 底层硬件 之上


    多种 即时编译器        // C1、C2、Graal

        适配 Client/Server端 不同的程序     ->      在  编译时间  和  执行效率  之间做取舍



========================================================================================================================
Java 编译   从源代码 -> 机器码                                  https://blog.csdn.net/csywwx2008/article/details/100563162
========================================================================================================================
编译的本质

    1、起始                                            // .java

        随便你是什么语言

            Java、kotlin、Scala、Groovy、Clojure、Jython、JRuby、Ceylon、Eta、Haxe...           ->     都可以在JVM上运行


    2、中间态                                           // .class       ->          可有可无

        中间层VM OS  能接受的   字节码

            JVM   ->   只接受 .class字节码             ===>   JVM 不管你是什么语言，只要你能编译成 .class字节码    ->  你就能在 JVM 上运行


    3、目的（最终态）                                    // 机器码

        硬件接受的   机器码       ->     平台强相关      ===>   这也是   增加JVM中间层   的原因之一


------------------------------------------------------------------------------------------------------------------------

1、前置编译器     ->      javac

     Java源代码  编译为  Java字节码文件

2、JIT编译器

    最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将  Java字节码  编译为  本地机器代码


    从字节码到机器码：

        1、解释器

            解释执行字节码

        2、编译器

            JIT 编译器 将字节码 转化为 本地机器代码

            完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用


    编译模式：

        混合模式（Mixed Mode）            // 默认

            解释 + 编译（C1 + C2）
                  --------------
                  指定C1
                      -client
                  指定C2
                      -server

        解释模式（Interpreted Mode）

            -Xint

            所有代码都解释执行

        编译模式（Compiled Mode）

            -Xcomp

            此模式优先采用编译，但是无法编译时也会解释执行



3、AOT编译器

    将  源代码  直接编译为   本地机器码

    在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。


4、比较

    编译速度上       解释执行     >      AOT 编译器     >      JIT 编译器
    编译质量上       解释执行     <      AOT 编译器     <      JIT 编译器（运行时信息）


5、配合使用

    在JVM 中，通过这几种不同方式的配合，使得 JVM 的    编译质量 和 运行速度   达到最优的状态。



========================================================================================================================
Java类 加载过程
========================================================================================================================
JVM 将  字节流 转化为 Java类  的过程：

    1、加载

        是指 查找字节流，并且据此 创建类 的过程

        加载需要借助

            类加载器
                启动类加载器          ->  加载 <JAVA_HOME>\lib     目录中的所有类库         // 命名识别   e.g. -> rt.jar
                扩展类加载器          ->  加载 <JAVA_HOME>\lib\ext 目录中的所有类库
                应用程序类加载器       ->  ClassLoader.getSystemClassLoader()   ==>  "系统类加载器"   ->  负责加载 用户类路径（classpath）上所指定的类库

                自定义类加载器

                ---------------------------------------------------
                类 - 类加载器

                    任意一个类，都由 加载它的类加载器 和 这个类本身   ->   一同确立其在 JVM中的唯一性    // 每一个类加载器，都有一个独立的类名称空间

                    比较两个类是否“相等”  ->   来源于同一个Class    +   必须由同一个类加载器加载       // equals、isInstance

                ---------------------------------------------------
                类加载过程：
                    加载 -> 验证 -> 准备 -> 解析 -> 初始化

                    加载：
                        获取二进制字节流（.clss）
                        二进制字节流代表的静态结构  -> 转化为 方法区的运行时数据结构
                        创建Class对象   // Class<Foo> foo = Foo.class;

                    验证：
                        确保 Class文件的字节流中 包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全  // 语义、语法、规范

                    准备：
                        为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段

                            普通变量  -> 赋值为：0 / null

                            如果是 常量 -> 直接赋值123    public static final int value = 123;


                    解析：
                        JVM将  常量池内的符号引用 替换为 直接引用  的过程

                    初始化：
                        执行 类构造器<clinit>()方法  的过程    // static变量赋值



            在 Java 虚拟机中，类加载器 使用了 双亲委派模型

        双亲委派模型

            接收到加载请求时，会先将 请求转发给 父类加载器

        ----------------------------------------------------------------------------------------------------------------
        为什么使用双亲委派模型？

            像 java.lang.Object 这些   ==>   存放在 rt.jar 中的类

                无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载   ->   从而使得 不同加载器加载的Object类 都是同一个


            相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话

                如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下   ->   那么系统将会出现 多个不同的Object类

                ==>   Java 类型体系中最基础的行为也就无法保证



    2、链接

        是指 将创建成的类 合并至 Java虚拟机中，使之能够执行的过程

        链接还分三个阶段

            验证、准备、解析

        其中，解析阶段为非必须的。

    3、初始化

        是为 标记为 常量值的字段 赋值，以及执行 < clinit > 方法的过程

        类的初始化仅会被执行一次，这个特性被用来实现  ->  单例的延迟初始化


========================================================================================================================
JVM 异常处理
========================================================================================================================

JVM的异常处理：

    1、抛出异常

        显式
            应用内      主动抛出   ->    throw

        隐式
            Java虚拟机  抛出      ->     数组索引越界异常     ===>      无法继续执行的异常状态，自动抛出异常


    2、捕获异常


Java异常类：

    Throwable

        1、Error
            执行状态已经 无法恢复，需要中止线程、甚至是中止虚拟机

        2、Exception
            程序可能 需要捕获，并且处理的异常

            RuntimeException
                程序虽然无法继续执行，但是还能抢救一下


异常实例的构造十分昂贵

    JVM 需要生成该异常的栈轨迹（stack trace）

        该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，
        包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。



RuntimeException 和 Error 属于 非检查异常

    其他的 Exception

        皆属于   检查异常    ->      在触发时需要 显式捕获，或者在方法头用 throws 关键字声明



========================================================================================================================
反射
========================================================================================================================

反射：
    允许正在运行的Java程序  ->  观测(获取)、甚至是修改  程序的动态行为

应用：
    IDE
    Java 调试器
    Spring 依赖反转（IoC）        ->    根据配置来加载不同的类


反射的实现：

    1、委派实现

        在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。

    2、动态实现

        在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。

        这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。


反射开销大：

    1、Method#invoke 方法会对参数做封装和解封操作          // 基本类型的 自动装箱、拆箱

    2、需要检查方法可见性         // 校验

    3、需要校验参数              // 校验

    4、反射方法难以内联           // 无法利用优化

    5、JIT 无法优化              // 无法利用 编译优化

    --------------------------------
    invoke 方法的参数是一个可变长参数，也就是构建一个 Object 数组存参数，这也同时带来了基本数据类型的装箱操作

    在 invoke 内部会进行运行时权限检查，这也是一个损耗点。

    普通方法调用可能有一系列优化手段，比如方法内联、逃逸分析，而这又是反射调用所不能做的，性能差距再一次被放大。


优化反射调用：

    可以尽量避免反射调用虚方法

    关闭运行时权限检查

    可能需要增大 基本数据类型对应的包装类缓存

    如果调用次数可知，可以关闭 Inflation 机制，以及增加内联缓存记录的类型数目



反射API：

    1、获取Class对象

        1、Class.forName

        2、对象的 getClass()

        3、类名 + .class


    2、一旦得到了 Class 对象，便可以正式地 使用反射功能了

        newInstance()
        isInstance(Object)
        Array.newInstance(Class,int)
        getFields()/getConstructors()/getMethods()
            带Declared   的不会返回父类的成员，但是会返回私有成员；
            不带Declared 的则相反

        Constructor/Field/Method.setAccessible(true)
        Constructor.newInstance(Object[])
        Field.get/set(Object)
        Method.invoke(Object, Object[])


========================================================================================================================
Java对象  的  内存布局
========================================================================================================================

Java虚拟机 构造对象的方式，所构造对象的大小，以及对象的内存布局

    常见的 new 语句

        会被编译为 new 指令，以及对构造器的调用。

        每个类的构造器皆会直接或者间接调用父类的构造器，并且在同一个实例中初始化相应的字段。


Java虚拟机 引入了 压缩指针 的概念

    将原本的 64 位指针压缩成 32 位

    压缩指针要求 Java虚拟机 堆中对象 的起始地址 要对齐至 8 的倍数

    Java虚拟机 还会对每个类的字段 进行重排列，使得字段也能够 内存对齐




========================================================================================================================
垃圾回收
========================================================================================================================

垃圾回收

    找垃圾（统计、标记）    ->      回收垃圾（清除、压缩、复制）


JVM自动内存管理

    将原本需要由开发人员手动回收的内存，交给垃圾回收器来自动回收


免费的其实是最贵的

    不过既然是自动机制，肯定没法做到像手动回收那般精准高效

    而且还会带来不少与垃圾回收实现相关的问题



垃圾回收
    将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配

垃圾
    死亡对象 所占据的 堆空间



------------------------------------------------------------------------------------------------------------------------
1、寻找垃圾
------------------------------------------------------------------------------------------------------------------------
如何辨别一个对象是存是亡

    1、引用计数法             // 旧时代

        为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。

        计数器为 0，则说明该对象已经死亡，便可以被回收了。


        实现：

            +1
            -1

            截获所有的引用更新操作，并且相应地增减目标对象的引用计数器

        代价：

            需要额外的空间来存储计数器，以及繁琐的更新操作

        重大bug

            无法处理 循环引用对象



    2、可达性分析         // 新 -> 主流

        GC Roots
            由     堆外  --指向-->  堆内     的引用

        GC Roots 包括（但不限于）如下几种：

            1、Java方法栈桢 中的局部变量
            2、已加载类的静态变量
            3、JNI handles
            4、已启动且未停止的 Java 线程

        优点：

            可以解决  循环引用

            举例来说

                即便对象 a 和 b 相互引用，只要从GC Roots出发，无法到达 a或b

                那么可达性分析 便不会 将它们加入 存活对象合集之中



------------------------------------------------------------------------------------------------------------------------
2、垃圾分类(代)                                             堆  ->  新生代 + 老年代               方法区  ->  永久代
------------------------------------------------------------------------------------------------------------------------

1、分代回收 思想                      // 堆     ->      二八法则

    1、二八法则

        大部分Java对象  只存活   一小段时间                      ->     新生代     ==>   新建对象
        小部分Java对象  会存活   很长一段时间                    ->     老年代     ==>   存活时间够长的对象


    2、堆

        新生代                      // Eden区      +       Survivor(from + to)区

            存活时间短   ->  回收频繁    ->  耗时时间短的 GC算法

            Minor GC

        老年代
            存活时间长   ->  回收频次低   ->  耗时时间长点的 GC算法   没问题


    3、方法区

        永久代



2、堆分配 安全性问题            // 同步（加锁）    +    预申请（连续空间）

    why同步：

        堆内存     ->      线程共享           ==>      保证内存分配安全    ->    同步


    事故现象：

        不同步（加锁）  ->  多个对象   分配到同一块 堆空间           // 多辆车 停在 同一个停车位


    解决方案：                           // TLAB（Thread Local Allocation Buffer）

        加锁  +  预申请

            每个线程    向JVM  申请一段连续的内存    ->   作为 线程私有  TLAB

        实现：

            指针      ->      TLAB起始位置  +  TLAB末尾


3、触发GC

    1、Eden区 的空间耗尽       ->      触发一次 Minor GC

    2、




Minor GC                    // 标记 - 复制算法

    算法：

        1、Eden区  +  Survivor(from)区             ===>         存活下来的对象（少量  ->  多数都死亡了）    ->     Survivor(to)区

        2、Survivor（from/to）区  指针互换           ->          每次保证 to区 是空的

        3、GC复制 超过15次 的对象                    ->          老年代

        4、如果单个 Survivor区  已经被占用了 50%      ->          较高复制次数的对象 也会被晋升至   老年代

    优点：
        不用对整个堆  进行垃圾回收

    缺点：
        老年代的对象  可能引用  新生代的对象

            在标记存活对象的时候，我们需要扫描老年代中的对象        ->      全堆扫描


卡表

    1、将整个堆  划分为  一个个大小为512字节的卡

    2、维护一个卡表

        1、用来存储 每张卡 的一个标识位

        2、标识位代表对应的卡  是否可能存有  指向 新生代对象 的引用

        3、如果可能存在，这张卡  ->   脏的

    全堆扫描    ->      寻找脏卡

        1、Minor GC  可以不用扫描 整个老年代，而是 在卡表中 寻找脏卡

        2、脏卡中的对象  加入到   Minor GC 的 GC Roots

        3、当完成所有脏卡的扫描之后，JVM 将 所有脏卡的标识位 清零






------------------------------------------------------------------------------------------------------------------------
3、回收方式                                                              // 垃圾回收器
------------------------------------------------------------------------------------------------------------------------

1、针对 新生代：                       // 都是  标记 - 复制算法

    1、Serial                            单线程

    2、Parallel New                      Serial 的 多线程版本

    3、Parallel Scavenge                 并行  ->  高吞吐

        和 Parallel New 类似，但更加注重 吞吐率

        Parallel Scavenge 不能与 CMS 一起使用





2、针对 老年代：

    1、Serial Old                        标记 - 压缩算法               单线程

    2、Parallel Old                      标记 - 压缩算法               Serial Old 的 多线程版本

    3、CMS                               标记 - 清除算法               并发                        // 已废弃  ->  被 G1 替代

        1、除了少数几个操作需要 stop-the-world 之外，它可以在应用程序 运行过程中 进行垃圾回收

        2、在并发收集失败的情况下，Java 虚拟机 会使用 其他两个压缩型垃圾回收器 进行一次垃圾回收

        3、由于 G1 的出现，CMS 在 Java 9 中已被废弃



3、全新   ->  不分代

    G1（Garbage First）       ->      横跨  新生代和老年代  的垃圾回收器

        1、它已经打乱了前面所说的堆结构，直接将堆 分成 极其多个区域

        2、每个区域都可以充当   Eden区、Survivor区、老年代   中的一个

        3、标记 - 压缩算法

        4、和 CMS 一样，都能够在应用程序  运行过程中  并发地 进行垃圾回收

        5、G1 能够针对 每个细分的区域 来进行垃圾回收

            在选择进行垃圾回收的区域时，它会 优先回收 死亡对象较多 的区域

            这也是 G1 名字的由来



4、ZGC

    Java 11 引入了 ZGC，宣称暂停时间不超过 10ms          // 也有STW


------------------------------------------------------------------------------------------------------------------------
stop-the-world                                       // 即使是 并发GC   ->   也依然存在 STW

    Java 虚拟机中的垃圾回收器采用 可达性分析 来探索所有存活的对象

    它从一系列 GC_Roots 出发，边标记边探索所有被引用的对象。

    为了防止  在标记过程中  ->   堆栈的状态发生改变

        Java虚拟机 采取 安全点机制 来实现 stop-the-world 操作   ->   暂停 其他非垃圾回收线程

------------------------------------------------------------------------------------------------------------------------
回收死亡对象的内存共有三种方式，分别为：

    会造成内存碎片的清除、性能开销较大的压缩、以及 堆使用效率较低的复制



------------------------------------------------------------------------------------------------------------------------
小结：

1、垃圾回收

 核心工作就是 回收垃圾

2、那关键点回来了，什么是垃圾？这个垃圾需要分类嘛？怎么定位垃圾？怎么回收垃圾？回收垃圾的方法都有哪些？他们都有什么优缺点？另外，就是我们为什么要学习垃圾回收？

    站在JVM的视角来看

        垃圾             就是无用对象所占用的堆内存空间

        垃圾分类         不需要垃圾分类，识别垃圾并回收就行

        定位垃圾         是垃圾回收的关键点，无用的对象占用的堆空间即是垃圾，那就需要先定位无用的对象，这里的无用是 不再使用 的意思

                     咋判断呢？

                         两种方法

                             1、计数法

                             2、标记法

                         核心在于能定位出无用的对象，后出现的方法 往往 比早出现的 更好一点

                         这里也一样，标记法能解决计数法，解决不了的循环引用不能回收的问题

                         但是也存在其他的问题，误报和漏报的问题

                             误报浪费点垃圾回收的机会浪费点空间，漏报在多线程并发工作时可能会死JVM的

                             所以，比较严重

                             所以，JVM采用了简单粗暴的stop-the-world的方式来对待

                             所以，老年代的回收有卡顿的现象


        怎么回收垃圾      定位出垃圾，回收就是一个简单的事情了

                     当然也非常关键，把要回收的堆内存空间标记为可继续使用就行，下次有新对象能在此空间创建就行

        回收垃圾的方法

         1、清除法     简单，但易产生碎片，可能总空间够但分配不了的问题
         2、压缩法     能解决清除法的问题，但是复杂且耗性能
         3、复制法     折衷一些，堆使用效率较低的复制，但是空间利用率低







========================================================================================================================
Java内存模型
========================================================================================================================

as-if-serial                // 像 串行执行

    首先需要说明一点

        即时编译器（和处理器）   ==>    需要保证  程序能够遵守 as-if-serial 属性

    通俗地说

        就是在单线程情况下   ->   要给程序一个 顺序执行的假象

        即：经过重排序的执行结果   ->   要与顺序执行的结果   ==>   保持一致


    如果两个操作之间存在 数据依赖

        即时编译器（和处理器）  ==>   不能调整它们的顺序   ->   否则将会造成 程序语义的改变



多线程  ->  同步

    在多线程情况下   ->   数据竞争（data race）的情况  是有可能发生的

    而且，Java 语言规范   ->   将其归咎于  应用程序  没有作出恰当的同步操作



happens-before 规则


    1、在同一个线程中


        字节码的先后顺序   也暗含了   happens-before 关系：

            在程序控制流路径中    ->    靠前的字节码   happens-before   靠后的字节码

            --------------------------------------------------------------
            然而，这并不意味着  前者一定在后者  之前执行

            实际上，如果  后者没有观测前者  的运行结果

                即：后者  没有数据依赖于  前者   ->   那么它们可能会被重排序


    2、线程间的 happens-before 关系：

        1、解锁操作  happens-before  之后（这里指时钟顺序先后）对同一把锁的加锁操作

        2、volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作

        3、线程的启动操作【 即 Thread.start() 】 happens-before  该线程的第一个操作

            线程启动之前的  共享变量    ->    对线程内部 可见  // 启动完成之后

        4、线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）

            线程内部的 共享变量        ->    对 线程终止之后  可见

        5、线程对其他线程的中断操作  happens-before  被中断线程所收到的中断事件

            （即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）

        6、构造器中的最后一个操作 happens-before 析构器的第一个操作


    3、传递性

        happens-before 关系还具备 传递性

            X happens-before Y  +  Y happens-before Z     ==>   X  happens-before  Z


    4、 volatile 字段的 happens-before 关系




Java内存模型  的 底层实现

    Java 内存模型

        通过  内存屏障（memory barrier）   ->   禁止重排序（编译优化）


------------------------------------------------------------------------------------------------------------------------
即时编译的 编译优化

    依赖  指令重排        ->      带来 bug


修复 编译优化  带来的bug

    禁止 指令重排         ==>      JMM提出了   happens-before 规范     ->   约束了  编译器的 部分优化行为


    ==>    具体实现： 内存屏障（memory barrier）       ->   读读、读写、写写、写读



------------------------------------------------------------------------------------------------------------------------
锁 可见性                                                        // 锁的 可见性  ==>  强刷缓存  +  锁擦除

    1、强刷缓存      ->      可见性

        在解锁时，Java 虚拟机同样需要  强制刷新缓存   ->   使得   当前线程所修改的内存  对其他线程  可见


    2、锁独占        ->      锁擦除         ->          不强刷缓存

        如果编译器能够（通过逃逸分析）证明    ->   某把锁 仅被同一线程持有   ==>   移除相应的 加锁解锁操作     ->    不强刷缓存


            即时编译 后的  synchronized (new Object()) {}    ==>    等同于 空操作     ->   不会 强制刷新缓存


------------------------------------------------------------------------------------------------------------------------
volatile 可见性

    强制刷新缓存  ->  读取主内存

------------------------------------------------------------------------------------------------------------------------
final 优化

    不变  ->  告诉编译器  使劲优化吧





========================================================================================================================
synchronized 的实现
========================================================================================================================

加锁/释放锁 指令：

    monitorenter 和 monitorexit

抽象的锁算法：

    每个锁对象都拥有

        1、一个锁计数器

            为0    ==>   可获取锁    ->  锁指针 指向当前（获取锁的）线程

            不为0  ==>    当前线程   ->  可重入（计数+1）
                         其他线程   ->  等待


        2、一个指向 持有该锁的线程 的指针



HotSpot中 具体的锁实现：

    无锁      ->      偏向锁     ->      轻量级锁（自适应 - 自旋锁）    ->      重量级锁（互斥锁 - mutex）





========================================================================================================================
Java字节码
========================================================================================================================

各种类型的 Java字节码


    Java方法的栈桢 分为

        操作数栈、局部变量区

        通常来说，程序需要将变量从局部变量区加载至操作数栈中，进行一番运算之后再存储回局部变量区中。


    Java字节码 可以划分为很多种类型

        如：加载常量指令、操作数栈专用指令、局部变量区访问指令、Java相关指令、方法调用指令、数组相关指令、控制流指令、以及 计算相关指令



------------------------------------------------------------------------------------------------------------------------

1、  .java代码   由Java的语言语法组成，由开发人员来编写

2、  .class代码  由Java编译器来编译，Java编译器也是由 对应的开发人员来编写的
     .class代码  由字节码指令来组成，如果人理解Java字节码指令集比较简单，也可以直接编写.class代码

3、  Java对应的机器码 由JVM来编译出来，原料是.class代码
     如果人类理解机器码比较容易，那么可能变成就直接在机器硬件上直接编写机器码了

4、  高级语言的出现是为提高人编写代码的效率

    我们学习 .class字节码指令集、JVM、机器码 等的知识，是为了使我们编写的高级语言代码 能更好的在机器硬件上的执行、效率更高

    从高级语言的代码 到能在机器上运行的机器码，中间经过了好几层的转换

    所以，了解每一层是怎么转换就能更快的定位出高级语言代码的性能瓶颈了，感觉是为了  ==>  在 人的编码效率 和 机器的执行效率  之间找平衡点



------------------------------------------------------------------------------------------------------------------------
JVM基于栈的计算模型的原因，推测可能是为了更简单的实现和更高的性能但是是怎么做到的呢？


    基于栈的计算模型确实是为了实现起来容易一些，但它并不高效，因为没有使用底层体系架构的寄存器。

    在JVM中，只有解释器完整地模拟出该计算模型。

    即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。



------------------------------------------------------------------------------------------------------------------------








========================================================================================================================
方法内联      // 将  当前方法内部的多个方法  合并成一个方法    一起即时编译成机器码     -->     省去方法调用的  各种中间状态  的维护
========================================================================================================================


method_A {

    method_B
    method_C            ===>     method_A()     ===>    即时编译 成一个方法     ===>   省去了内部方法调用的  中间状态维护
    method_D
}


方法内联

    在编译过程中，当遇到方法调用时   ->   将  目标方法的方法体  纳入  编译范围之中   ->   并取代 原方法调用的 优化手段


实现方式：

    即时编译器

        1、既可以在  解析过程中  替换    方法调用 字节码

        2、也可以在  IR图中     替换    方法调用 IR节点

    这两者都需要 将目标方法的参数 以及返回值 映射到当前方法来


方法内联有许多规则

    除了一些  强制内联、以及强制不内联  的规则外

    即时编译器会根据

        方法调用的层数、方法调用指令 所在的程序路径的热度、目标方法的调用次数及大小、以及当前IR图的大小

        来决定方法调用能否被内联


------------------------------------------------------------------------------------------------------------------------
这个和 C++内联函数 类似吧，  目的是   ==>   减少函数调用的开销

最终都是编译器来优化

    C++   通过 inline 声明函数，建议编译器内联编译。

    Java  是 JVM 自动处理，也可通过 VM 参数控制。



------------------------------------------------------------------------------------------------------------------------
内联  ->   是一种编译器的优化手段   ==>   目的就是  ->  让代码执行更快

    把频繁调用的方法，进行内联后，把调用的目标方法直接编译成机器代码，减少目标方法频繁调用的开销


如果不内联

    程序需要保存当前调用者方法的执行位置，同时还要创建用于调用目标方法的栈帧

    目标方法执行结束，还是再恢复调用者方法的执行，开销很大。


------------------------------------------------------------------------------------------------------------------------
内联的实现过程有两种：

    1、在即时编译的过程中，可以根据一定的规则，将目标方法的方法体直接编译为机器码

    2、在 IR图中 替换目标方法调动 IR节点

        Java字节码本身作为一种 IR，不可直接优化

        所以即时编译器会将 字节码 转换成 可优化的IR，IR可以理解为 一种字节码指令在虚拟机中运行的分支流程和数据流程图

        IR图中的每个节点 可以看成是 程序执行的一个或多个指令，把调用目标方法的IR 节点，替换成目标方法的IR 图

        其实就是把俩个方法的IR 图合并，这样可以对合并后的 IR 图进行优化；


------------------------------------------------------------------------------------------------------------------------
无论是哪种内联过程，本质都是  ->  将两个方法合并

    也就是 把目标方法 合并到 调用方法里面

    合并方法之后，还需要将目标方法的参数和返回值，都映射到调用方的方法里面




------------------------------------------------------------------------------------------------------------------------
方法内联    去虚化                             // 多态  =>  编译阶段 无法确定真实方法  ->  运行时 才能确定  =>  引出 去虚化 手段
------------------------------------------------------------------------------------------------------------------------


所谓去虚化

    1、Java 多态  ==>  编译阶段 无法确定真实方法  ->  运行时 才能确定

    2、而 内联发生在 即时编译阶段

    3、只能通过一些方式  尝试提前确定 真实方法   ->   即所谓的 去虚化     ==>   达成 即时编译 方法内联 优化的目的


------------------------------------------------------------------------------------------------------------------------
即时编译器  去虚化 的几种方法


    1、完全去虚化

        通过 类型推导 或 类层次分析   ==>  将  虚方法调用  --转换为-->  直接调用

        它的关键在于   ->   证明 虚方法调用的目标方法 是唯一的


    2、条件去虚化

        通过向代码中增添类型比较，将虚方法调用转换为一个个的类型测试以及对应该类型的直接调用。
        它将借助 Java 虚拟机所收集的类型 Profile。



------------------------------------------------------------------------------------------------------------------------
方法内联就是将调用的目标方法，内联到调用者方法里面，以避免目标方法的重复调用带来的开销

但是在内联时

    如果，目标方法  ->  完全确定   ==>    也就是说，目标方法的调用是唯一的，那么直接内联就可



    但是由于 Java的多态特性  ->  基于接口 而非实现编程等     ==>    导致 目标方法的调用  ->  需要在运行时确定

        也就是 虚方法的调用 在即时编译阶段 无法确定唯一调用的目标方法版本，而  内联 是在 即时编译阶段。


------------------------------------------------------------------------------------------------------------------------
方法调用的两种情形：

    1、在 编译阶段   ->   就可以确定唯一的调用版本

    2、在 运行时     ->   才能将符号引用替换为直接引用

    这就导致  ==>  在 即时编译器 进行内联时，这部分方法  没法确定唯一的调用版本  ->  于是就有 去虚化 手段

                  把虚方法调用通过一定的去虚化手段  ->  替换为直接调用   ->   保证内联后的方法 在实际运行时不会出错

------------------------------------------------------------------------------------------------------------------------
去虚化的手段

    只能 尽量保证      虚方法的调用能直接替换为直接调用，只有准确的替换，才能体现出内联的优势。
    如果 实在确定不了  虚方法调用的准确版本   ->  那么就去优化，也就是不走内联了


    1、基于类型的去虚化：

        通过对象的静态类型、实际类型、一些重载、重写方法的调用，

        即时编译器能通过具体的数据类型，进行识别，可以说一旦识别，就准确无误。

    2、基于层次的去虚化

        完全依赖于jvm类的加载，基于只加载一个类的假设

        适用场景很受限

    3、基于条件的去虚化

        依赖于分层编译时收集的数据

------------------------------------------------------------------------------------------------------------------------
总的来说

    内联带来的 程序运行的性能提升   ->   要远远大于 内联的成本

    方法内联，为的就是  ->  把即时编译的性能发挥到极致，都是为性能考虑的






========================================================================================================================
Java编译器(javac)  的   注解处理器                                // 自定义注解  ->  插件开发    ==>   注解 + 注解Processor
========================================================================================================================


自定义注解

    1、作用在编译期                                    // 定义编译规则、修改/生成源代码    ->  Lombok

        1、自定义  @annotation + 注解Processor

        2、将 注解处理逻辑 实现在 process()

        3、以插件的方式 注册到 Java编译器


    2、作用在运行期                                    // AOP -> Cglib     ==>  依赖Spring提供的  拦截注解 @Around / @Before / @After / ...

                                                                           ->  拦截自定义注解(标签)   ->  做 逻辑处理(标签语义的实现)
        1、通过 反射 获取注解

        2、解析注解，实现注解处理逻辑


------------------------------------------------------------------------------------------------------------------------
注解（annotation）                                                              // 就是一种  标签(标记)

    Java5 引入

    用来为 类、方法、字段、参数 等Java结构  提供额外信息的机制


------------------------------------------------------------------------------------------------------------------------
元注解：

    @Target         放在哪      ==>   限定目标注解 所能标注的Java结构

    @Retention      生命周期    ==>   SOURCE -> CLASS -> RUNTIME         .java -> .class -> 机器码


------------------------------------------------------------------------------------------------------------------------
Java的注解机制 允许开发人员自定义注解

    这种功能需要 由开发人员提供，以插件的形式  接入 Java编译器 中

    这些插件 我们称之为  注解处理器（annotation processor）


------------------------------------------------------------------------------------------------------------------------
javac的 注解处理器

    注解处理器 主要有三个用途：                                              // 关键字  ===>  .java 源代码   ->  非 字节码

        1、定义编译规则，并检查被编译的源文件      // @Override

        2、修改 已有源代码                      // Lombok  ->  修改代码 ，添加 Getter/Setter 方法...            涉及了 javac的 内部API，因此并不推荐

        3、生成 新的源代码                      // 较为常见，是 OpenJDK 工具jcstress，以及 JMH 生成测试代码的方式





========================================================================================================================
逃逸分析                                                        // 也是一种优化手段   ==>   锁消除 、 栈上分配 、标量替换
========================================================================================================================

逃逸分析

    一种  确定指针动态范围 的静态分析

        它可以分析  ->  在程序的哪些地方 可以访问到指针


    在JVM的 即时编译语境下

        逃逸分析  将判断 新建的对象是否逃逸


即时编译器判断对象是否逃逸的依据

    1、对象是否被存入堆中（静态字段或者堆中对象的实例字段）

        一旦对象被存入堆中，其他线程便能获得该对象的引用   ->   即时编译器也因此 无法追踪 所有使用该对象的代码位置

    2、对象是否被传入未知代码中



基于逃逸分析的优化

    即时编译器 可以根据逃逸分析的结果 进行诸如

        锁消除、栈上分配、标量替换   的优化



------------------------------------------------------------------------------------------------------------------------
即时编译器的逃逸分析

    在 JVM的即时编译语境下，逃逸分析将判断 新建的对象是否会逃逸。

    即时编译器判断对象逃逸的依据有两个：

        1、看对象是否被存入堆中

        2、看对象 是否作为方法调用的 调用者或者参数


基于逃逸分析的优化

    即时编译器会根据逃逸分析的结果进行优化

        如：锁消除、标量替换

        后者指的是  ->  将原本连续分配的对象 拆散为一个个单独的字段，分布在栈上或者寄存器中



部分逃逸分析

    是一种附带了 控制流信息的逃逸分析

        它将判断 新建对象真正逃逸的分支
        并且支持 将新建操作推延至逃逸分支





========================================================================================================================
循环优化                                                             // 即时编译 优化  ->  循环
========================================================================================================================

    1、循环无关代码外提

    2、循环展开

        在循环中 重复多次迭代，并且相应地 减少循环次数 的优化方式

        循环体的 步数增加   ==>    64   i++   (循环 64次)    ->     64   i+=2  （循环 32次）


            ------- 循环 64次

            int foo(int[] a) {
              int sum = 0;
              for (int i = 0; i < 64; i++) {
                sum += (i % 2 == 0) ? a[i] : -a[i];
              }
              return sum;
            }


            ------- 循环 32次

            int foo(int[] a) {
              int sum = 0;
              for (int i = 0; i < 64; i += 2) {     // 注意这里的步数是2
                sum += (i % 2 == 0) ? a[i] : -a[i];
                sum += ((i + 1) % 2 == 0) ? a[i + 1] : -a[i + 1];
              }
              return sum;
            }


    3、循环判断外提

        if 语句外提至  循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。

    4、循环剥离

        将循环的前几个迭代或者后几个迭代剥离出循环的优化方式

            一般来说，循环的  前几个迭代或者后几个迭代  都包含特殊处理

            通过将这几个特殊的迭代剥离出去，可以使原本的循环体的规律性更加明显，从而触发进一步的优化。




========================================================================================================================
JNI                                                                         // Java native   == JVM JNI ==>   C/C++
========================================================================================================================

JNI 的缘由：

    我们经常会遇见 Java语言较难表达，甚至是无法表达的 应用场景

        比如：

            1、我们希望使用汇编语言（如 X86_64 的 SIMD 指令）来提升关键代码的性能

            2、我们希望调用 Java 核心类库无法提供的，某个体系架构或者操作系统特有的功能


    即 跨语言调用：

        Java所处层级比较高  ->  无法直接调用 底层架构/系统 的某些功能   ==>   曲线救国  ->  在 Java 代码中调用 C/C++ 代码（牺牲可移植性）

        跨语言的调用，需借助 JVM 的   ->   JNI（Java Native Interface）机制


native方法的调用：

    Java代码  ->  调用 native   ==>   JVM通过JNI  链接Java-C   ->  调用至 对应C函数         // native方法  ->  实现在 C函数


------------------------------------------------------------------------------------------------------------------------
JNI 的运行机制：

    1. Java 中的 native 方法的链接方式主要有两种：

        1、自动链接
            按照 JNI的默认命名规范 命名所要链接的 C函数，并依赖于 JVM 自动查找并链接

        2、主动链接

            在 C 代码中主动链接

                通过 static  ->  registerNatives();


    2. JNI 提供了一系列API 来允许 C代码使用Java语言特性

        1、映射了 Java ⇋ C 的 基本数据类型 和 引用数据类型          int -> jint ...

        2、异常处理


    3. 防止 C代码 中 引用到的Java对象  被 JVM GC

        在C代码中，可以访问传入的引用类型参数，也可以 通过 JNI API 创建新的Java对象

        Java 虚拟机需要一种机制，来告知垃圾回收算法，不要回收这些 C代码中 可能引用到的Java对象

            - JNI 的 局部引用（Local Reference）和 全局引用（Global Reference）
                这两者都可以 阻止垃圾回收器 回收 被引用的 Java对象
                不同的是，局部引用 在 native 方法调用返回之后便会失效。传入参数 以及大部分 JNI API 函数的返回值 都属于 局部引用


            局部引用 ⇋ 全局引用    // 通过 JNI函数 互转  NewGlobalRef / DeleteGlobalRef

                方法返回时，局部引用失效   ==>   可通过  转化为全局引用，保持引用


    4. JNI 的额外性能开销

        1、进入 C函数时，对引用类型参数的句柄化，和调整参数位置（C调用 和 Java调用 传参的方式不一样）

        2、从C函数 返回时，清理线程私有句柄块