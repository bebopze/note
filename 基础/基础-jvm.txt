------------------------------------------------------------------------------------------------------------------------
Java代码是怎么运行的                                                    // .java  ->  .class  ->  机器码
------------------------------------------------------------------------------------------------------------------------
1、高级语言的运行

    1、语法复杂、抽象程度较高       ->      无法直接运行在硬件     ===>   需要先 转换（翻译）

    2、主流思路：

        1、高级语言   --直接编译为-->   机器码                      // C++

        2、设计一个面向Java的虚拟机      ->          JVM            // Java

            ----------------------------------------------------
            人能识别的       JVM能识别的             硬件能识别的

            .java           .class                 机器码
            ----------------------------------------------------


2、Java代码 为何非要在虚拟机中运行

    1、C++和Java比较

        1、为什么不像 C++                  直接      ===>      源码         ->        机器码          ===>  一步 编译到位

        2、非要搞出个JVM，多一步 字节码的 中间转换      ===>      源码   ->  字节码   ->  机器码


    2、JVM优势

        1、跨平台               ->  可移植性                        // JVM  只接收 .class字节码

        2、托管环境
            1、自动内存管理
            2、垃圾回收               // GC
            3、动态检测
                数组越界、动态类型、安全权限

        ------------------------------------------------------------------------------------------
        JVM相当于一个托管                                          ->  使我们编程更方便，专注于业务开发
            所以你不会为了像C那样的内存管理而发愁
            虽然，手动内存管理会更精确一点，跨平台也需要不同平台的虚拟机才可以实现。


3、Java 翻译过程

    1、javac

        xx.java     ->      xx.class            // java代码         ->    .class字节码

    2、加载到JVM 方法区

        .class字节码     ->    JVM 方法区

    3、解释/即时 编译器

        .class字节码     ->    机器码


4、Java虚拟机
    1、是一个  独立的进程
    2、执行    方法区的代码      // .class -> 机器码      然后执行


5、Java虚拟机 把 内存 分为

    1、两种形式

        堆、栈     ->    存储  运行时数据

    2、栈
        1、Java方法栈
        2、native方法栈

    3、线程共享
        方法区
        堆

    4、线程私有
        Java方法栈      ->      面向 Java 方法
        native方法栈    ->      面向本地方法（用 C++ 写的 native 方法）
        PC寄存器        ->      存放 各个线程执行位置


6、JVM 编译器

    1、功能：
        .class字节码   ->   机器码

    2、分类：

        1、解释执行

            边翻译，边执行                    // 编译单位：  一句        ->    .class字节码  语句(一句)

            优势：
                无需等待编译      // 慢

        2、即时编译

            先翻译，再执行                     // 编译单位： 方法        ->  热点代码

            优势：
                速度更快          // 快
                ---------------------------------------------------------------
                1、提前编译
                2、即时编译 拥有程序的 运行时信息，并且能够根据这个信息 做出相应的优化


    3、编译时机
        1、JVM  在运行程序的时候  才会去做的
        2、是   运行时的开销


    4、编译线程
        解释执行        ->      当前线程
        即时编译        ->      额外的编译线程


7、HotSpot

    解释执行    ->      每次执行的时候，实时翻译（机器码），实时执行      // 同声传译

    即时编译    ->      统计执行的频率，找出 热点代码，提前翻译          // 全文翻译


    混合

        1、解释执行 Java字节码

        2、将其中反复执行的 热点代码，以 方法 为单位  ->  即时编译

            翻译后的机器码   ->   直接运行在 底层硬件 之上


    多种 即时编译器        // C1、C2、Graal

        适配 Client/Server端 不同的程序     ->      在  编译时间  和  执行效率  之间做取舍



------------------------------------------------------------------------------------------------------------------------