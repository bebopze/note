------------------------------------------------------------------------------------------------------------------------
Java代码是怎么运行的                                                    // .java  ->  .class  ->  机器码
------------------------------------------------------------------------------------------------------------------------

1、为什么使用JVM

    1、可以轻松实现 Java代码 的 跨平台执行

    2、JVM提供了一个 托管平台

        提供

            内存管理、垃圾回收、编译时动态校验  等功能

    3、使用JVM能够让我们的编程工作更轻松、高效，节省公司成本，提示社会化的整体快发效率

        我们只关注和业务相关的程序逻辑的编写

        其他业务无关，但对于编程同样重要的事情，交给JVM来处理



1、   xx.java    ---javac编译--->    xx.class    ---java虚拟机--加载到--->    方法区

    --------------------------------------------------------------------------------------------------------------------
    xx.java     ->      xx.class        //  javac                          ==>    java代码         ->    .class字节码

    xx.class    ->      机器码           //  Java虚拟机 - 解释/即时 编译器    ==>    .class字节码     ->    机器码

    --------------------------------------------------------------------------------------------------------------------
    1、java代码(xx.java)  首先编译为  .class字节码(xx.class)

    2、然后通过 java虚拟机

        加载到 方法区

            .class字节码     ->    机器码

    3、Java虚拟机

        1、是一个  独立的进程

        2、执行    方法区的代码      // 机器码


2、Java虚拟机 把 内存 分为

    堆、栈

        两种形式    ->    存储  运行时数据

    包括 线程共有 的：

        方法区、堆

    以及 线程私有 的：

        pc计数器、方法栈、naive方法栈


3、Java虚拟机将  字节码 翻译成 机器码，执行的方法有两种：

    1、解释执行

        1、读一句，执行一句            // 单位：  .class字节码  语句(一句)

            逐条  翻译 + 执行

                1、将 一句字节码 翻译成 机器码

                2、并执行


        2、优势：

            无需等待编译              // 运行性能  相对慢

    2、即时编译

        1、读完后，再执行               // 单位：方法

            1、将 一个方法 包含的所有字节码  编译成机器码  后

            2、再执行


        2、优势：

            速度更快                // 即时编译   运行的性能 优于   解释运行




4、这里编译的概念并不是 java代码编译为字节码，而是  字节码编译为机器码

    .class字节码  ->  机器码

        1、是由 java虚拟机  在运行程序的时候  才会去做的

        2、所以是  运行时的开销

    热点代码

        会通过 即时编译 来执行


5、HotSpot内置了多个  即时编译器

    包括：

        C1、C2 和 Graal


6、JVM 将 Boolean类型 看作是 int类型

    true就是1，false就是0


7、Asmtools.jar 下载地址

    https://ci.adoptopenjdk.net/view/Dependencies/job/asmtools/lastSuccessfulBuild/



JVM 内存区域

    1、堆                         ->      线程共有

    2、栈

        pc寄存器                  ->      线程私有

        本地方法栈                 ->      线程xx

        Java方法栈                ->      线程xx

        naive方法栈               ->      线程私有
