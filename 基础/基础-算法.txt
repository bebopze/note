------------------------------------------------------------
基本数据结构与算法           -   算法
------------------------------------------------------------

1、排序                // 应用：快排 [大规模数据  ->  O(nlogn) + 原地 + 非稳定 ]  、 插入 [小规模数据  ->  O(n²) + 原地 + 稳定 ]

    1、时间复杂度


        1、桶排序、计数排序、基数排序                 // O(n)    ->  线性排序          ->  条件苛刻

            1、非基于比较：

                都不涉及元素之间的比较操作


            2、适用场景：                 // 苛刻       ->  应用不多

                1、桶排序 和 计数排序

                    排序思想 是非常相似的

                    都是针对 范围不大的数据

                    将数据划分成 不同的桶 来实现排序


                2、基数排序

                    要求数据可以划分成 高低位，位之间有 递进关系

                    比较两个数，我们只需要 比较高位，高位相同的 再比较低位

                    而且每一位的数据范围不能太大，因为基数排序算法 需要借助桶排序 或者 计数排序 来完成每一个位的排序工作



        2、归并排序、快速排序、堆排序                     // O(nlogn)                ->      大规模数据


            1、分治思想 + 递归实现

                1、核心：

                    分治思想

                2、实现：

                    递归


            2、实现：

                1、归并

                    递推公式  和  merge() 合并函数

                2、快排

                    递推公式  和  partition() 分区函数



            3、分析：                               // 原地（空间）、稳定（交换次数）

                1、归并排序        // 非原地、稳定

                    1、稳定：

                        在任何情况下 时间复杂度都比较稳定 的排序算法     ->  O(nlogn)

                    2、非原地：

                        空间复杂度 较高  ->  O(n)

                            每次都要 借助一个额外的数字 进行merge操作，所以空间复杂度为O(n)

                            如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费就翻倍了

                        -------------------------
                        归并 没有 快排 应用广：

                            快排 -> 原地    ->  空间复杂度 O(1)

                            归并 -> 非原地  ->  空间复杂度 O(n)


                2、快速排序        // 原地、非稳定

                    缺点：

                        快速排序在 最坏情况下的 时间复杂度是 O(n²)

                    优化：

                        合理地选择 pivot  ->  来避免 “复杂度恶化”


                    理想的分区点：

                        被分区点分开 的两个分区中，数据的 数量差不多

                    分区算法：

                        1、三数取中法

                            首、尾、中间，分别取出一个数，然后对比大小，取这3个数的 中间值 作为分区点

                        2、随机法

                            随机选择一个元素

                                不能保证每次 分区点 都选的比较好

                                但从 概率 的角度来看，也不大可能出现 每次分区点都选得很差

                        3、Java中的 分区算法

                            DualPivotQuicksort

                                双分区点的选取

                                    1、计算区间1/7长

                                    2、取区间 中间值作为e3

                                    3、中值e3 左右1/7、2/7处，各取值（e1, e2, e4, e5）

                                    4、将 e1, e2, e3, e4, e5 排序后，按照 大小顺序(小->大) 放回        // 此时 5个位置的e 已按大小顺序换位

                                    5、取分区点：

                                        1、若 5个e值 各不相等，则取 e2, e4 作为双分区点      ->  双分区点    // (-∞,e2]、[e2,e4]、[e4,+∞)

                                        2、有相等，则取 e3 为单分区点                       ->  单分区点    //  (-∞,e3]、[e3,+∞)

                                    6、遍历，分区

                                    7、递归，快排


                3、堆排序：

                    堆排序包含两个过程：

                        1、建堆

                        2、排序

                    过程：

                        我们将下标从 2n​ 到 1 的节点，依次进行从上到下的堆化操作，然后就可以将 数组中的数据 组织成 堆 这种数据结构。

                        接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化
                        重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。



            --------------------------
            分治思想

            Java：

                Arrays.sort     ->      DualPivotQuicksort.sort     // 快排







        3、冒泡排序、插入排序、选择排序            // O(n²)                ->      小规模数据

            应用：

                冒泡排序、选择排序   ->  纯粹 理论层面，实际应用 不多

                插入排序            ->  部分语言的 排序函数 实现           // 原地 + 稳定





    2、分析 一个排序算法的 指标：            // 时间、空间、稳定

        1、执行效率（时间）

            1、最好情况、最坏情况、平均情况时间复杂度

            2、时间复杂度的系数、常数 、低阶

            3、比较次数 和 交换（移动）次数


        2、内存消耗

            空间复杂度

                原地排序（Sorted in place）         // 空间 -> O(1)

                    特指 空间复杂度是 O(1)          // 除了 存储数据本身的空间 不需要额外的辅助存储空间


        3、稳定性

            如果待排序的序列中存在 值相等的元素，经过排序之后，相等元素之间 原有的先后顺序不变

            -----------------------------
            1，2，1       ->      1，1，2

                前后2个1的顺序不变  ->  稳定 排序算法

            ---------------------------------------------------
            订单 多属性 排序：      // 下单时间 + 金额  排序

                稳定排序算法 可以保持 金额相同的 两个对象，在排序之后的 前后顺序不变

                    1、第一次排序之后，所有的订单按照 下单时间 从早到晚有序了

                    2、在第二次排序中，我们用的是 稳定的排序算法

                        所以经过第二次排序之后，相同金额的订单 仍然保持下单时间 从早到晚有序



2、二分查找

    1、核心思想

        有点类似 分治思想

            即每次都通过 跟区间中的 中间元素 对比，将 待查找的区间 缩小为一半

            直到找到 要查找的元素，或者 区间被缩小为 0


    2、适用场景（局限性）            // 有序 + 数组 + 数据规模不能太大（数组 -> 随机访问 -> 连续空间）

        1、数组

            二分查找算法 需要 按照下标随机访问元素

                数组 -> 取中间值 ==> index  -> O(1)

                链表 -> 取中间值 ==> 需遍历 -> O(n)

        2、有序

            如果无序，需要先排序

                频繁的插入和删除操作，要想用二分查找      // 针对这种动态数据集合，无论哪种方法，维护有序的成本都很高

                    要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序

            适用：
                处理静态数据      // 也就是没有频繁的数据插入、删除操作


        3、数据量太大 也不适合二分查找

            依赖数组    ->  随机访问    ->  连续空间

                二分查找的底层需要 依赖数组 这种数据结构，而数组为了 支持随机访问 的特性，要求内存空间连续，对内存的要求比较苛刻

        4、数据量太小 不适合二分查找

            顺序遍历就足够了
            --------------------------------------------------------------------------
            有一个例外：
                如果数据之间的 比较操作 非常耗时  ->  不管数据量大小，都推荐使用 二分查找


    3、惊人的查找速度               // O(logn)

        O(logn)

            O(logn) 这种 对数时间复杂度

            是一种极其高效的时间复杂度，有的时候甚至比 时间复杂度是常量级 O(1) 的算法  还要高效

                -------------------------------------------------
                对数 对应的就是 指数

                    “阿基米德与国王下棋的故事”，感受一下指数的“恐怖”。

                    这也是为什么我们说，指数时间复杂度的算法 在大规模数据面前 是无效的

                -------------------------------------------------
                n^32 ≈ 42亿      ===>    二分查找  ->  最多 32 次

                    因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。

                    比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。

                    也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次

                -------------------------------------------------
                用大O标记法 表示时间复杂度的时候，会省略掉常数、系数和低阶

                    对于常量级时间复杂度的算法来说，O(1) 有可能表示的是 一个非常大的常量值，比如 O(1000)、O(10000)

                    所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高


    4、实现：

        1、递归

        2、非递归     // 手动模拟栈    ->  循环



3、递归

    1、优势：
        高效、简洁的编码技巧

    2、弊端：

        堆栈溢出、重复计算、函数调用耗时多、空间复杂度高



4、哈希算法

    定义：

        哈希算法：
            将 任意长度的二进制值串 映射为 固定长度的二进制值串，这个 映射的规则 就是 哈希算法

        哈希值：
            而通过 原始数据映射之后 得到的 二进制值串  就是  哈希值


    应用场景：

        1、唯一标识

        2、用于校验数据的完整性和正确性

        3、安全加密

        4、散列函数



5、并行算法                          // 多机处理

    并行计算：

        算法的目的就是为了提高代码执行的效率。

        那当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢？

        一种非常简单但又非常好用的优化方法，那就是并行计算。


    时间复杂度 != 性能

        时间复杂度 是衡量 算法执行效率 的一种标准

        但是，时间复杂度 并不能跟 性能 划等号

        在真实的软件开发中，即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率


    借助 并行计算的处理思想 对算法进行改造

        1、并行排序

            分治思想  ->  对数据进行分片，然后并行处理

                1、对 归并排序 并行化处理

                2、对 快速排序 并行化处理


        2、并行查找

        3、并行字符串匹配

        4、并行搜索



    并行计算是一个工程上的实现思路：

        当要处理的数据规模达到一定程度之后，无法通过继续优化算法，来提高执行效率 的时候

        我们就需要在实现的思路上做文章，利用更多的硬件资源，来加快执行的效率



5、分治算法


6、贪心算法




----------------------------------------------
排序算法 的综合比较指标：

    1、时间

        O(n) < O(nlogn) < O(n²)

        实际应用：

            O(nlogn)        ->   快排（原地、非稳定）   >   归并（非原地、稳定）

    2、空间

        最佳：

            O(1) ->  原地排序           // 不需要占用 额外的数据结构（内存空间）  存储比较过程中的中间态

    3、稳定

        相等元素 两两比较     ->     位置不变


        应用场景：

            多条件排序       // 下单时间 + 金额  排序




----------------------------------------------
时间：O(n) < O(nlogn) < O(n²)


    1、桶排序、计数排序、基数排序           // 快，场景严苛           -->  应用价值  有限

        应用：
            不具备 广泛应用价值


    2、归并排序、快速排序                  // 中规中矩，应用广泛      -->  适用  大规模数据

        应用广泛：

            快排 应用较多（原地排序，  空间O(1)        ， 非稳定）

            归并 应用次之（非原地排序，空间O(n)费内存   ，  稳定 ）


    3、冒泡排序、插入排序、选择排序         // 时间复杂度较高          -->  仅适用 小规模数据

        应用：
            插入（小规模数据）



----------------------------------------------
Java中的排序实现

    1、Arrays.sort

        1、基本数据类型：               // 快排

            DualPivotQuicksort
                --------------------------------------------------------------------------------------------------------
                (0,47)

                    插入      // 小规模  ->  O(n²)和O(nlogn)差距不大     ==>     优先选用  ->  原地（省内存） + 稳定（交换次数少）

                [47,286)

                    快排

                [286,+∞)

                    趋近有序   ->   归并            // 同O(nlogn)  ->  待排序数组 越趋近有序  ->  归并排序 效率越高

                    无序       ->   快排


                --------------------------------------------------------------------------------------------------------
                1、算法步骤：                 // 非DualPivotQuicksort的 最终实现，但思路可作为 DualPivotQuicksort实现的理解

                    1、对于很小的数组（长度小于27），会使用 插入排序

                    2、选择 两个点P1,P2 作为轴心，比如我们可以使用 第一个元素和最后一个元素

                    3、P1必须比P2要小，否则将这两个元素交换
                        现在将整个数组分为四部分：
                            第一部分：比P1小的元素
                            第二部分：比P1大但是比P2小的元素
                            第三部分：比P2大的元素
                            第四部分：尚未比较的部分
                        在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后第四部分没有元素

                    4、从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分中的一个

                    5、移动L，K，G指向

                    6、重复4、5步，直到第四部分没有元素

                    7、将P1与第一部分的最后一个元素交换，将P2与第三部分的第一个元素交换

                    8、递归的将一二三部分排序





            快排实现：

                2个 pivot 分区优化       ->      分成3段

                一般的快排 采用1个pivot 来把一个数组划分成两半，然后递归之

                大量经验数据表面，采用2个pivot划分成3份 的算法更高效，这就是 DualPivotQuicksort





        2、引用数据类型：               // 归并     ->  引用类型 存储指针  ->  O(n)空间占用  实际要低的多  -> 这时候  (归并的)稳定性 相对 (快排的)空间   优势就凸显了

            1、MergeSort

                1.7以前版本的 归并排序

                实现：
                    递归

            2、TimSort

                1.7新引入的 归并排序 优化版

                实现：
                    归并 + 快排 + 二分查找



    2、Collections.sort

        Arrays.sort

            1、DualPivotQuicksort

            2、TimSort   /   MergeSort



-------------------------------------------------
基本类型

    数组存储  ->  值          // 快排  ->  原地排序（省内存） 更占优势

引用类型

    数组存储  ->  指针        // 归并  ->  稳定性（交换次数少）更占优势


----------------------------------------------
越趋近有序  ->  归并 效率越高


----------------------------------------------
比较 + 交换

    数组中 插/删  ->  移位补齐  ->  O(n)     ==>     改用“交换”  ->  不用移位  ->  O(1)


----------------------------------------------
哨兵

    解决的是 国家之间的 边界问题

    同理，这里说的哨兵也是解决 “边界问题” 的，不直接参与业务逻辑


    作用：
        利用哨兵 简化编程难度 的一种技巧

    应用：

        插入排序、归并排序、动态规划等


--------------------------------------------------------------------------------------
稳定性 的作用：


    多条件排序       // 金额 + 下单时间

        最先想到的方法是：

            1、先按照 金额 进行排序

            2、再遍历排序之后的数据，对 每个金额相同的小区间，再按照 下单时间 排序


        难实现：

            这种排序思路 理解起来不难，实现 却会很复杂！！！


        最优：

            借助 稳定排序算法：

                1、先按照 下单时间 给订单排序          // 注意是 按照 下单时间，不是金额

                2、排序完成之后，我们用稳定排序算法，按照 订单金额 重新排序

----------------------------------------------
数组的插入操作     ->  交换

    在数组某个位置插入元素，需要搬移数据，非常耗时

    处理技巧：

        交换

        在 O(1) 的时间复杂度内 完成插入操作


----------------------------------------------
归并、快排 分治处理过程对比：

    归并              // 由下到上

        将大数据 等分到 不可拆分后

        从下往上

        也就是 从最小拆分往最大拆分 进行排序合并


    快排              // 由上到下

        每次将选择好的 分区点 与 数组中数据  进行  比较和交换

        交换完后，再如此往复

        选择 下一次分区点，继续如上操作，直到数组有序


----------------------------------------------
快排

    1、缺点：

        1、分区点 选择不当      ->  复杂度退化  ->  O(n²)

        2、递归                ->  堆栈溢出


    2、分区点 优化：

        双分区


    3、递归优化

        1、限制递归深度            // 简单粗暴

            用系统栈  ->  受限于系统栈的内存限制


        2、模拟栈                  // 即：  递归  ->  改写为 循环

            在堆上 模拟实现一个函数调用栈，手动模拟  递归压栈、出栈的过程        ->      摒弃系统栈，就没有了 系统栈大小的限制


    4、实际中的快排：

        1、小数据        ->  插入

        2、中等数据      ->  双分区快排

        3、大数据        ->  无序：双分区快排      、    有序：归并

------------------------------------------------
归并排序

    空间复杂度 应该没那么高，因为实际存储的都是 指针或引用

------------------------------------------------
通用排序函数 实现技巧

    1、数据量不大时，可以采取用 空间换时间 的思路

    2、数据量大时，优化 快排分区点的选择

    3、防止堆栈溢出，可以选择 在堆上手动模拟调用栈 解决

    4、在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n²)级别的插入排序

    5、用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致

------------------------------------------------
小规模数据       ->  插入


    小规模数据 前提下

        O(n²)的算法  并不一定比  O(nlogn)的算法  执行时间长：

            时间复杂度 代表的是 一个增长趋势
            如果画成增长曲线图，你会发现 O(n²) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些

            但是，在大O复杂度表示法中，我们会 省略低阶、系数和常数

                也就是说，O(nlogn) 在没有省略低阶、系数、常数之前，可能是 O(knlogn + c)
                而 k 和 c 可能是一个比较大的数


    对于小数据量的排序，我们选择：

        比较简单、不需要递归 的 插入排序算法


    插入：

        原地 + 稳定

    哨兵：

        少做一次判断

            排序函数是非常常用、非常基础的函数，性能的优化要做到极致


        道理很简单：

            插入排序 遍历整个数组，将  遍历值  放在  前面的有序数组的合适位置

            找合适位置的过程是从后往前的，所以为了防止超界，每次都要判定是否超界，无形中增加了很多没用的比较操作（只有最后一次超界的判定才是有用的）

            为了防止这一情况

            我们先判断 第一个值是否小于val：

                如果是，  则可放心大胆的向前遍历，寻找正确的位置

                如果不是，则第一个位置就是我们要的位置，所有数据向后移位，将val放在第一个就好


--------------------------------------------------------------------------------------
插入排序 比 冒泡排序 更受欢迎

    冒泡排序  每次交换      需要   3 次赋值操作
    插入排序  每次数据移动   只需   1 次赋值操作


        1、冒泡排序中 数据的 交换操作：                 // 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度

            if (a[j] > a[j+1]) {
                                   // 交换   3
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;

                flag = true;
            }

        2、插入排序中 数据的 移动操作：                 // 插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度

            if (a[j] > value) {
                a[j+1] = a[j];     // 移动   1
            } else {
                break;
            }



------------------------------------------------
为什选择 快速排序？

    1、线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序

    2、为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数

    3、同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排

--------------------------------------------------------------------------------------
快速排序 比 堆排序 性能好

    1、堆排序数据访问的方式没有快速排序友好        // CPU缓存

        快速排序  数据是顺序访问    -> 高效利用 CPU缓存

        堆排序    数据是跳着访问    -> 对 CPU缓存 不友好

    2、堆排序 比 快速排序 交换次数多

        对于同样的数据，在排序过程中，堆排序算法的 数据交换次数 要多于 快速排序

--------------------------------------------------------------------------------------
快排 和 归并

    同为 O(nlogn) 的 快排和归并 相比

    归并排序 不是原地排序算法

    所以最优的选择是 快排


--------------------------------------------------------------------------------------
工业级排序：

    1、插入排序      ->      小规模数据

    2、快速排序      ->      大规模数据                       // 基本类型（值   +  原地 -> 省内存）

    3、归并排序      ->      大规模数据   +   趋近有序        // 引用类型（指针 -> 内存影响不大 + 稳定）

    4、堆排序        ->      大规模数据                      // 快排 恶化至 O(n²)时   ->   可用 堆排序[ 稳定 O(nlogn) ]





------------------------------------------------------------------------------------------------------------------------
数据结构与算法：动态图解十大经典排序算法            - https://www.cnblogs.com/guoyaohua/p/8600214.html
                                               - https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

C++ sort源码分析                  - http://feihu.me/blog/2014/sgi-std-sort

C++中的sort分析:简直就是艺术品      - https://www.cnblogs.com/ygh1229/articles/9806398.html





--------------------------------------------------------------------------------------
快速排序 算法的优化：

    1、三数取中（找更好的分区点）
    2、随机法（找更好的分区点）
    3、手动模拟栈（防止递归引起的堆栈溢出）

qsort()：

    归并  +   快排（三数取中法+手动模拟栈）   +  插入（哨兵）












