========================================================================================================================
Java代码是怎么运行的                                                              // .java  ->  .class  ->  机器码
========================================================================================================================
解释执行

    执行时 才翻译成机器指令，  无需保存 -> 不占内存

即时编译

    类似 预编译，编译之后的指令  需要保存在内存中   ->   吃内存

按照二八原则

    混合模式 最恰当
        热点代码 编译之后 放入内存，避免重复编译
        而其他运行次数较少代码则解释执行，避免占用过多内存


------------------------------------------------------------------------------------------------------------------------
1、解释执行是将字节码翻译为机器码，JIT也是将字节码翻译为机器码，为什么JIT就比解释执行要快这么多？

    就单条加法字节码而言

        解释执行器              ->      需要识别字节码，然后将两个操作数从Java方法栈上读取出来并相加，最后将结果存入Java方法栈中

        而 JIT 生成的机器码     ->      就只是一个CPU加法指令


2、如果说 JIT 检测到是热点代码 并且进行优化，那么为什么解释执行不直接就用这种优化去解释字节码？

    因为JIT比较费时

    如果字节码需要JIT后才跑，那么启动性能会很糟糕

------------------------------------------------------------------------------------------------------------------------
文中提到虚拟机 会把部分热点代码编译成机器码
我有个疑问，
    为什么不把java代码全部编译成机器码？
    很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。
    如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益，不是很合适么？



    事实上JVM确实有考虑做 AOT (ahead of time compilation - 提前编译) 这种事情

        AOT（启动前 - 提前编译）

            能够在 线下，将Java字节码编译成机器码

            主要是用来解决：
                启动性能 不好的问题

    对于这种 发布频率不频繁(长时间运行)的程序

        其实选择 线下编译和即时编译 都一样：

            因为至多一两个小时后，该即时编译的 都已经编译完成了

    另外，即时编译器

        因为有程序的 运行时信息   ->   优化效果更好，也就是说峰值性能更好

------------------------------------------------------------------------------------------------------------------------
老师，那个pc寄存器，本地方法栈，以及方法栈，java方法栈这三个组成的就是我们常统称的栈吧，然后也叫栈帧？

    JVM里的栈指的应该是

        Java方法栈  和  本地方法栈

    每个方法调用

        会在 栈 上划出一块    ->    作为   栈帧(stack frame)

        栈

            是由  多个栈帧  构成的     ->   就好比  电影是由一个个帧构成的
------------------------------------------------------------------------------------------------------------------------
Java源代码怎么就经过编译变成了Java字节码？

    其实是这样的，JVM接收字节码

        1、要运行在JVM上         ->   只能选择   转化为       字节码

        2、要是不想在JVM上跑     ->    可以选择   直接转化为   机器码

------------------------------------------------------------------------------------------------------------------------
JVM将内存区域分成 堆和栈，然后又将栈分成pc寄存器、本地方法栈、Java方法栈，有些内存空间是线程可共享的，有些是线程私有的。
    现在也了解不同的内存区块有不同的用处，不过他们是怎么被划分的哪？
    为什么是他们，不能再多几种或少几种了吗？共享的内存区和私有的又是怎么控制的哪？


    具体的划分都是实现细节，你也可以选择全部冗杂在一起。

        但是内存划分后

            性能较高      ->   因为线程私有的  可以不用同步

------------------------------------------------------------------------------------------------------------------------
java语法复杂，抽象度高，直接通过硬件来执行不现实，但是同样作为高级语言为什么C++就可以呢？
这个理由作为引入虚拟机这个中间层的原因不是很充分吧


    这里的直接运行指的是  ->   不经过任何转换(编译)，直接在硬件上跑

    即便是 C++     ->    也不可以直接运行

    ------------------------------------------------------
    C++的策略是：

        直接编译成       目标架构的   机器码

    Java的策略是：

        编译成一个       虚拟架构的   机器码

        这个 虚拟架构 可以有

                物理实现    ->   可以搜 Java processor

                软件实现    ->   也就是我们经常接触到的  JRE


------------------------------------------------------------------------------------------------------------------------
对于性能要求高的web应用，为什么不直接使用即时编译器在启动时全部编译成机器码呢？虽然启动耗时，但是也是可以接受的


    通常，对于长时间运行的程序来说，大部分即时编译   ->   就发生在前几个小时

    再之后的即时编译
        主要是一些 非热点代码，以及 即时编译器中的bug 造成的反复去优化重新编译


------------------------------------------------------------------------------------------------------------------------
什么时候使用C1，什么时候使用C2，他是怎么区分热点方法的呢？

    JVM会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)

    默认的 分层编译：
        达到2000    ->  调C1
        达到15000   ->  调C2

------------------------------------------------------------------------------------------------------------------------
为什么使用JVM

    1、可以轻松实现 Java代码 的 跨平台执行

    2、JVM提供了一个 托管平台

        提供
            内存管理、垃圾回收、编译时动态校验  等功能

    3、轻松、高效、节省成本

        使用JVM能够让我们的编程工作更轻松、高效，节省公司成本，提示社会化的整体快发效率

        我们只关注和业务相关的程序逻辑的编写

        其他业务无关，但对于编程同样重要的事情，交给JVM来处理

------------------------------------------------------------------------------------------------------------------------
JVM 将 Boolean类型 看作是 int类型

    true -> 1      false -> 0

------------------------------------------------------------------------------------------------------------------------
JRE
    Java 虚拟机    +   Java 核心类库

JDK
    JRE           +   一系列开发、诊断工具

------------------------------------------------------------------------------------------------------------------------
HotSpot内置了多个

    即时编译器       ->      C1、C2 和 Graal
    -------------------------------------------
    在 编译时间 和 生成代码的执行效率   之间进行取舍
    -------------------------------------------
    C1
        Client端程序         ->  启动性能

    C2
        Server服务端程序     ->  峰值性能

    -------------------------------------------------
    分层编译：       // Java7

        1、热点方法             ->   首先会被   C1 编译

        2、热点方法中的 热点     ->   会进一步被 C2 编译

------------------------------------------------------------------------------------------------------------------------
偏移            给虚拟机读的机器码               最右列是给人读的代码（字节码）

0x00:             b2 00 02                    getstatic java.lang.System.out
0x03:             12 03                       ldc "Hello, World!"
0x05:             b6 00 04                    invokevirtual java.io.PrintStream.println
0x08:             b1                          return


------------------------------------------------------------------------------------------------------------------------
# Foo.main编译后的  字节码                             // .class 字节码

 0: iconst_2       // 我们用AsmTools更改了这一指令
 1: istore_1
 2: iload_1
 3: ifeq 14        // 第一个if语句，即操作数栈上数值为0时跳转
 6: getstatic java.lang.System.out
 9: ldc "吃了"
11: invokevirtual java.io.PrintStream.println
14: iload_1
15: iconst_1
16: if_icmpne 27   // 第二个if语句，即操作数栈上两个数值不相同时跳转
19: getstatic java.lang.System.out
22: ldc "真吃了"
24: invokevirtual java.io.PrintStream.println
27: return
------------------------------------------------------------------------------------------------------------------------


========================================================================================================================
Java类 加载过程
========================================================================================================================
1、虚拟机必须知道（加载）有这个类，才能创建这个类的数组（容器），但是这个类并没有被使用到（没有达到初始化的条件），所以不会初始化。

2、新建数组的时候并不是要使用这个类（只是定义了放这个类的容器），所以不会被链接

    调用getInstance(false)的时候约等于告诉虚拟机，我要使用这个类了，你把这个类造好（链接），然后把static修饰的字符赋予变量（初始化）。


------------------------------------------------------------------------------------------------------------------------
老师可以讲下ASM、Unsafe和CAS的底层原理吗？这块儿一直是个拦路虎，谢谢！

    ASM         你指的是那个字节码工程包吗？
                是的话那就是一个提供了字节码抽象的工具，允许用Java代码来生成或者更改字节码。
                JDK里也会用到ASM，用来生成一些适配器什么的。我印象中代码覆盖工具JaCoCo也是用ASM来实现的。

    Unsafe      就是一些不被虚拟机控制的内存操作的合集。具体想要了解哪个API？

    CAS         可以理解为原子性的写操作，这个概念来自于底层CPU指令。
                Unsafe提供了一些cas的Java接口，在即时编译器中我们会将对这些接口的调用替换成具体的CPU指令。

------------------------------------------------------------------------------------------------------------------------
其实那个boolean的true虚拟机里面为1，也就是if(true==吃了没)其实可以替换成if(1==2)这样理解吧

    对的！
------------------------------------------------------------------------------------------------------------------------



========================================================================================================================
JVM 异常处理
========================================================================================================================
1、使用异常捕获的代码为什么比较耗费性能？

    因为 构造异常的实例 比较耗性能
        这从代码层面很难理解，不过站在JVM的角度来看就简单了。

    因为JVM在构造异常实例时 需要生成该异常的栈轨迹
        这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。

    虽然具体不清楚JVM的实现细节，但是看描述这件事情也是比较费时费力的。

------------------------------------------------------------------------------------------------------------------------
2、finally是怎么实现无论异常与否都能被执行的？

    这个事情是由 编译器 来实现的

    现在的做法是这样的

        编译器在编译Java代码时，会复制finally代码块的内容，然后分别放在try-catch代码块所有的正常执行路径及异常执行路径的出口中

------------------------------------------------------------------------------------------------------------------------

========================================================================================================================
反射
========================================================================================================================

    1、反射机制是Java语言的一个非常重要的特性

        通过这个特性，我们能够动态的监控、调用、修改类的行为，许多的框架实现就用到了Java语言反射的机制


    2、使用反射挺好的，但它也是不完美的，复杂的操作往往更耗时间和精力

        使用反射也是一样，性能低下是她所被人诟病的一个地方

        那为什么方法的反射如此耗费性能呐？它的性能耗在那里呢？

            方法的反射调用会带来不少性能开销，原因主要有三个：
                变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。


========================================================================================================================
Java对象的 内存布局
========================================================================================================================

1、Java中创建对象的方式

    1、new                           通过调用构造器来初始化实例字段

    2、反射                           通过调用构造器来初始化实例字段

    3、Object.clone                  通过直接复制已有的数据，来初始化新建对象的实例字段

    4、反序列化                       通过直接复制已有的数据，来初始化新建对象的实例字段

    5、Unsafe.allocateInstance       没有初始化对象的实例字段


2、Java对象的空间占用

    1、通过new创建的对象，涵盖了它所有父类中的对象实例的字段

    2、对象头，由标记字段和类型指针构成

    3、标记字段，用于存储Java虚拟机有关该对象的运行数据，比如：哈希码、GC信息、锁信息等

    4、类型指针，用于指向该对象的类

    5、此对象的实例字段对应的内存空间


3、压缩指针

    JVM的内存空间有限且昂贵，所以，能缩减的就缩减

    通过一定的算法，改进压缩类型指针的空间后，仍可以寻址到对象的实例对应的类

    所以，就采用了


4、字段重排

    意思是 JVM 会重新分配 字段的位置

        和我们Java源码中属性声明的位置存在差异

        猜想 Java编译器编译后的字节码，是没有改变源码中字段声明的位置的

    这样做是为了更好的实现内存对齐

        内存对齐本质上会浪费一定的内存空间，不过可以减少内存行的读取次数

        通过一消一涨的比对发现这样对于JVM的性能有一定的提高

    所以，也就使用了这种方式，浪费点空间能提高性能也是值得的




------------------------------------------------------------------------------------------------------------------------
对象头

    每个对象都有一个对象头，对象头包括两部分，标记信息和类型指针。

    标记信息包括哈希值，锁信息，GC信息。类型指针指向这个对象的class。

    两个信息分别占用8个字节，所以每个对象的额外内存为16个字节。很消耗内存。

压缩指针

    为了减少类型指针的内存占用，将64位指针压缩至32位，进而节约内存

        之前64位寻址，寻的是字节

        现在32位寻址，寻的是变量

    再加上内存对齐（补齐为8的倍数）

        可以每次寻变量都以一定的规则寻找，并且一定可以找得到

内存对齐

    内存对齐的另一个好处是

        使得 CPU缓存行 可以更好的实施

        保证每个变量都只出现在一条缓存行中，不会出现跨行缓存。提高程序的执行效率

字段重排序

    其实就是更好的执行内存对齐标准，会调整字段在内存中的分布，达到方便寻址和节省空间的目的


虚共享

    当 两个线程 分别访问 一个对象中的 不同volatile字段

        理论上是不涉及变量共享和同步要求的

    但是如果两个volatile字段处于同一个CPU缓存行中

        对其中一个volatile字段的写操作，会导致整个缓存行的写回和读取操作，进而影响到了另一个volatile变量

        也就是实际上的共享问题

@Contented注解

    该注解就是用来解决 虚共享 问题的

        被该注解标识的变量，会独占一个CPU缓存行

        但也因此浪费了大量的内存空间



========================================================================================================================
垃圾回收
========================================================================================================================
1、JVM的 stop-the-world 机制非常不友好，有哪些解决之道？原理是什么？

    采用 并行GC 可以减少需要STW的时间

    它们会在 即时编译器生成的代码中 加入 写屏障或读屏障


2、压测时出现频繁的gc容易理解，但是有时出现 毛刺 是因为什么呢？

    Y轴应该是时间，那毛刺就是长暂停

    一般 Full GC 就会造成 长暂停


3、full gc有卡顿，对性能很不利，怎么避免呢？

    通过调整新生代大小，使对象在其生命周期内都待在新生代中

    这样一来，Minor GC时就可以收集完这些短命对象了




------------------------------------------------------------------------------------------------------------------------
垃圾回收算法

    1、引用计数法（文中已经介绍，主要的缺点是无法处理循环引用；在每次引用的产生和消除的时候，会伴随着一个加法或者减法的操作，对性能有一定的影响）

    2、标记清除法（从根节点出发开始所有可达的对象，未被标记的就是垃圾对象。主要缺点是产生空间碎片）

    3、复制算法（将原空间分为两块，每次使用其中一块，在垃圾回收时，进行复制，然后转换使用的内存空间。主要的缺点是将系统的内存折半。主要适用于存活对象少，垃圾对象多的情况下）

    4、标记压缩法（从根出发对所有可达对象进行一次标记，然后进行压缩。最后进行清理）

    5、分代算法（每一种垃圾回收算法都有其优缺点。分代算法是根据对象的特点分成几块，新建的对象放入新生代区域，当一个对象经历了几次复制后还存活则放入老年代。老年代因为对象存活率高复制算法不适用，因此采取标记清除或者标记压缩）

    6、分区算法（把堆空间划分为连续的不同小区间。降低了GC产生的影响）




------------------------------------------------------------------------------------------------------------------------
突发奇想：

    如果 GC 将引用计数算法和可达性分析算法结合起来使用会怎样？

    循环引用毕竟是少数，如果先用引用计数算法回收掉大部分对象，再对剩余的小部分对象采用可达性分析算法解决循环引用问题。

    可能比只使用可达性分析算法带来更好的回收效率。


    赞想法！

    不过我认为没有达到更好的回收效率，因为垃圾回收标记的是非垃圾，剩余没有标记的对象是垃圾。用引用计数法清理后，可达性分析仍需遍历所有活着的对象。

    但是可以将引用计数做成minor minor GC，只有当引用计数回收不了垃圾时，再触发可达性分析。感兴趣的话可以深入探索一下业界其他非Java runtime的垃圾回收算法。



------------------------------------------------------------------------------------------------------------------------
老师有几个不明白的地方，误报和漏报不太明白：

    1、假设A引用开始指向A1对象：A------>A1，按老师说的误报就是将引用A指向null：A------>null，那么此时A1对象不是没有引用了，不就可以垃圾回收了么，为什么会错过垃圾回收的机会呢？

    2、漏报，是将A引用指向一个未被访问的对象假设对象为B：A----->B,此时A引用原来指向的对象应该没有引用了吧，为什么会垃圾回收器可能会回收事实上仍被引用的对象呢？


    这里指的是，GC已经标记完成，然后其他线程进行修改的情况(也是并发GC所要解决的问题)。

    当GC标记完成，还未开始回收时，你更新了其中一个引用，使之指向null，那么原来指向的对象本可以被回收的。

    如果指向一个新的对象，这个对象可没有被标记为不能回收，垃圾回收器就直接给回收掉了


------------------------------------------------------------------------------------------------------------------------
很是不明白，我的理解有没有stop the word 是和垃圾回收器有关的，看完之后怎么觉得您的意思是，不管什么垃圾回收器都会出现 stop-the-word

    目前的垃圾回收器多多少少需要stop the world，但都在朝着尽量减少STW时间发展

    完全的并发GC算法是存在的，但是在实现上一般都会在枚举GC roots时进行STW


------------------------------------------------------------------------------------------------------------------------
老师，我心中有一个疑惑。
压缩算法是不是也用到了复制呢？因为我觉得在压缩的过程中，也需要把存活的内存进行转移，而转移也就是复制吧？
麻烦老师给回答一下~

    确实是需要复制数据

    这样起名主要是为了区分复制到同一个区域中(需要复杂的算法保证引用能够正确更新)

    还是复制到另一个区域中(可以复制完后统一更新引用)


------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
垃圾回收
========================================================================================================================


1、二八法则

    适用于许多的领域，对象在JVM 堆内存空间 的生命周期 也同样符合


2、分代回收思想

    为了更好的JVM性能 以及充分利用对象生命周期的二八法则，JVM的作者将JVM的堆内存空间进行了 分代的处理


3、堆内存空间  =  年轻代  +  老年代

    1、年轻代  =  Eden  +  Survivor（from + to）

        年轻代用于分配新生的对象

        Eden
            通常用于存储新创建的对象，对内存空间是共享的，所以，直接在这里面划分空间需要进行同步

        from
            当Eden区的空间耗尽时，JVM便会出发一次Minor GC 来收集新生代的垃圾，会把存活下来的对象放入Survivor区，也就是from区

        注意，from和to是变动的

            to
                指向的Survivor区是空的，用于当发生Minor GC 时，存储Eden和from区中的存活对象

                然后再交换from和to指针，以保证下一次Minor GC 时to指向的Survivor区还是空的。

    2、老年代

        用于存储 存活时间更久 的对象

        如：15次 Minor GC 还存活的对象 就放入老年代中


4、堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式


    1、针对 新生代 的垃圾回收器：

        Serial、Parallel Scavenge、Parallel New       ->      标记 - 复制   的垃圾回收算法


    2、针对 老年代 的垃圾回收器：

        Serial Old 、Parallel Old                     ->      标记 - 压缩

        CMS                                           ->      标记 - 清除


5、TLAB（Thread Local Allocation Buffer）

    用于解决

        多线程竞争 堆内存分配问题

    核心原理是

        堆分配一些 连续的内存空间           +       加锁

6、卡表

    用于解决

        减少老年代的 全堆空间扫描




------------------------------------------------------------------------------------------------------------------------

请问JVM分代收集新生代对象进入老年代，年龄为什么是 15 而不是其他的?

    HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15


------------------------------------------------------------------------------------------------------------------------

写得真好，搞清楚了之前没掌握透彻的概念：
（1）TLAB是为了避免对象分配时对内存的竞争
（2）卡表是为了处理minor gc时老年代对新生代的引用，为了避免整堆扫描而提出了卡表的概念


------------------------------------------------------------------------------------------------------------------------
JVM中堆内存 GC roots 的物理内存是如何对应的，这个可以从哪里看？

    GC roots分布在HotSpot中的每个子系统里

    可以在源码中搜oops_do