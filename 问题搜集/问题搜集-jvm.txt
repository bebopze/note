------------------------------------------------------------------------------------------------------------------------
解释执行

    执行时 才翻译成机器指令，  无需保存 -> 不占内存

即时编译

    类似 预编译，编译之后的指令  需要保存在内存中   ->   吃内存

按照二八原则

    混合模式 最恰当
        热点代码 编译之后 放入内存，避免重复编译
        而其他运行次数较少代码则解释执行，避免占用过多内存


------------------------------------------------------------------------------------------------------------------------
1、解释执行是将字节码翻译为机器码，JIT也是将字节码翻译为机器码，为什么JIT就比解释执行要快这么多？

    就单条加法字节码而言

        解释执行器              ->      需要识别字节码，然后将两个操作数从Java方法栈上读取出来并相加，最后将结果存入Java方法栈中

        而 JIT 生成的机器码     ->      就只是一个CPU加法指令


2、如果说 JIT 检测到是热点代码 并且进行优化，那么为什么解释执行不直接就用这种优化去解释字节码？

    因为JIT比较费时

    如果字节码需要JIT后才跑，那么启动性能会很糟糕

------------------------------------------------------------------------------------------------------------------------
文中提到虚拟机 会把部分热点代码编译成机器码
我有个疑问，
    为什么不把java代码全部编译成机器码？
    很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。
    如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益，不是很合适么？



    事实上JVM确实有考虑做 AOT (ahead of time compilation - 提前编译) 这种事情

        AOT（启动前 - 提前编译）

            能够在 线下，将Java字节码编译成机器码

            主要是用来解决：
                启动性能 不好的问题

    对于这种 发布频率不频繁(长时间运行)的程序

        其实选择 线下编译和即时编译 都一样：

            因为至多一两个小时后，该即时编译的 都已经编译完成了

    另外，即时编译器

        因为有程序的 运行时信息   ->   优化效果更好，也就是说峰值性能更好

------------------------------------------------------------------------------------------------------------------------
老师，那个pc寄存器，本地方法栈，以及方法栈，java方法栈这三个组成的就是我们常统称的栈吧，然后也叫栈帧？

    JVM里的栈指的应该是

        Java方法栈  和  本地方法栈

    每个方法调用

        会在 栈 上划出一块    ->    作为   栈帧(stack frame)

        栈

            是由  多个栈帧  构成的     ->   就好比  电影是由一个个帧构成的
------------------------------------------------------------------------------------------------------------------------
Java源代码怎么就经过编译变成了Java字节码？

    其实是这样的，JVM接收字节码

        1、要运行在JVM上         ->   只能选择   转化为       字节码

        2、要是不想在JVM上跑     ->    可以选择   直接转化为   机器码

------------------------------------------------------------------------------------------------------------------------
JVM将内存区域分成 堆和栈，然后又将栈分成pc寄存器、本地方法栈、Java方法栈，有些内存空间是线程可共享的，有些是线程私有的。
    现在也了解不同的内存区块有不同的用处，不过他们是怎么被划分的哪？
    为什么是他们，不能再多几种或少几种了吗？共享的内存区和私有的又是怎么控制的哪？


    具体的划分都是实现细节，你也可以选择全部冗杂在一起。

        但是内存划分后

            性能较高      ->   因为线程私有的  可以不用同步

------------------------------------------------------------------------------------------------------------------------
java语法复杂，抽象度高，直接通过硬件来执行不现实，但是同样作为高级语言为什么C++就可以呢？
这个理由作为引入虚拟机这个中间层的原因不是很充分吧


    这里的直接运行指的是  ->   不经过任何转换(编译)，直接在硬件上跑

    即便是 C++     ->    也不可以直接运行

    ------------------------------------------------------
    C++的策略是：

        直接编译成       目标架构的   机器码

    Java的策略是：

        编译成一个       虚拟架构的   机器码

        这个 虚拟架构 可以有

                物理实现    ->   可以搜 Java processor

                软件实现    ->   也就是我们经常接触到的  JRE


------------------------------------------------------------------------------------------------------------------------
对于性能要求高的web应用，为什么不直接使用即时编译器在启动时全部编译成机器码呢？虽然启动耗时，但是也是可以接受的


    通常，对于长时间运行的程序来说，大部分即时编译   ->   就发生在前几个小时

    再之后的即时编译
        主要是一些 非热点代码，以及 即时编译器中的bug 造成的反复去优化重新编译


------------------------------------------------------------------------------------------------------------------------
什么时候使用C1，什么时候使用C2，他是怎么区分热点方法的呢？

    JVM会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)

    默认的 分层编译：
        达到2000    ->  调C1
        达到15000   ->  调C2

------------------------------------------------------------------------------------------------------------------------
为什么使用JVM

    1、可以轻松实现 Java代码 的 跨平台执行

    2、JVM提供了一个 托管平台

        提供
            内存管理、垃圾回收、编译时动态校验  等功能

    3、轻松、高效、节省成本

        使用JVM能够让我们的编程工作更轻松、高效，节省公司成本，提示社会化的整体快发效率

        我们只关注和业务相关的程序逻辑的编写

        其他业务无关，但对于编程同样重要的事情，交给JVM来处理

------------------------------------------------------------------------------------------------------------------------
JVM 将 Boolean类型 看作是 int类型

    true -> 1      false -> 0

------------------------------------------------------------------------------------------------------------------------
JRE
    Java 虚拟机    +   Java 核心类库

JDK
    JRE           +   一系列开发、诊断工具

------------------------------------------------------------------------------------------------------------------------
HotSpot内置了多个

    即时编译器       ->      C1、C2 和 Graal
    -------------------------------------------
    在 编译时间 和 生成代码的执行效率   之间进行取舍
    -------------------------------------------
    C1
        Client端程序         ->  启动性能

    C2
        Server服务端程序     ->  峰值性能

    -------------------------------------------------
    分层编译：       // Java7

        1、热点方法             ->   首先会被   C1 编译

        2、热点方法中的 热点     ->   会进一步被 C2 编译

------------------------------------------------------------------------------------------------------------------------
偏移            给虚拟机读的机器码               最右列是给人读的代码

0x00:             b2 00 02                    getstatic java.lang.System.out
0x03:             12 03                       ldc "Hello, World!"
0x05:             b6 00 04                    invokevirtual java.io.PrintStream.println
0x08:             b1                          return


------------------------------------------------------------------------------------------------------------------------



------------------------------------------------------------------------------------------------------------------------



------------------------------------------------------------------------------------------------------------------------








