========================================================================================================================
编译
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
Java代码是怎么运行的                                                              // .java  ->  .class  ->  机器码
------------------------------------------------------------------------------------------------------------------------
解释执行

    执行时 才翻译成机器指令，    无需保存           ->   不占内存

即时编译

    类似 预编译，编译之后的指令  需要保存在内存中    ->   吃内存

按照二八原则

    混合模式 最恰当
        热点代码 编译之后 放入内存，避免重复编译
        而其他运行次数较少代码则解释执行，避免占用过多内存


------------------------------------------------------------------------------------------------------------------------
编译的二八法则

    及时编译的模式    ->    假定程序符合二八定律    ->   即：百分之二十的代码 占用了百分之八十的资源

    不常用的代码      ->   根本无需耗时将其编译成机器码   ->   采用解释执行 完全可以满足要求

    常用的热点代码    ->   可以将其编译成机器码，达到理想的运行效率

------------------------------------------------------------------------------------------------------------------------
Java源代码怎么就经过编译变成了Java字节码？

    其实是这样的，JVM接收字节码

        1、要运行在JVM上         ->   只能选择   转化为       字节码

        2、要是不想在JVM上跑     ->    可以选择   直接转化为   机器码


------------------------------------------------------------------------------------------------------------------------
JVM将内存区域分成 堆和栈，然后又将栈分成pc寄存器、本地方法栈、Java方法栈，有些内存空间是线程可共享的，有些是线程私有的。
    现在也了解不同的内存区块有不同的用处，不过他们是怎么被划分的哪？
    为什么是他们，不能再多几种或少几种了吗？共享的内存区和私有的又是怎么控制的哪？


    具体的划分都是实现细节，你也可以选择全部冗杂在一起。

        但是内存划分后

            性能较高      ->   因为线程私有的  可以不用同步

------------------------------------------------------------------------------------------------------------------------
java语法复杂，抽象度高，直接通过硬件来执行不现实，但是同样作为高级语言为什么C++就可以呢？
这个理由作为引入虚拟机这个中间层的原因不是很充分吧


    这里的直接运行指的是  ->   不经过任何转换(编译)，直接在硬件上跑

    即便是 C++     ->    也不可以直接运行

    ------------------------------------------------------
    C++的策略是：

        直接编译成       目标架构的   机器码

    Java的策略是：

        编译成一个       虚拟架构的   机器码

        这个 虚拟架构 可以有

                物理实现    ->   可以搜 Java processor

                软件实现    ->   也就是我们经常接触到的  JRE


------------------------------------------------------------------------------------------------------------------------
对于性能要求高的web应用，为什么不直接使用即时编译器在启动时全部编译成机器码呢？虽然启动耗时，但是也是可以接受的


    通常，对于长时间运行的程序来说，大部分即时编译   ->   就发生在前几个小时

    再之后的即时编译
        主要是一些 非热点代码，以及 即时编译器中的bug 造成的反复去优化重新编译


------------------------------------------------------------------------------------------------------------------------
什么时候使用C1，什么时候使用C2，他是怎么区分热点方法的呢？

    JVM会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)

    默认的 分层编译：
        达到2000    ->  调C1
        达到15000   ->  调C2

------------------------------------------------------------------------------------------------------------------------
1、解释执行是将字节码翻译为机器码，JIT也是将字节码翻译为机器码，为什么JIT就比解释执行要快这么多？

    就单条加法字节码而言

        解释执行器              ->      需要识别字节码，然后将两个操作数从Java方法栈上读取出来并相加，最后将结果存入Java方法栈中

        而 JIT 生成的机器码     ->      就只是一个CPU加法指令


2、如果说 JIT 检测到是热点代码 并且进行优化，那么为什么解释执行不直接就用这种优化去解释字节码？

    因为JIT比较费时

    如果字节码需要JIT后才跑，那么启动性能会很糟糕            // 可能要半小时、几个小时    有些大型祖传老代码 编译几天、几个月的都有😄

------------------------------------------------------------------------------------------------------------------------
文中提到虚拟机 会把部分热点代码编译成机器码
我有个疑问，
    为什么不把java代码全部编译成机器码？
    很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。
    如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益，不是很合适么？



    事实上JVM确实有考虑做 AOT (ahead of time compilation - 提前编译) 这种事情

        AOT（启动前 - 提前编译）

            能够在 线下，将Java字节码编译成机器码

            主要是用来解决：
                启动性能 不好的问题

    对于这种 发布频率不频繁(长时间运行)的程序

        其实选择 线下编译和即时编译 都一样：

            因为至多一两个小时后，该即时编译的 都已经编译完成了

    另外，即时编译器

        因为有程序的 运行时信息   ->   优化效果更好，也就是说峰值性能更好



------------------------------------------------------------------------------------------------------------------------
为什么使用JVM

    1、可以轻松实现 Java代码 的 跨平台执行

    2、JVM提供了一个 托管平台

        提供
            内存管理、垃圾回收、编译时动态校验  等功能

    3、轻松、高效、节省成本

        使用JVM能够让我们的编程工作更轻松、高效，节省公司成本，提示社会化的整体快发效率

        我们只关注和业务相关的程序逻辑的编写

        其他业务无关，但对于编程同样重要的事情，交给JVM来处理

------------------------------------------------------------------------------------------------------------------------
JVM 将 Boolean类型 看作是 int类型

    true -> 1      false -> 0

------------------------------------------------------------------------------------------------------------------------
JRE
    Java 虚拟机    +   Java 核心类库

JDK
    JRE           +   一系列开发、诊断工具

------------------------------------------------------------------------------------------------------------------------
HotSpot内置了多个

    即时编译器       ->      C1、C2 和 Graal
    -------------------------------------------
    在 编译时间 和 生成代码的执行效率   之间进行取舍
    -------------------------------------------
    C1
        Client端程序         ->  启动性能

    C2
        Server服务端程序     ->  峰值性能

    -------------------------------------------------
    分层编译：       // Java7

        1、热点方法             ->   首先会被   C1 编译

        2、热点方法中的 热点     ->   会进一步被 C2 编译

------------------------------------------------------------------------------------------------------------------------
偏移            给虚拟机读的机器码               最右列是给人读的代码（字节码）

0x00:             b2 00 02                    getstatic java.lang.System.out
0x03:             12 03                       ldc "Hello, World!"
0x05:             b6 00 04                    invokevirtual java.io.PrintStream.println
0x08:             b1                          return


------------------------------------------------------------------------------------------------------------------------
# Foo.main编译后的  字节码                             // .class 字节码

 0: iconst_2       // 我们用AsmTools更改了这一指令
 1: istore_1
 2: iload_1
 3: ifeq 14        // 第一个if语句，即操作数栈上数值为0时跳转
 6: getstatic java.lang.System.out
 9: ldc "吃了"
11: invokevirtual java.io.PrintStream.println
14: iload_1
15: iconst_1
16: if_icmpne 27   // 第二个if语句，即操作数栈上两个数值不相同时跳转
19: getstatic java.lang.System.out
22: ldc "真吃了"
24: invokevirtual java.io.PrintStream.println
27: return
------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
Java内存                                  堆、方法区、栈、PC计数器
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
PC计数器（寄存器）
------------------------------------------------------------------------------------------------------------------------

1、使用PC寄存器存储字节码指令地址有什么用呢?

    JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

2、为什么使用PC寄存器记录当前线程的执行地址呢?

    因为CPU需要不停的切换各个线程,这时候切换回来以后,就得知道接着从哪开始继续执行。可以理解为游标


    注意题目中的是记录当前线程的执行地址，PC寄存器存储的还是即将要执行的指令的地址。



3、PC寄存器为什么会被设定为线程私有？
    多线程在一个特定的时间段内指挥执行其中某一个线程的方法，CPU会不停地做任务切换，这必然会导致经常中断或者恢复（CPU时间片轮换机制，宏观上我们可以打开多个应用程序同时运行，但在微观上单核情况下由于只有一个CPU，一次只能处理程序要求的一部分），如何保证CPU回到不同线程的时候能正确从上次工作点继续工作？最好地办法自然是为每个线程都分配一个PC寄存器，这样一来各线程之间便可以进行独立计算，从而不会出现相互干扰的情况。


------------------------------------------------------------------------------------------------------------------------
老师，那个pc寄存器，本地方法栈，以及方法栈，java方法栈这三个组成的就是我们常统称的栈吧，然后也叫栈帧？

    JVM里的栈指的应该是

        Java方法栈  和  本地方法栈

    每个方法调用

        会在 栈 上划出一块    ->    作为   栈帧(stack frame)                // 一个方法    ->    一个栈帧

    栈

        是由  多个栈帧  构成的     ->   就好比  电影是由一个个帧构成的





========================================================================================================================
Java类 加载过程
========================================================================================================================
1、虚拟机必须知道（加载）有这个类，才能创建这个类的数组（容器），但是这个类 并没有被使用到（没有达到初始化的条件），所以不会初始化。

2、新建数组的时候  并不是要使用这个类（只是定义了放这个类的容器），所以不会被链接

    调用getInstance(false)的时候约等于告诉虚拟机，我要使用这个类了，你把这个类造好（链接），然后把static修饰的字符赋予变量（初始化）。


------------------------------------------------------------------------------------------------------------------------
老师可以讲下ASM、Unsafe和CAS的底层原理吗？这块儿一直是个拦路虎，谢谢！

    ASM         你指的是那个字节码工程包吗？
                是的话那就是一个提供了字节码抽象的工具

                    允许 用Java代码   ->   来生成/更改 字节码

                    JDK里也会用到ASM，用来生成一些适配器什么的。我印象中代码覆盖工具JaCoCo也是用ASM来实现的。


    Unsafe      就是一些 不被虚拟机控制的 内存操作 的合集

                具体想要了解哪个API？


    CAS         可以理解为  原子性的写操作，这个概念来自于 底层CPU指令。

                Unsafe提供了一些cas的Java接口，在即时编译器中，我们会将 对这些接口的调用   替换成   具体的CPU指令

------------------------------------------------------------------------------------------------------------------------
其实那个boolean的true虚拟机里面为1，也就是if(true==吃了没)其实可以替换成if(1==2)这样理解吧

    对的！
------------------------------------------------------------------------------------------------------------------------



========================================================================================================================
JVM 异常处理
========================================================================================================================
1、使用异常捕获的代码为什么比较耗费性能？

    因为 构造异常的实例 比较耗性能
        这从代码层面很难理解，不过站在JVM的角度来看就简单了。

    因为JVM在构造异常实例时 需要生成该异常的栈轨迹
        这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括 栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。

    虽然具体不清楚JVM的实现细节，但是看描述这件事情也是比较费时费力的。

------------------------------------------------------------------------------------------------------------------------
2、finally是怎么实现无论异常与否都能被执行的？

    这个事情是由 编译器 来实现的

    现在的做法是这样的

        编译器在 编译Java代码 时

            1、会复制finally代码块的内容

            2、然后分别放在 try-catch代码块   ->  所有的   正常执行路径 及 异常执行路径   的出口中

------------------------------------------------------------------------------------------------------------------------



========================================================================================================================
反射
========================================================================================================================

    1、反射机制是Java语言的一个非常重要的特性

        通过这个特性，我们能够 动态的监控、调用、修改类的行为，许多的框架实现就用到了Java语言反射的机制


    2、使用反射挺好的，但它也是不完美的，复杂的操作往往更耗时间和精力

        使用反射也是一样，性能低下是她所被人诟病的一个地方

        那为什么方法的反射如此耗费性能呐？它的性能耗在那里呢？

            方法的反射调用会带来不少性能开销，原因主要有三个：

                1、变长参数方法导致的 Object 数组

                2、基本类型的自动装箱、拆箱

                3、还有最重要的方法内联


------------------------------------------------------------------------------------------------------------------------
虚方法
------------------------------------------------------------------------------------------------------------------------

Java虚方法你可以理解为

    java里   所有被Overriding的方法     ->     都是virtual的

        即：所有被子类重写的 父类方法    ==>  虚方法


        // 所有重写的方法     ->     都是Override的


在JVM字节码执行引擎中，方法调用 会使用 invokevirtual 字节码指令 来调用所有的虚方法



虚方法出现在 Java的多态特性 中

    父类与子类之间的多态性，对父类的函数进行重新定义。

    如果在子类中定义某方法与其父类有 相同的名称和参数，我们说该方法被重写 (Overriding)。

    在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。

    但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。

    方法重写又称方法覆盖。


当设计类时，被重写的方法的行为怎样影响多态性

    方法的重写使得子类能够重写父类的方法。

    当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。





========================================================================================================================
Java对象   的   内存布局
========================================================================================================================

1、Java中创建对象的方式

    1、new                           通过调用构造器，来初始化实例字段

    2、反射                           通过调用构造器，来初始化实例字段

    3、Object.clone                  通过直接复制已有的数据，来初始化新建对象的实例字段

    4、反序列化                       通过直接复制已有的数据，来初始化新建对象的实例字段

    5、Unsafe.allocateInstance       没有初始化对象的实例字段


2、Java对象的空间占用

    1、通过new创建的对象，涵盖了它所有父类中的对象实例的字段

    2、对象头，由标记字段和类型指针构成

        1、标记字段   ->   用于存储Java虚拟机有关该对象的运行数据     ->      比如：哈希码、GC信息、锁信息等

        2、类型指针   ->   用于指向该对象的类

    3、此对象的实例字段对应的内存空间


3、压缩指针                                                      // 内存对齐

    JVM的内存空间有限且昂贵，所以，能缩减的就缩减

    通过一定的算法改进，压缩类型指针的空间后，仍可以寻址到对象的实例对应的类

    所以，就采用了

    ----------------------------------------------------------------------------------------------
    内存对齐

        不仅存在于对象与对象之间，也存在于对象中的字段之间。

            比如说，Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8 的倍数。

        字段内存对齐的其中一个原因

            是让字段只出现在同一 CPU 的缓存行中。

            如果字段不是对齐的，那么就有可能出现跨缓存行的字段。

            也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。

            这两种情况对程序的执行效率而言都是不利的。


4、字段重排

    意思是 JVM 会重新分配 字段的位置

        机器码  ->  和我们 Java源码中属性声明的位置 存在差异

        // 猜想  ->  Java编译器编译后的 .class字节码  ->  是没有改变源码中字段声明的位置的


    这样做是为了  ->  更好的实现 内存对齐

        内存对齐本质上会浪费一定的内存空间，不过可以 减少 内存行的读取次数

        通过一消一涨的比对  ->  发现这样对于JVM的性能有一定的提高

    所以，也就使用了这种方式，浪费点空间能提高性能也是值得的




------------------------------------------------------------------------------------------------------------------------
对象头

    每个对象都有一个对象头，对象头包括两部分：

        标记信息    ->  包括：哈希值、锁信息、GC信息

        类型指针    ->  指向这个对象的Class

    两个信息分别占用8个字节，所以每个对象的额外内存为16个字节。很消耗内存。

压缩指针

    为了减少类型指针的内存占用，将64位指针压缩至32位，进而节约内存

        之前64位寻址，寻的是字节

        现在32位寻址，寻的是变量

    再加上内存对齐（补齐为8的倍数）

        可以每次寻变量都以一定的规则寻找，并且一定可以找得到

内存对齐

    内存对齐的另一个好处是

        使得 CPU缓存行 可以更好的实施

        保证每个变量都只出现在一条缓存行中，不会出现跨行缓存。提高程序的执行效率

字段重排序

    其实就是更好的执行内存对齐标准，会调整字段在内存中的分布，达到方便寻址和节省空间的目的


虚共享

    当 两个线程 分别访问 一个对象中的 不同volatile字段

        理论上是不涉及变量共享和同步要求的

    但是如果   两个volatile字段   ->   处于同一个CPU缓存行中

        对  其中一个volatile字段  的写操作    ->    会导致整个缓存行的写回和读取操作     ==>     进而影响到了  另一个volatile变量

        也就是实际上的 共享问题

@Contended 注解

    该注解就是用来解决 虚共享 问题的

        被该注解标识的变量    ->   会独占一个CPU缓存行

        但也因此浪费了大量的内存空间



========================================================================================================================
垃圾回收
========================================================================================================================
1、JVM的 stop-the-world 机制非常不友好，有哪些解决之道？原理是什么？

    采用 并行GC 可以减少需要STW的时间

    它们会在 即时编译器生成的代码中 加入 写屏障或读屏障


2、压测时出现频繁的gc容易理解，但是有时出现 毛刺 是因为什么呢？

    Y轴应该是时间，那毛刺就是长暂停

    一般 Full GC 就会造成 长暂停


3、full gc有卡顿，对性能很不利，怎么避免呢？

    通过调整新生代大小，使对象在其生命周期内都待在新生代中

    这样一来，Minor GC时就可以收集完这些短命对象了




------------------------------------------------------------------------------------------------------------------------
垃圾回收算法


    --------------------------------------------------------
    找垃圾：

        1、引用计数法（文中已经介绍，主要的缺点是无法处理循环引用；在每次引用的产生和消除的时候，会伴随着一个加法或者减法的操作，对性能有一定的影响）

        2、可达性分析（遍历GC_Roots对象引用链，不在引用链上 的就是垃圾）

    --------------------------------------------------------
    回收垃圾：

        1、标记清除法（从根节点出发开始所有可达的对象，未被标记的就是垃圾对象。主要缺点是产生空间碎片）

        2、复制算法（将原空间分为两块，每次使用其中一块，在垃圾回收时，进行复制，然后转换使用的内存空间。主要的缺点是将系统的内存折半。主要适用于存活对象少，垃圾对象多的情况下）

        3、标记压缩法（从根出发对所有可达对象进行一次标记，然后进行压缩。最后进行清理）

    --------------------------------------------------------
    分代回收：

        1、分代回收（每一种垃圾回收算法都有其优缺点。分代算法是根据对象的特点分成几块，新建的对象放入新生代区域，当一个对象经历了几次复制后还存活则放入老年代。老年代因为对象存活率高复制算法不适用，因此采取标记清除或者标记压缩）


------------------------------------------------------------------------------------------------------------------------
突发奇想：

    如果 GC 将引用计数算法和可达性分析算法结合起来使用会怎样？

        循环引用毕竟是少数，如果先用引用计数算法回收掉大部分对象，再对剩余的小部分对象采用可达性分析算法解决循环引用问题。

        可能比只使用可达性分析算法带来更好的回收效率。


    赞想法！

        不过我认为没有达到更好的回收效率
            因为垃圾回收标记的是非垃圾，剩余没有标记的对象是垃圾。
            用引用计数法清理后，可达性分析仍需遍历所有活着的对象。

        但是可以将引用计数做成 Minor GC，只有当引用计数回收不了垃圾时，再触发可达性分析。
            感兴趣的话可以深入探索一下业界其他非Java runtime的垃圾回收算法



------------------------------------------------------------------------------------------------------------------------
老师有几个不明白的地方，误报和漏报不太明白：

    1、假设A引用开始指向A1对象：A------>A1，按老师说的误报就是将引用A指向null：A------>null，那么此时A1对象不是没有引用了，不就可以垃圾回收了么，为什么会错过垃圾回收的机会呢？

    2、漏报，是将A引用指向一个未被访问的对象假设对象为B：A----->B,此时A引用原来指向的对象应该没有引用了吧，为什么会垃圾回收器可能会回收事实上仍被引用的对象呢？


    这里指的是，GC已经标记完成，然后其他线程进行修改的情况(也是 并发GC 所要解决的问题)。


        当GC标记完成，还未开始回收时             // 并发GC 中间态bug      ->      解决：实际也是靠 stop-the-world

            漏报：
                你更新了其中一个引用，使之指向null，那么原来指向的对象本可以被回收的。

            误报：
                如果指向一个新的对象，这个对象可没有被标记为不能回收，垃圾回收器就直接给回收掉了


------------------------------------------------------------------------------------------------------------------------
很是不明白，我的理解有没有 stop-the-word 是和垃圾回收器有关的，看完之后怎么觉得您的意思是，不管什么垃圾回收器都会出现 stop-the-word


    目前的 垃圾回收器（包括并发GC -> CMS）    ->   多多少少 都需要stop-the-world     ->    但都在朝着  尽量减少STW时间  发展

    完全的并发GC算法是存在的，但是在实现上    ->    一般都会在 枚举GC_Roots 时进行STW


------------------------------------------------------------------------------------------------------------------------
老师，我心中有一个疑惑。
压缩算法是不是也用到了复制呢？因为我觉得在压缩的过程中，也需要把存活的内存进行转移，而转移也就是复制吧？
麻烦老师给回答一下


    确实是需要复制数据

    这样起名主要是为了区分

        复制到     同一个区域中（需要复杂的算法保证引用能够正确更新）

        还是复制到  另一个区域中（可以复制完后统一更新引用）


------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
垃圾回收
========================================================================================================================


1、二八法则

    适用于许多的领域，对象在JVM 堆内存空间 的生命周期 也同样符合


2、分代回收思想

    为了更好的JVM性能 以及充分利用对象生命周期的二八法则，JVM的作者将JVM的堆内存空间进行了 分代的处理


3、堆内存空间  =  年轻代  +  老年代

    1、年轻代  =  Eden  +  Survivor（from + to）

        年轻代用于分配新生的对象

        Eden
            通常用于存储新创建的对象，对内存空间是共享的，所以，直接在这里面划分空间需要进行同步

        from
            当Eden区的空间耗尽时，JVM便会出发一次Minor GC 来收集新生代的垃圾，会把存活下来的对象放入Survivor区，也就是from区

        注意，from和to是变动的

            to
                指向的Survivor区是空的，用于当发生Minor GC 时，存储Eden和from区中的存活对象

                然后再交换from和to指针，以保证下一次Minor GC 时to指向的Survivor区还是空的。

    2、老年代

        用于存储 存活时间更久 的对象

        如：15次 Minor GC 还存活的对象 就放入老年代中


4、堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式


    1、针对 新生代 的垃圾回收器：

        Serial、Parallel Scavenge、Parallel New       ->      标记 - 复制   的垃圾回收算法


    2、针对 老年代 的垃圾回收器：

        Serial Old 、Parallel Old                     ->      标记 - 压缩

        CMS                                           ->      标记 - 清除


5、TLAB（Thread Local Allocation Buffer）

    用于解决

        多线程竞争 堆内存分配问题

    核心原理是

        堆分配一些 连续的内存空间           +       加锁

6、卡表

    用于解决

        减少老年代的 全堆空间扫描





------------------------------------------------------------------------------------------------------------------------
写得真好，搞清楚了之前没掌握透彻的概念：

    1、TLAB是为了避免对象分配时对内存的竞争

    2、卡表是为了处理 minor gc 时老年代对新生代的引用，为了避免整堆扫描而提出了卡表的概念

------------------------------------------------------------------------------------------------------------------------
通过 GC_roots 探索存活对象的时候，有的对象在新生代，有的对象在老年代。
如果当前对象处在老年代而且在赃卡中，需要继续深度遍历对象。若不在赃卡中，就没必要进一步深度遍历下去了。不知道我的理解对不？

    对的
    卡表就是为了 避免探索整个老年代，而只将 脏表中的对象 作为 GC_Roots


------------------------------------------------------------------------------------------------------------------------
如果 Eden区 和 from指向的Survivor区存活对象 大于 to指向的Survivor区 的大小，那么JVM会如何处理？

    会按 对象年龄 晋升最老的那些至老年代

    极端情况，假设 Survivor 区大小为0，那就是直接把 Eden区的存活对象 晋升过去了

------------------------------------------------------------------------------------------------------------------------
看某些资料介绍说 TLAB 是将对象创建在栈内存上，并且与逃逸分析一起用
这样在释放栈内存时就直接将这部分内存一起释放了，降低了gc成本。您讲解的说 TLAB 是提前在堆内存中分配空间，这样没有降低gc成本呀？

    HotSpot不支持在栈上新建对象。

    C2里的逃逸分析是静态分析，和TLAB没什么关系。它和标量替换一起使用，能够完全不分配对象，仅在寄存器中维护这个对象的字段。

------------------------------------------------------------------------------------------------------------------------
新生代回收的时候 会把 老年代的所有对象 当做 GC roots 吗？

    原本是的
    但使用了脏卡技术之后，JVM只需要把  脏卡中的对象  当成 GC roots

------------------------------------------------------------------------------------------------------------------------
多线程访问共享变量会存在线程安全问题，那么方法内部通过new的局部变量是不是也存在安全问题呢？

    如果你把new后的对象发布出去，就是放到其他共享变量中，也会存在线程安全问题。
    如果new后 只是在方法中使用该对象 而不作为参数传出去（以它为调用者的实例方法也不会传出去），那么没有问题。


------------------------------------------------------------------------------------------------------------------------
如果新生代晋升到老年代失败的时候如何处理？（可能原因：老年代内存不够，老年代碎片过多，晋升的新生代太大）

    此时发生 full gc，对于cms可能还伴随着一次压缩

------------------------------------------------------------------------------------------------------------------------
老师，GC ROOT到底指的是对象本身，还是引用？

    严格来说应该是 对象

    像局部变量中存放的引用 只是导致 对象成为GC roots 的原因。
    我个人倾向于 将这些引用 作为 GC roots，因为GC 是从这些地方出发 开始探索的。
    看各人理解方便吧。

    你可以参考eclipse MAT定义的GC roots:
        https://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html


------------------------------------------------------------------------------------------------------------------------
1、什么场景下老年代的对象会引用新生代的对象？是有些对象可以移到老年代了但是他引用的对象还不能是吗？

    对的。
    还有一种可能，就是更新老年代对象的引用型字段，使之指向新生代对象。


2、我觉得卡表的维护很重要，并发环境怎么保证卡表的健壮性？

    我的理解：
        应用程序只设置脏位而不清除，垃圾回收前需要强制flush CPU缓存。

------------------------------------------------------------------------------------------------------------------------
TLAB 和 工作内存 是什么关系？

    如果你说的是 JMM 中的工作内存，那是JMM抽象出来的一个概念，在现实的体系架构中可以映射为CPU中的缓存，属于硬件技术。

    TLAB 是用来 优化多线程分配的，属于软件技术。

    两者没啥关系。

------------------------------------------------------------------------------------------------------------------------
卡表用于堆内所有空间(新生代/老年代/永久代)，还是只存在于老年代？

    卡表 是用来优化 快速判断 老年代中 是否引用新生代对象的技术，你说它是哪里

------------------------------------------------------------------------------------------------------------------------

1、Java将堆分成 新生代及老年代 分别应对不同的对象生命周期消亡的特点

    新生代 使用 标记-复制：

        新生代对象 存活时间短，垃圾回收后 相应的存活对象少，可用 标记-复制算法。
        并且新生代用于分配新对象，所以要求有 连续空的内存 用于快速分配。这里涉及TLAB，即java线程会先申请线程单独有的内存。

    老年代 使用 标记-清除：

        老年代对象 存活时间长，垃圾回收后 会有大量对象还是在的，所以用 标记-复制的话 复制成本比较大，相比直接清除成本更低。
        且老年代分配新对象的频率较小，是一个 trade off 的过程。

2、Minor gc 涉及如何防止新生代有个对象在线程等gc root没有在用，但实际老年代对象存在新生代对象的引用。
    这个解法就是卡表，将内存划分512字节的卡页，卡页有标识是否为脏页的字段。

    在Minor gc时如果发现新生代对象卡页为 脏，则 不会 对该对象进行回收。

    卡页设置的触发点是：

        在复制对象到老年代时需要更新对应引用，这时将引用所对应的卡页设置为脏标记。

        eg：对象C中引用了新生代对象B，对象C在Minor gc时需要移到老年代，这时需要更新新生代对象B所在卡表为脏页。


------------------------------------------------------------------------------------------------------------------------
Java对象的生存周期

    大部分对象的生命周期都很短，小部分对象的生命周期很长。

    因为这个特点，可以对jvm内存分代，不同代采用不同的回收方式：

        年轻代要采用频繁的回收方式，快速回收大部分垃圾。

        老年代则采用不频繁但彻底的回收方式。


JVM堆的划分

    因为对象以上的特点，将堆分为两个代，新生代和老年代。

    新生代分为 Eden区 和 两个Survivor区：
        可以使用参数 “xx”， 会动态的根据对象的生成速率以及survivor区的使用情况，调整Eden区和survivor区的比例。
        也可以使用参数“xx”，来固定Eden和survivor的比例。


如何保证内存分配的线程安全

    堆 是共享的，所有的线程都会在 堆上分配内存

    那么jvm是如何保证内存分配是线程安全的？

        每个线程都会有 TLAB(thread local allocation buffer)，这个是线程私有的。

        首先会在TLAB上分配，如果TLAB不够用，就需要通过加锁的方式，申请TLAB。


Eden区满了

    触发 Minor GC，Eden和from依旧存活的对象会放置到to区。然后交换from、to指针的指向。

        其中达到经历过一定回收次数的对象将会被晋升到老年代，同时如果也配置了[xx]参数。

        单个survivor区占用超过50%，经历次数较高的对象也会晋升到老年代。


    先提前说一个结论，Minor GC有一个好处：

        发生GC时不会遍历 整个堆内存，只会遍历 Eden + Survivor区

    讲道理，老年代很可能拥有 Eden + Survivor区 对象的引用，那 Minor GC 只遍历年轻代，是怎么做到GC的呢？


卡表

    HotSpot会将堆分割成一个个512字节大小的卡，然后维护一张卡表，每个卡在表中占据一个卡位。


------------------------------------------------------------------------------------------------------------------------
在copy对象的时候，card table也需要更新吧？

    1、copy对象 指的是 垃圾回收器的copy吗

        垃圾回收时 会更新卡表的

    2、或者你说的是克隆

        我认为 Object.clone 也会更新卡表
------------------------------------------------------------------------------------------------------------------------
卡表中将堆划分为大小为512字节的卡，意思是将512字节的数据作为一个卡吗？

    可以这么说

然后用卡片中的比特位1、0代表是否存在GC roots？

    指的是这张卡上的对象很可疑，可能存在 GC roots


------------------------------------------------------------------------------------------------------------------------
Minor GC 也会造成stop the world吗？

    GC 都会啊


------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
请问JVM分代收集新生代对象进入老年代，年龄为什么是 15 而不是其他的?

    HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15

------------------------------------------------------------------------------------------------------------------------
JVM中堆内存 GC roots 的物理内存是如何对应的，这个可以从哪里看？

    GC roots分布在HotSpot中的每个子系统里

    可以在源码中搜oops_do






========================================================================================================================
可达性分析                   ->    遍历 GC_Roots 对象（引用链）
========================================================================================================================

如何区分垃圾

    1、引用计数

        通过统计控制生成对象和删除对象时的引用数来判断。

        垃圾回收程序收集计数为0的对象即可。

        但是这种方法无法解决 循环引用。


    2、可达性分析

        所以，后来实现的垃圾判断算法中，都是从程序运行的根节点出发，遍历整个对象引用，查找存活的对象。

        那么在这种方式的实现中，垃圾回收从哪儿开始的呢？即，从哪儿开始查找哪些对象是正在被当前系统使用的。

            1、栈

                上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从Java栈开始。

                同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。

            2、PC寄存器

                同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。

            3、方法区

            ------------------------------------------------------------------------------------------------------------
            这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象
                又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以null引用或者基本类型结束

            这样就形成了一颗以 Java栈中引用所对应的对象 为根节点的一颗对象树，如果栈中有多个引用，则最终会形成多颗对象树。
                在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。
                而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。

            因此，垃圾回收的起点是一些根对象（java栈、静态变量、寄存器...）
                而最简单的Java栈就是   ->   Java程序执行的main函数
                这种回收方式，也是上面提到的 “标记-清除” 的回收方式


------------------------------------------------------------------------------------------------------------------------
如何处理碎片
------------------------------------------------------------------------------------------------------------------------
    由于不同Java对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。

    碎片最直接的问题就是会导致

        1、无法分配 大块的内存空间

        2、程序运行效率降低

    所以，在上面提到的基本垃圾回收算法中，“复制”方式和“标记-整理”方式，都可以解决碎片的问题。




------------------------------------------------------------------------------------------------------------------------
如何解决   同时存在的  ->  对象创建 和 对象回收 问题                            // 垃圾回收的 并发安全   ->  效率（性能） 与 安全
------------------------------------------------------------------------------------------------------------------------

1、回收 - 分配                    // 矛盾


    垃圾回收线程      ->     是   回收内存的

    程序运行线程      ->     是   消耗（或分配）内存的



2、暂停                           // 同步算法（类似  ->  加锁算法）    ->    串行（单线程）、并行（多线程）


    回收 - 分配    ===>    矛盾  ->  暂停  整个应用：

        1、一个回收内存，一个分配内存     ->    从这点看，两者是矛盾的

        2、因此，在现有的垃圾回收方式中，

            进行垃圾回收前     ->       一般都需要   暂停整个应用（暂停内存的分配）

            然后进行垃圾回收，回收完成后再继续应用

        3、这种实现方式是最直接，而且最有效的解决二者矛盾的方式。



3、不暂停                       // 并发算法（类似  ->  无锁算法）

    但是这种方式有一个很明显的弊端

        当堆空间 持续增大时   ->   垃圾回收的时间 也将会相应的持续增大   ->   应用暂停的时间 也会相应的增大


    一些对响应时间要求很高的应用

        比如最大暂停时间要求是几百毫秒，那么当堆空间大于几个G时，就很有可能超过这个限制


    在这种情况下

        1、垃圾回收 将会成为系统运行的 一个瓶颈

        2、为解决这种矛盾   ==>   有了 并发垃圾回收算法

            使用这种算法   =>   垃圾回收线程 与 程序运行线程   ->   同时运行

        3、在这种方式下

            1、解决了暂停的问题

            2、但是因为需要    ==>   在新生成对象 的同时   +   又要回收对象

                算法复杂性 会大大增加   ->   系统的处理能力 也会相应降低   ->   同时，“碎片”问题 将会比较难解决




========================================================================================================================
分代 回收
========================================================================================================================

分代的 垃圾回收策略，是基于这样一个事实：

    不同对象的生命周期      ->     是不一样的

    不同生命周期的对象      ->     可以采取 不同的收集方式     ->    以便提高 回收效率


------------------------------------------------------------------------------------------------------------------------
分代回收：

    由于对象进行了 分代处理         ->    因此 垃圾回收区域、时间也不一样

    ===>   GC 一般指的是：

                Minor GC                    ->    新生代

                Major GC / Full GC          ->    整个堆（代）    ->     新生代 + 老年代 + 持久代



------------------------------------------------------------------------------------------------------------------------
Minor GC                                            // 新生代


    特点：
        1、针对 新生代

        2、新生代空间小   ->   触发频繁   ->   回收快

    触发：
        当新对象生成，并且在 Eden区 申请空间失败时       ->      触发 Minor GC

    过程：

        1、对 Eden区 进行GC，清除非存活对象

        2、并且把 尚且存活的对象 移动到 Survivor区

        3、然后整理 Survivor的两个区     ->      from/to 指针互换


    这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。

        因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。

        因而，一般在这里需要使用速度快、效率高的算法，使Eden能尽快空闲出来。


------------------------------------------------------------------------------------------------------------------------
Full GC                                             // 整个 堆（代）   ->    新生代 + 老年代 + 持久代

    区域：
        整个堆     ->     包括 Young、Tenured、Perm

    Full GC 因为需要对整个对进行回收，所以比 Minor GC 要慢，因此应该尽可能减少 Full GC 的次数

    在对JVM调优的过程中，很大一部分工作就是对于 Full GC 的调节


    触发 Full GC：

        1、老年代（Tenured）空间不足

        2、方法区（Perm）空间不足

        3、显示调用 System.gc()   ->  系统建议执行Full GC，但是不必然执行

        4、上一次GC之后Heap的各域分配策略动态变化



========================================================================================================================
分代
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
1、为什么要分代
------------------------------------------------------------------------------------------------------------------------

分代的 垃圾回收策略，是基于观察得出的事实：

    不同对象的生命周期      ->     是不一样的         // 二八法则


    ==>   不同生命周期的对象      ->     采取 不同的垃圾回收方式     ->    提高 回收效率



在Java程序运行的过程中，会产生大量的对象

    1、长生命周期对象

        其中 有些对象   ->    是与 业务信息相关，跟 业务直接挂钩    ->   因此  生命周期比较长

        比如：Http请求中的Session对象、线程、Socket连接

    2、短生命周期对象

        但是还有一些对象   ->    主要是 程序运行过程中 生成的   临时变量    ->   这些对象   生命周期会比较短

        比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。


试想，在不进行 对象存活时间区分 的情况下

    1、每次垃圾回收 都是对整个堆空间 进行回收，花费时间相对会长

    2、同时，因为每次回收 都需要遍历 所有存活对象

        但实际上，对于 生命周期长的对象 而言，这种遍历 是没有效果的

        因为可能进行了 很多次遍历，但是他们 依旧存在。


    3、因此，分代垃圾回收采用  分治的思想，进行 代的划分

        把不同生命周期的对象   ->   放在不同代上

        不同代上 采用最适合它的 垃圾回收方式 进行回收



------------------------------------------------------------------------------------------------------------------------
2、如何分代
------------------------------------------------------------------------------------------------------------------------

虚拟机中的共划分为三个代：

    新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）

        新生代和老年代 的划分   ->   是对垃圾回收 影响比较大的

        永久代                 ->   主要存放的是 Java类的类信息     ->     与垃圾回收 要收集的Java对象 关系不大




------------------------------------------------------------------------------------------------------------------------
新生代:
------------------------------------------------------------------------------------------------------------------------
    所有 新生成的对象  首先都是放在 年轻代 - Eden区

        Eden    +    Survivor(From)    +    Survivor(To)

    年轻代的目标

        尽可能快速的 收集掉那些 生命周期短 的对象

------------------------------------------------------------------------------------------------------------------------
老年代:
------------------------------------------------------------------------------------------------------------------------
    在 新生代中经历了N次（默认15次） 垃圾回收后   ->   仍然存活的对象    ->   就会被放到 老年代中


    老年代中存放的
        都是一些 生命周期较长 的对象

------------------------------------------------------------------------------------------------------------------------
永久代:
------------------------------------------------------------------------------------------------------------------------
    用于存放 静态文件   ->   如： Java类、方法等

        持久代对垃圾回收 没有显著影响

        但是有些应用可能 动态生成或者调用一些class

            例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

            持久代大小通过-XX:MaxPermSize=<N>进行设置。








========================================================================================================================
方法区                     // 永久代（HotSpot VM 对方法区的实现）
========================================================================================================================

方法区     ->      标准/规范

实现
    1.2 ~ 1.6       ->         HotSpot  ->   永久代
    1.7             ->         HotSpot  ->   永久代
    1.8             ->         HotSpot  ->   元空间



随JDK版本变迁的方法区

    JDK6

        Klass 元数据信息

        每个类的运行时常量池（字段、方法、类、接口等符号引用）、编译后的代码

        静态字段（无论是否有final）在 instanceKlass 末尾（位于 PermGen 内）

        oop（Ordinary Object Pointer（普通对象指针）） 其实就是 Class 对象实例

        全局字符串常量池 StringTable，本质上就是个 Hashtable

        符号引用（类型指针是 SymbolKlass）


    JDK7

        Klass 元数据信息

        每个类的运行时常量池（字段、方法、类、接口等符号引用）、编译后的代码

        ---------------------------------------------------------------------------------------
        静态字段 从 instanceKlass 末尾移动到了 java.lang.Class 对象（oop）的末尾（位于 Java Heap 内）

        oop 与 全局字符串常量池  移到 Java Heap 上

        符号引用 被移动到 Native Heap 中


    JDK8

        移除永久代

        ---------------------------------------------------------------------------------------
        Klass 元数据信息

        每个类的 运行时常量池、编译后的代码  移到了另一块与堆不相连的 本地内存 -- 元空间（Metaspace）






========================================================================================================================
默认GC                                                                        // 参数可配
========================================================================================================================

Java 5          串行          Serial GC                       ->    Serial（新生代）             +   Serial Old（老年代）

Java 8          并行          Parallel GC                     ->    Parallel Scavenge（新生代）  +   Parallel Old（老年代）

Java 11         并发          G1


--------------------------------------------------
命令
    java -XX:+PrintCommandLineFlags -version

    java -XX:+PrintGCDetails -version



------------------------------------------------------------------------------------------------------------------------
[root@F001 ~]# java -XX:+PrintCommandLineFlags -version

-XX:InitialHeapSize=260250240 -XX:MaxHeapSize=4164003840 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops

-XX:+UseParallelGC                                                      // UseParallelGC

java version "1.8.0_151"
Java(TM) SE Runtime Environment (build 1.8.0_151-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)


------------------------------------------------------------------------------------------------------------------------
[root@F001 ~]# java -XX:+PrintGCDetails -version

java version "1.8.0_151"
Java(TM) SE Runtime Environment (build 1.8.0_151-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)


Heap

 PSYoungGen      total 74752K, used 2580K [0x000000076d400000, 0x0000000772700000, 0x00000007c0000000)
  eden space 64512K, 4% used [0x000000076d400000,0x000000076d685368,0x0000000771300000)
  from space 10240K, 0% used [0x0000000771d00000,0x0000000771d00000,0x0000000772700000)
  to   space 10240K, 0% used [0x0000000771300000,0x0000000771300000,0x0000000771d00000)

 ParOldGen       total 171008K, used 0K [0x00000006c7c00000, 0x00000006d2300000, 0x000000076d400000)
  object space 171008K, 0% used [0x00000006c7c00000,0x00000006c7c00000,0x00000006d2300000)

 Metaspace       used 2226K, capacity 4480K, committed 4480K, reserved 1056768K
  class space    used 243K, capacity 384K, committed 384K, reserved 1048576K





========================================================================================================================
Java内存模型
========================================================================================================================

Java 内存模型通过定义了一系列的 happens-before 操作

    让应用程序开发者   ->   能够轻易地表达 不同线程的操作之间的 内存可见性


在遵守 Java 内存模型的前提下

    即时编译器以及底层体系架构   ->   能够调整内存访问操作，以达到性能优化的效果

    如果开发者没有正确地利用 happens-before 规则   ->   那么将可能导致 数据竞争


Java 内存模型是通过 内存屏障 来禁止重排序的

    对于即时编译器来说   ->    内存屏障  将限制 它所能做的重排序优化

    对于处理器来说       ->    内存屏障  会导致缓存的刷新操作




------------------------------------------------------------------------------------------------------------------------
刚才有说不会把volatile放到寄存器，但是应该会在栈里面对吧。
直接读取主内存，读写的是栈数据，然后利用堆内存和栈上数据是利用写缓存刷新同步的？

    我可能没有在原文中讲清楚。
    这里指的是volatile变量不能被分配到寄存器中，但是计算还是加载到寄存器中来计算的。

    所谓的分配到寄存器中，你可以理解为编译器将内存中的值缓存在寄存器中，之后一直用访问寄存器来代表对这个内存的访问的。
    假设我们要遍历一个数组，数组的长度是内存中的值。
    由于我们每次循环都要比较一次，因此编译器决定把它放在寄存器中，免得每次比较都要读一次内存。
    对于会更改的内存值，编译器也可以先缓存至寄存器，最后更新回内存即可。

    volatile会禁止上述优化

------------------------------------------------------------------------------------------------------------------------
求讲解下jvm中代码如何实现的内存屏障

    即时编译器生成的代码里会使用CPU的内存屏障指令。
    HotSpot采用的lock前缀的指令，lock add DWORD PTR [rsp] 0。它也会刷缓存。

    至于在即时编译器里禁止重排序所使用的”内存屏障”，就是一个特殊的编译器中间表达形式节点。


------------------------------------------------------------------------------------------------------------------------
我在一些技术文章里看到说 volatile 的变量是存在工作内存，这个工作内存是一个什么概念？

    工作内存是JMM抽象出来的一个概念，你可以映射到实际的CPU缓存。


------------------------------------------------------------------------------------------------------------------------
一个共享对象的变量是非volatile的，那么这个变量的写入会先写到寄存器上，再写回内存吗？
那么jvm是不是无论如何都不保证啥时候变量的值会写回内存。假如另一个线程加锁访问这个变量，是不是jvm也不保证它能拿到最新数据。

    对的！
    如果即时编译器把那个变量放在寄存器里维护，那么另一个线程也没辙。


------------------------------------------------------------------------------------------------------------------------
问一下，内存屏障是即时编译器生成本地代码的时候产生的？？那照这个意思岂不是关闭即时编译器，就实现不了happen-before原则了？

    在解释执行时，字节码之间也有内存屏障

------------------------------------------------------------------------------------------------------------------------
关于volatile, 我想问下，如果是单个cpu的系统上运行多线程的程序，是不是这个volatile就没有效果了？ 因为大家都使用同一个寄存器。

    理论上，因为都使用同一套缓存，所以不需要volatile。
    实际实现中，对编译器不能重排列的限制还是存在的，但具体的 memory barrier指令 的实现是no-op。


------------------------------------------------------------------------------------------------------------------------
即时编译在单线程的情况下，根据as if serial 的选择，会使得 编译逻辑和程序逻辑 相同。

但是，在多线程情况下可能出现编译器重排序导致的数据竞争。这时就需要使用volatile来禁止重排序。

volatile的底层原理，是在字节码中插入内存屏障实现的。

内存屏障会被转化成一条指令，指令具体的效果是强制刷新缓存。
疑问：为什么是强制刷新缓存？是因为happen-before原则，要让后面的程序看到？ 那后面程序看到的就是缓存中的内容吗？

我对寄存器，缓存有不熟悉的地方，希望老师可以指正，指导我该补哪方面的知识，多谢



    我们考虑一种简单情况，即每个CPU有独占缓存，没有共享缓存。
    强制刷新缓存，是为了让跑在另外一个CPU上的线程看到你这个CPU上更新的内容。

    如果想要深入研究下去，可以翻翻CSAPP那本书。

------------------------------------------------------------------------------------------------------------------------
当工作线程需要的内存特别大 比如超过10m 那工作线程会copy10m的内存数据到工作线程嘛？


    JMM里的工作内存是个虚拟概念，实际上映射到的是CPU缓存。

    如果你指工作线程会不会将用到的内存加载至CPU缓存中，那么答案是会的。

    如果你指会不会另外开一片内存，来存储这部分用到的堆内存，那么答案是不会的。


------------------------------------------------------------------------------------------------------------------------




========================================================================================================================
synchronized 的实现
========================================================================================================================


synchronized 关键字的实现

    无锁      ->      偏向锁     ->      轻量级锁（自适应 - 自旋锁）    ->      重量级锁（互斥锁 - mutex）



    重量级锁

        会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。

    轻量级锁

        采用 CAS 操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储着锁对象原本的标记字段。
        它针对的是多个线程在不同时间段申请同一把锁的情况。

        Java 虚拟机采取了自适应自旋，来避免线程在面对非常小的 synchronized 代码块时，仍会被阻塞、唤醒的情况。

    偏向锁
        只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。
        在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。


------------------------------------------------------------------------------------------------------------------------
问一下加锁实际上都是加在当前线程吗


    这个说法有点歧义。

    按我的理解，你应该在问是否为当前线程获得这把锁？那么答案是对的

        一定是 当前线程 获得这把锁

        另外，锁是加在 目标锁 对象上的


------------------------------------------------------------------------------------------------------------------------
本课程在介绍轻量级锁的时候，没提及轻量级锁在其他线程占用改锁的的时候，是否会进入自旋状态。
我先前的理解是，轻量级锁在被其他线程占用的时候，会进入短暂的自旋状态，当自旋达到一定的阈值后，膨胀为重量级锁，阻塞当前线程。
不知道我这么理解是否正确？


    我印象中不会自旋，直接膨胀。

    轻量级锁的假设是，不同线程拿同一把锁的时间没有overlap。一旦有了overlap，即需要竞争锁的情况，那么假设失效，需要膨胀为重量锁。

    如果乐观点的话，猜测只有这一次假设失效，那也可以自旋一会再膨胀。不过我记得没有这么乐观。

    你可以自己读hotspot的源代码，share/runtime/synchronizer.cpp ObjectSynchronizer:fast_enter


------------------------------------------------------------------------------------------------------------------------
当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。
标记在方法上也有这两个指令吗？


    没有，方法有ACC_SYNCHRONIZED标志符



========================================================================================================================
Java字节码
========================================================================================================================


为什么局部变量要初始化？想请老师专业解答下！

    如果是虚拟机初始化局部变量，那么它需要掌握每个变量的生命周期，以便初始化共享同一下标的局部变量。实现起来比较费事。

    另一方面，从代码规范来看，使用未经初始化的局部变量意义不明。

    ------------------------------------------------------------------------------------
    这个好理解，主要从这个变量在使用的时候，有什么场景，是先赋值在使用还是不赋值可以直接使用。

    就两种：局部和成员

        对于成员变量：
            在类加载过程的准备阶段即可给它赋予默认值，其赋值和取值访问在运行时的先后顺序具有不确定性(有可能先取值后赋值)
            所以加载阶段赋予默认值，保证了成员变量只要被定义，就可以被使用。
            对象不创建，我也可以使用它的成员变量。

        对于局部变量：
            是在类方法中的变量，在执行方法(字节码执行时候)的时候才会用到，其赋值和取值访问顺序是确定的。
            运行时被分配在栈中，量大且生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销(类中方法很多)
            这样设计也是一种约束，尽最大程度减少使用者犯错的可能。
            假使局部变量可以使用默认值，可能会无意间忘记赋值，进而导致不可预期的情况出现。
            同时局部变量不赋值就使用是不安全的。



------------------------------------------------------------------------------------------------------------------------
