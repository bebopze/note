----------------------------------------------------
Arrays.sort();


    1、基本类型

        DualPivotQuicksort                          - https://baijiahao.baidu.com/s?id=1660992747529534465
                                                    - https://blog.csdn.net/xjyzxx/article/details/18465661
                                                    - https://www.cnblogs.com/weiyinfu/p/10963062.html


            数据规模 -> 不同算法：                   // 47 、 286              ->   根据 数据规模    --路由-->   不同算法


                1、(0, 47]               ->      插入

                    注意的是, 在这里提供了两种不同的插入排序算法,

                        当传入的参数leftmost真假值不同时, 会使用不同的算法.

                    leftmost

                        代表的是本次传入的数组是否是从最初的int[] a的最左侧left开始的,
                        因为本方法在整个排序过程中可能会针对数组的不同部分被多次调用, 因此leftmost有可能为false.


                2、(47, 286]             ->      快排

                    单/双 基准快排：

                        思路上虽然并不复杂, 但为了尽可能的提高效率, 在对这个算法进行实现的过程中增加了非常多的细节；


                        最具特色的部分, 就是对pivot的选取:

                            1、先通过位运算，获取数组长度的1/7的近似值（位运算无法精确表示1/7）

                            2、然后获取本数组 中间位置的索引e3

                            3、在中间位置的左右1/7、2/7处，各获取两个索引（e1, e2, e4, e5）

                            4、之后再将这五个索引对应的值，用插入算法进行有小到大的排序后, 再放回五个索引的位置

                            5、接下来进行判断：

                                1、若这五个索引对应的元素值 各不相同             // 双

                                    1、则选取 e2的值作为pivot1, e4的值作为pivot2（特别注意基准是值 而不是元素）

                                    2、然后进行 双 基准快排

                                        接下来就是移动位置，分成三部分了    // ~1~   pivot1   ~2~   pivot2  ~3~


                                2、如果这五个值中 有相同的存在                  // 单

                                    1、则 本轮排序选取 e3的值作为pivot

                                    2、进行 单 基准快排



                            6、分区部分排序

                                递归的将第一二三部分排序



                3、(286, +∞)

                    1、趋近 有序           ->    归并           // count <  67

                    2、无序                ->    快排          // count >= 67


                    --------------------------------------------------------------------
                    当长度大于286时，继续判断该数组是否已经 高度结构化（已接近 排序完成）

                        基本思路：

                            1、定义一个常量 MAX_RUN_COUNT = 67;

                            2、定义一个计数器 int count = 0; 定义一个数组 int[] run 使之长度为 MAX_RUN_COUNT + 1;

                            3、令run[0] = left, 然后从传入数组的最左侧left开始遍历

                                若数组的 前n个元素 均为升序/降序排列, 而 第n+1个元素 的升/降序发生了改变

                                则将 第n个元素 的索引存入run[1], 同时++count, 此时count的值为1

                            4、从n+1开始继续遍历, 直至升/降序再次改变, 再将此处的索引存入run[2], ++count, 此时count的值为2, 以此类推...

                            ......

                            5、若将整个数组 全部遍历完成 后

                                1、count < 67                                 // 升/降序 改变次数  <  67次

                                    该数组 是 高度结构化     ->      归并

                                        判断该数组本身 是否完全有序：

                                            1、是(count == 1)     ->   直接return

                                            2、否                 ->   归并排序

                                2、若 count == 67 时, 还未完成 对数组的遍历       // 升/降序 改变次数  >=  67次

                                    该数组 非 高度结构化     ->      快排









    2、引用类型

        1、MergeSort                 // 旧版 归并

            兼容旧版，强制 legacyMergeSort


        2、TimSort                   // 新版 归并


            TimSort

                是 工业级算法

                其混用 归并排序 与 插入排序，二分搜索等算法

                亮点是充分利用待排序数据可能部分有序的事实

                并且依据待排序数据内容 动态改变排序策略————选择性进行归并 以及galloping



            TimSort

                是一个归并排序做了大量优化的版本
                对归并排序排在已经反向排好序的输入时做了特别优化
                对已经正向排好序的输入减少回溯
                对两种情况混合（一会升序，一会降序）的输入处理比较好







----------------------------------------------------
快速排序

    使用的是 分治思想，将原问题 分成若干个子问题 进行递归解决


    选择一个元素作为 轴(pivot)，通过一趟排序 将要排序的数据 分割成独立的两部分

        其中一部分的所有数据 都比轴元素小，另外一部分的所有数据 都比轴元素大

    然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列




----------------------------------------------------
双基准快排(DualPivotQuicksort)

    顾名思义 有两个轴元素：pivot1、pivot2

    且 pivot ≤ pivot2

    将序列分成三段：

        x < pivot1  、  pivot1 ≤ x ≤ pivot2  、  x > pivot2

        然后分别对三段 进行递归

        这个算法通常会比传统的快排效率更高


----------------------------------------------------
Collections.sort(List list);




