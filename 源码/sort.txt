----------------------------------------------------
Arrays.sort();


    1、基本类型

        DualPivotQuicksort                          - https://baijiahao.baidu.com/s?id=1660992747529534465
                                                    - https://blog.csdn.net/xjyzxx/article/details/18465661
                                                    - https://www.cnblogs.com/weiyinfu/p/10963062.html


            数据规模 -> 不同算法：                   // 47 、 286              ->   根据 数据规模    --路由-->   不同算法


                1、(0, 47]               ->      插入

                    注意的是, 在这里提供了两种不同的插入排序算法

                        当传入的参数leftmost真假值不同时, 会使用不同的算法

                        leftmost

                            代表的是本次传入的数组是否是从 最初的int[] a 的最左侧left开始的
                            因为本方法在整个排序过程中可能会针对数组的不同部分被多次调用, 因此leftmost有可能为false


                2、(47, 286]             ->      快排

                    单/双 基准快排：

                        思路上虽然并不复杂, 但为了尽可能的提高效率, 在对这个算法进行实现的过程中增加了非常多的细节；

                        --------------------------------------------------
                        最具特色的部分, 就是对pivot的选取：

                            1、先通过位运算，获取数组长度的1/7的近似值（位运算无法精确表示1/7）

                            2、然后获取本数组 中间位置的索引e3

                            3、在中间位置的左右1/7、2/7处，各获取两个索引（e1, e2, e4, e5）

                            4、之后再将这五个索引对应的值，用插入算法进行有小到大的排序后, 再放回五个索引的位置

                            5、接下来进行判断：

                                1、若这五个索引对应的元素值 各不相同             // 双

                                    1、则选取 e2的值作为pivot1, e4的值作为pivot2（特别注意基准是值 而不是元素）

                                    2、然后进行 双 基准快排

                                        接下来就是移动位置，分成三部分了    // ~1~   pivot1   ~2~   pivot2  ~3~


                                2、如果这五个值中 有相同的存在                  // 单

                                    1、则 本轮排序选取 e3的值作为pivot

                                    2、进行 单 基准快排



                            6、分区快排

                                递归的 将一二三部分 快排排序



                3、(286, +∞)

                    1、趋近 有序           ->    归并           // count <  67

                    2、无序                ->    快排          // count >= 67


                    --------------------------------------------------------------------
                    当长度大于286时，继续判断该数组是否已经 高度结构化（已接近 排序完成）

                        基本思路：

                            1、定义一个常量 MAX_RUN_COUNT = 67;

                            2、定义一个计数器 int count = 0; 定义一个数组 int[] run 使之长度为 MAX_RUN_COUNT + 1;

                            3、令run[0] = left, 然后从传入数组的最左侧left开始遍历

                                若数组的 前n个元素 均为升序/降序排列, 而 第n+1个元素 的升/降序发生了改变

                                则将 第n个元素 的索引存入run[1], 同时++count, 此时count的值为1

                            4、从n+1开始继续遍历, 直至升/降序再次改变, 再将此处的索引存入run[2], ++count, 此时count的值为2, 以此类推...

                            ......

                            5、若将整个数组 全部遍历完成 后

                                1、count < 67                                 // 升/降序 改变次数  <  67次

                                    该数组 是 高度结构化     ->      归并

                                        判断该数组本身 是否完全有序：

                                            1、是(count == 1)     ->   直接return

                                            2、否                 ->   归并排序

                                2、若 count == 67 时, 还未完成 对数组的遍历       // 升/降序 改变次数  >=  67次

                                    该数组 非 高度结构化     ->      快排




    2、引用类型

        1、MergeSort                 // 旧版 归并

            兼容旧版，强制 legacyMergeSort


        2、TimSort                   // 新版 归并


            TimSort

                是 工业级算法

                其混用 归并排序 与 插入排序，二分搜索等算法

                亮点是充分利用待排序数据可能部分有序的事实

                并且依据待排序数据内容 动态改变排序策略————选择性进行归并 以及galloping



            TimSort

                是一个归并排序做了大量优化的版本
                对归并排序排在已经反向排好序的输入时做了特别优化
                对已经正向排好序的输入减少回溯
                对两种情况混合（一会升序，一会降序）的输入处理比较好


            大致思路：

                1、元素个数 < 32,  采用 二分查找插入排序（Binary Sort）
                2、元素个数 >= 32, 采用 归并排序，归并的核心是 分区（Run）
                3、找连续升或降的序列作为分区，分区最终被调整为升序后压入栈
                4、如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值
                5、每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并
                6、最终栈内的分区被全部合并，得到一个排序好的数组


            TimSort的合并算法非常巧妙：

                1、找出左分区最后一个元素(最大)及在右分区的位置
                2、找出右分区第一个元素(最小)及在左分区的位置
                3、仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的




----------------------------------------------------
数据库里面的Order BY，用的是什么排序呢？

    如果有limit限制，则是 堆排序

    如果数据无法全部读入内存，则是 归并

    否则 快排



----------------------------------------------------
快速排序

    使用的是 分治思想，将原问题 分成若干个子问题 进行递归解决


    选择一个元素作为 轴(pivot)，通过一趟排序 将要排序的数据 分割成独立的两部分

        其中一部分的所有数据 都比轴元素小，另外一部分的所有数据 都比轴元素大

    然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列




----------------------------------------------------
双基准快排(DualPivotQuicksort)

    顾名思义 有两个轴元素：pivot1、pivot2

    且 pivot ≤ pivot2

    将序列分成三段：

        x < pivot1  、  pivot1 ≤ x ≤ pivot2  、  x > pivot2

        然后分别对三段 进行递归

        这个算法通常会比传统的快排效率更高


----------------------------------------------------
Collections.sort(List list);




