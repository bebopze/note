========================================================================================================================
AQS                                                                                       // AbstractQueuedSynchronizer

    volatile int state;     // 共享变量  ->  同步状态


    CLH队列                 // FIFO双端同步队列  ->  基于Node 双向链表   ->   通过内置的FIFO队列 来完成 获取资源、线程排队

        1、FIFO双端同步队列   ->   公平队列                                    // CLH  =>  Craig Landin Hagersten -> 人名

        2、基于Node 双向链表


------------------------------------------------------------------------------------------------------------------------
Node

    static final Node SHARED = new Node();          // 共享式  Node模式标识   ->   new Node()
    static final Node EXCLUSIVE = null;             // 独占式  Node模型标识   ->   null


    volatile  Node prev
    volatile  Node next


    volatile  Thread thread          // 与当前Node 关联的 排队中的Thread



    volatile int waitStatus = 0         // 等待状态  ->  初始值 0

        CANCELLED  =  1      ->      线程已失效                                      // 等待超时或者被中断

        SIGNAL     = -1      ->      后继线程需要被唤醒（unpaking）                   // head.next结点 需要被唤醒

        CONDITION  = -2      ->      结点线程等待在Condition队列上                    // 用于Lock.Condition  ->  条件变量  ->  当被signal后  =>  会从  等待队列（Condition队列） -> 同步队列

        PROPAGATE  = -3      ->      下一次共享式同步状态  会被无条件地传播下去        // 共享式   ->  若还有可用资源，传播下去，也就是继续唤醒后继结点



========================================================================================================================
对于独占式同步组件

    1、同一时刻只有一个线程 能获取到同步状态     ->   其他线程都得去排队等待

    2、待重写的 尝试获取同步状态（锁）的方法     ->   tryAcquire() 的返回值为       boolean



对于共享式同步组件

    1、同一时刻可以有多个线程 同时获取到同步状态，这也是“共享”的意义所在

    2、待重写的 尝试获取同步状态（锁）的方法     ->   tryAcquireShared() 的返回值为  int


        1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取

    　　2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了

    　　3.当返回值小于0时，表示获取同步状态失败




========================================================================================================================
AQS是JUC中很多同步组件的构建基础

    它内部实现主要是：

        1、状态变量state

        2、一个FIFO队列


    同步队列的 head结点  ->  当前获取到同步状态 的结点


    获取同步状态state失败的线程

        1、会被构造成一个结点         // 共享式/独占式

        2、加入到同步队列尾部         // 采用自旋CAS来保证此操作的线程安全

        3、随后线程会阻塞


    释放时

        唤醒 head结点的后继结点，使其加入对同步状态的争夺中



------------------------------------------------------------------------------------------------------------------------
AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时

    只需重写 tryAcquire、tryRelease，tryAcquireShared、tryReleaseShared 几个方法，来决定同步状态的释放和获取即可

    至于背后复杂的 线程排队、线程阻塞/唤醒、如何保证线程安全，都由AQS为我们完成了



这也是非常典型的模板方法的应用

    AQS定义好顶级逻辑的骨架

    并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，

    将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现





========================================================================================================================
AQS

    待重写方法 -> 空实现                       // throw new UnsupportedOperationException()   ->   子类 按模式选择性实现


        tryAcquire()                           // 独占式获取同步状态，试着获取，成功返回true，反之为false
        tryRelease()                           // 独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；


        tryAcquireShared()                     // 共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；
        tryReleaseShared()                     // 共享式释放同步状态，成功为true，失败为false


        isHeldExclusively()                    // 是否在独占模式下被线程占用


    Condition



========================================================================================================================
独占锁

    实现  ->  tryAcquire()、tryRelease()

共享锁

    实现  ->  tryAcquireShared()、tryReleaseShared()




========================================================================================================================
自定义同步器  ->  AQS模板方法  ->  重写方法

    ------------------------------------------------------------------------------------------
    1、 tryAcquire()、tryRelease()


        MyLock   ->   lock / tryLock / tryLock(time) / lockInterruptibly

            AQS   ->   acquire / tryAcquireNanos / acquireInterruptibly         // 模板方法

                sync   =>   tryAcquire()                                        // 重写方法

        ---------------------------------------
        MyLock   ->   unlock

            AQS   ->   release

                sync   =>   tryRelease()


    ------------------------------------------------------------------------------------------
    2、 tryAcquireShared()、tryReleaseShared()


        MyLock   ->   lock / tryLock / tryLock(time) / lockInterruptibly

            AQS   ->   acquireShared / tryAcquireSharedNanos / acquireSharedInterruptibly           // 模板方法

                sync   =>   tryAcquireShared()                                                      // 重写方法

        ---------------------------------------
        MyLock   ->   unlock

            AQS   ->   releaseShared

                sync   =>   tryReleaseShared()



    --------------------------------------------------------------------------------
    isHeldExclusively()         // 是否在独占模式下被线程占用  ->  独占模式 + 占用锁资源

        MyLock.isLocked       ->   sync.isHeldExclusively


------------------------------------------------------------------------------------------
Condition

    MyLock.newCondition   ->   sync.newCondition






========================================================================================================================
独占式
========================================================================================================================
acquire         // 获取 同步状态（锁）

    ---------------------------------------------------
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();

    -------------------------------------------------------------------------
    1、调用tryAcquire  ->  获取 同步状态（锁）  ->  成功则return

    2、构建 独占式Node，并加入 同步队列 的尾部

    3、获取当前Node的 前驱结点pred，判断pred 是否为头结点head

        1、是（则当前结点为 老二） -> 再次执行tryAcquire  ->  获取 同步状态（锁）

            获取成功 -> 将当前结点设置为head（头结点） -> 并返回

        2、tryAcquire失败 或 当前结点非二号结点

            通过shouldParkAfterFailedAcquire  ->  判断是否应该阻塞   // 当前Thread是否可以休息

            是 ->  通过parkAndCheckInterrupt 用来阻塞线程


    -------------------------------------------------------------------------
    1、首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节

    2、线程获取同步状态失败，就构造一个结点，加入同步队列中                // CAS - 加入队列过程 要保证线程安全

    3、加入队列中的结点线程进入自旋状态

        1、若为老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态

        2、否则，只有其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒


            ------------------------------------------------------------------------------------------------------------
            若前驱结点waitStatus > 0（CANCELLED = 1）  ->  直接丢弃此前驱结点  ->  继续往前找 -> ... ->  直到前驱结点 waitStatus ≤ 0 为止

                然后将 当前结点p 和 新的有效前驱结点pred 指针相连   // 双向链表

            然后继续自旋（for死循环）

            然后判断pred.waitStatus是否为SIGNAL

                是 -> 当前线程park阻塞

                否 ->  CAS 将pred设置为SIGNAL

            然后继续自旋（for死循环）

                然后判断pred.waitStatus是否为SIGNAL

                    是 -> 当前线程park阻塞



------------------------------------------------------------------------------------------------------------------------
release         // 释放 同步状态

    ------------------------------------------------
    final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0) {
                unparkSuccessor(h);
            }
            return true;
        }
        return false;
    }

    -----------------------------------------------------------------------------------------------
    1、释放锁

    2、唤醒 一个等待线程

        需要找到 头结点的后继结点 进行唤醒

        若后继结点为空或处于CANCEL状态，从链表尾部向前遍历 找寻一个正常的结点，唤醒其对应线程

    -----------------------------------------------------------------------------------------------
    1、调用重写的 tryRelease()     ->  释放 同步状态（锁）    ->  释放失败 返回false     // 释放锁

    2、唤醒 头结点的 后继结点                                                           // 唤醒 一个等待线程

        如果head.next结点为 CANCEL，从链表尾部 向前遍历，找寻一个正常的结点，唤醒其对应线程

    -----------------------------------------------------------------------------------------------
    1、释放锁

    2、唤醒 一个等待线程

        1、优先唤醒 后继结点（head.next）

        2、后继结点为CANCEL（已失效）  ->  从链表尾部 从后往前遍历  ->  取一个 waitStatus <= 0 的结点s

        3、执行唤醒  ->  唤醒结点 的线程      // LockSupport.unpark(s.thread);


------------------------------------------------------------------------------------------------------------------------
tryAcquireNanos

    ----------------------------------------------------------------
    final boolean tryAcquireNanos(int arg, long nanosTimeout) {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);
    }

    ----------------------------------------------------------------
    1、检测线程是否中断   =>  是 -> 抛出异常

    2、先尝试用 常规非阻塞方式 - tryAcquire()，获取一次 同步状态（锁）

    3、尝试获取失败   ->  再走 超时模式   ->   获取 同步状态（锁）

        超时  ->  自旋重试  +  time校验



========================================================================================================================
共享式
========================================================================================================================
acquireShared           // 获取同步状态

    --------------------------------------------
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0) {
            doAcquireShared(arg);
        }
    }

    -----------------------------------------------------------------
    执行 重写的tryAcquireShared()  ->  尝试获取 - 同步状态（锁）

        1、返回值＜0，获取同步状态失败，排队去；

        2、返回值≥0，获取同步状态成功，直接返回           // 去干自己的事儿

    -----------------------------------------------------------------
    doAcquireShared

        大体逻辑与 独占式的acquireQueued差距不大

        只不过由于是共享式，会有多个线程同时获取到资源，也可能同时释放资源，空出很多同步状态

        所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去              //  waitStatus -> PROPAGATE  = -3


------------------------------------------------------------------------------------------------------------------------
releaseShared           // 释放同步状态

    ----------------------------------------------
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

    -----------------------------------------------------------------
    释放同步状态

        共享模式，释放同步状态也是多线程的，采用了CAS自旋来保证安全






========================================================================================================================
CountDownLatch          // 同步工具(非互斥) -> 一次性使用     ==>  1等N  ->  1个队长 等 N个队员      ==>     1个线程等N个线程
========================================================================================================================



场景：

    主线程 等待 所有子线程-任务处理完成后，再往下走

        分10个子线程执行      ->     new CountDownLatch(10)        // 初始化state

        每个子线程 执行完成后  ->     countDown()                   // state - 1

        主线程  ->  await()                                       // 等待所有 子线程执行完    ->  state = 0

------------------------------------------------------------------------------------------------------------------------
使用：
    1、你可以向CountDownLatch对象设置一个初始的数字作为计数值

    2、任何调用这个对象上await()方法 的线程都会被阻塞

    3、直到这个计数器的计数值被其他的线程减为0为止


CountDownLatch

    AQS保证了安全性  ->  countDown()是线程安全的         // CAS



用例：
    有三个工人在为老板干活，当三个工人把活都干完了的时候，老板就来检查。

        唤醒条件：三个工人先全部干完活，老板才检查



------------------------------------------------------------------------------------------------------------------------
CountDownLatch

    1、是一个同步工具类，用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）

    2、能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行

        使用一个计数器进行实现：

            1、计数器初始值为线程的数量

            2、每一个线程完成自己任务后，计数器的值就会减一

            3、当计数器的值为0时，表示所有的线程都已经完成任务，然后在CountDownLatch上等待的线程 就可以恢复执行接下来的任务


------------------------------------------------------------------------------------------------------------------------
CountDownLatch的用法：

    1、某一线程在开始运行前等待n个线程执行完毕

        1、将CountDownLatch的计数器初始化为new CountDownLatch(n)

        2、每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()

        3、当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒

        ------------------------------------
        一个典型应用场景就是

            启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行



    2、实现多个线程开始执行任务的最大并行性

        注意是并行性，不是并发

            强调的是多个线程在某一时刻同时开始执行

            类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑


        做法是初始化一个共享的CountDownLatch(1)

            将其计算器初始化为1

            多个线程在开始执行任务前，首先countDownLatch.await()

            当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒



------------------------------------------------------------------------------------------------------------------------
CountDownLatch

    new CountDownLatch(10)          ->     设置初state始化值


    countDown()     ->      releaseShared                   ->      state - 1           // 释放 state

    getCount()      ->      getState                        ->      state               // 读   state

    await()         ->      state != 0  ->  加入阻塞队列     ->       等待唤醒


------------------------------------------------------------------------------------------------------------------------
new CountDownLatch(10)       设置初state始化值

getCount()                   读取state

----------------------------------------------------------
countDown()

    1、先判断 state == 0
        等于0   ->   不再递减，直接返回 false

        不等于0
            1、state减1，并CAS 更新state
            2、然后判断 state是否已经减为0

    2、state 第一次递减为0时

        唤醒同步队列 中阻塞的Thread           // 唤醒 所有await线程

----------------------------------------------------------
await()

    判读当前state是否为0

        1、等于0，不阻塞

            继续往下执行                              // state = 0  ==>  已经达到唤醒条件  ->  无需阻塞


        2、不等于0，加入同步队列   ->  阻塞当前Thread

            1、阻塞当前Thread  ->   等待条件唤醒

            2、唤醒条件 -> state = 0                 //  执行countDown()  ->  state减为0时，唤醒同步队列中 所有阻塞的Thread


------------------------------------------------------------------------------------------------------------------------
应用：
    1、初始化state

        CountDownLatch cdl = new CountDownLatch(10)      ->   state = 10

    2、申请一个资源

        cdl.countDown()         // 同步状态state -1

    3、获取当前state

        cdl.getCount()          // 获取当前state值

    4、阻塞

        cdl.await()             // 加入同步队列排队  ->  阻塞线程   ==>  等待唤醒  ->  默认唤醒条件：state = 0





========================================================================================================================
CyclicBarrier              // 同步工具 + 重复使用      ->    相互等待  =>  所有人到齐 -> 再开饭        ==>    一组线程相互等待
========================================================================================================================
CyclicBarrier类最主要的功能：
    使 先到达屏障点的线程 阻塞  ->  并等待 后面的线程


其中它提供了两种等待的方法：
    定时等待          await(long timeout, TimeUnit unit)
    非定时等待        await


实现一组线程相互等待的原理：

    1、在CyclicBarrier类的内部有一个计数器

    2、每个线程在到达屏障点的时候  ->  都会调用await()将自己阻塞  ->  此时计数器会减1

    3、当计数器减为0的时候  ->  所有因调用await()而被阻塞的线程将被唤醒


------------------------------------------------------------------------------------------------------------------------
回调函数

    1、由最后一个到达栅栏 的线程执行

    2、先执行 回调函数   ->   再执行 唤醒

    3、可将回调函数  ->  放入线程池 异步执行  ->  提升性能



------------------------------------------------------------------------------------------------------------------------
CyclicBarrier       // 循环栅栏

    栅栏（Barrier） -> 重复使用（Cyclic）


实现：
    基于AQS的 Condition



------------------------------------------------------------------------------------------------------------------------
CyclicBarrier barrier = new CyclicBarrier(int parties, Runnable callback);

    barrierCommand          // 回调函数

        本局结束时要执行的任务（回调任务）     ->  由最后一个到达栅栏的线程执行

    parties
        总线程数             // 总人数


    count           // 计数器count的初始值被设置为parties

        当count减为0时  ->  表示本局游戏结束，需要转到下一局

        在转到下一局游戏之前  ->  会将所有阻塞的线程唤醒

        在唤醒所有线程之前  ->  你可以通过指定barrierCommand来执行自己的任务

----------------------------------------------------------
barrier.await()

    计数器减1  ->  并阻塞线程    // 等待计数器归0  ->  被唤醒

----------------------------------------------------------
Generation

    一局   =>   像玩游戏时 ->  代表的当前局游戏       // 利用它可以实现循环等待   ->   重新开局

------------------
nextGeneration()
    开始下一句

------------------
breakBarrier
    打破栅栏


------------------------------------------------------------------------------------------------------------------------
wait超时
    如果其中有一个线程因为等待超时而退出，那么整盘游戏也会结束，其他线程都会被唤醒

-----------------------------------------------------------
线程醒来后会执行下面三个判断：

    看看是否因为调用breakBarrier方法而被唤醒，如果是则抛出异常；

    看看是否是正常的换代操作而被唤醒，如果是则返回计数器的值；

    看看是否因为超时而被唤醒，如果是的话就调用breakBarrier打破栅栏并抛出异常


------------------------------------------------------------------------------------------------------------------------
使用：

    1、CyclicBarrier barrier = new CyclicBarrier(2, callback);

    2、barrier.await();



    -------------------------------------------------------------------------------------------
    final CyclicBarrier barrier = new CyclicBarrier(2, () -> {
        executor.execute(() -> System.out.println("======人到齐了，开饭吧======"));
    });


    Runnable r1 = () -> {
        System.out.println("----公瑾到了");
        barrier.await();
    };

    Runnable r2 = () -> {
        System.out.println("----子敬到了");
        barrier.await();
    };

    executor.submit(r1);
    executor.submit(r2);




========================================================================================================================
CountDownLatch 和 CyclicBarrier                              // 同步工具   =>   线程间通信    ->    线程间条件依赖
========================================================================================================================
CountDownLatch

    主线程                 ->      await()         ->      等待队员到齐                    // 等待        ->  state = 0

    每个子线程任务完成时     ->      countDown()     ->       等待人数减1                    // countDown  ->  state减1


CyclicBarrier

    每个线程到达屏障时   ->  await()          ->     等待其他人                               // await   ->  state减1

    当state=0          ->  所有人到齐         ->    唤醒所有await()的线程                     // 等待    ->  state = 0


-----------------------------------------------------------
CountDownLatch  1等N

CyclicBarrier   N等N         ->   可实现CountDownLatch的功能



------------------------------------------------------------------------------------------------------------------------
功能：

    这两个类都可以实现一组线程在到达某个条件之前进行等待

    它们内部都有一个计数器，当计数器的值不断的减为0的时候  ->  所有阻塞的线程将会被唤醒


区别：

    CyclicBarrier的计数器由自己控制，而CountDownLatch的计数器则由使用者来控制

        在CyclicBarrier中线程调用await()    ->   不仅会将自己阻塞，还会将计数器减1             // 相互等待（子 ⇄ 相互await ⇄ 子）

        在CountDownLatch中线程调用await()   ->   只是将自己阻塞，  不会减少计数器的值           // 1等N  （主 -await-> N子）



    CountDownLatch只能拦截一轮，而CyclicBarrier可以实现 循环拦截

        一般来说用CyclicBarrier可以实现CountDownLatch的功能，而反之则不能





========================================================================================================================
Semaphore                                                       // 1个信号 -> 互斥锁        N个信号 ->  同步器
========================================================================================================================

使用：

    Semaphore semaphore = new Semaphore(3)      // 初始化N个许可


    semaphore.acquire();                        // 申请许可      =>   成功 / 许可不足 ->  阻塞线程

        申请成功  ->  执行

        申请失败  ->  线程阻塞

    semaphore.release();                         // 归还许可     =>  释放资源  ->  唤醒一个 阻塞线程

        释放1个信号  ->  唤醒1个 阻塞线程


----------------------------------------------------------------------
功能：

    1、有N个许可证   ->   就最多运行 N个线程同时访问

    2、没有Condition  ==>  每次只唤醒1个阻塞线程  // 归还1个 -> 唤醒1个

-----------------------------------------------------------------------
Semaphore（天然支持限流）

    用于限制 可以访问某些资源（物理或逻辑的）的线程数目


他维护了一个许可证集合

    有多少资源需要限制  ->  就初始化多少个许可证


假如这里有N个资源，那就对应于N个许可证，同一时刻也只能有N个线程访问

    一个线程获取许可证  ->  就调用acquire方法

    用完了释放资源      ->  就调用release方法



---------------------------------------------------------------
使用：

    1、初始化 -> 许可证个数

    2、申请许可证     ==>     成功 / 阻塞（许可证为0 -> 已被申请完）

    3、释放许可证     ==>     释放1个 -> 唤醒1个



-----------------------------------------
单个信号  =>   可作为 -> 互斥锁


多个信号  ->   同步器