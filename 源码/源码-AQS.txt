========================================================================================================================
AQS

    volatile int state;     // 共享变量  ->  同步状态


    CLH队列                 // FIFO双端同步队列  ->  基于Node 双向链表   ->   通过内置的FIFO队列 来完成 获取资源、线程排队

        1、FIFO双端同步队列   ->   公平队列                                    // CLH  =>  Craig Landin Hagersten -> 人名

        2、基于Node 双向链表


------------------------------------------------------------------------------------------------------------------------
Node

    static final Node SHARED = new Node();          // 共享式  Node模式标识   ->   new Node()
    static final Node EXCLUSIVE = null;             // 独占式  Node模型标识   ->   null


    volatile  Node prev
    volatile  Node next


    volatile  Thread thread          // 与当前Node 关联的 排队中的Thread



    volatile int waitStatus = 0         // 等待状态  ->  初始值 0

        CANCELLED  =  1      ->      线程已失效                                      // 等待超时或者被中断

        SIGNAL     = -1      ->      后继线程需要被唤醒（unpaking）                   // head.next结点 需要被唤醒

        CONDITION  = -2      ->      结点线程等待在Condition队列上                    // 用于Lock.Condition  ->  条件变量  ->  当被signal后  =>  会从  等待队列（Condition队列） -> 同步队列

        PROPAGATE  = -3      ->      下一次共享式同步状态  会被无条件地传播下去        // 共享式   ->  若还有可用资源，传播下去，也就是继续唤醒后继结点



========================================================================================================================
对于独占式同步组件

    1、同一时刻只有一个线程 能获取到同步状态     ->   其他线程都得去排队等待

    2、待重写的 尝试获取同步状态（锁）的方法     ->   tryAcquire() 的返回值为       boolean



对于共享式同步组件

    1、同一时刻可以有多个线程 同时获取到同步状态，这也是“共享”的意义所在

    2、待重写的 尝试获取同步状态（锁）的方法     ->   tryAcquireShared() 的返回值为  int


        1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取

    　　2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了

    　　3.当返回值小于0时，表示获取同步状态失败




========================================================================================================================
AQS是JUC中很多同步组件的构建基础

    它内部实现主要是：

        1、状态变量state

        2、一个FIFO队列


    同步队列的 head结点  ->  当前获取到同步状态 的结点


    获取同步状态state失败的线程

        1、会被构造成一个结点         // 共享式/独占式

        2、加入到同步队列尾部         // 采用自旋CAS来保证此操作的线程安全

        3、随后线程会阻塞


    释放时

        唤醒 head结点的后继结点，使其加入对同步状态的争夺中



------------------------------------------------------------------------------------------------------------------------
AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时

    只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可

    至于背后复杂的 线程排队、线程阻塞/唤醒、如何保证线程安全，都由AQS为我们完成了



这也是非常典型的模板方法的应用

    AQS定义好顶级逻辑的骨架

    并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，

    将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现





========================================================================================================================
AQS

    待重写方法 -> 空实现                       // throw new UnsupportedOperationException()   ->   子类 按模式选择性实现


        tryAcquire()                           // 独占式获取同步状态，试着获取，成功返回true，反之为false
        tryRelease()                           // 独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态；


        tryAcquireShared()                     // 共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败；
        tryReleaseShared()                     // 共享式释放同步状态，成功为true，失败为false


        isHeldExclusively()                    // 是否在独占模式下被线程占用


    Condition



========================================================================================================================
独占锁

    实现  ->  tryAcquire()、tryRelease()

共享锁

    实现  ->  tryAcquireShared()、tryReleaseShared()




========================================================================================================================
自定义同步器  ->  AQS模板方法  ->  重写方法

    ------------------------------------------------------------------------------------------
    1、 tryAcquire()、tryRelease()


        MyLock   ->   lock / tryLock / tryLock(time) / lockInterruptibly

            AQS   ->   acquire / tryAcquireNanos / acquireInterruptibly         // 模板方法

                sync   =>   tryAcquire()                                        // 重写方法

        ---------------------------------------
        MyLock   ->   unlock

            AQS   ->   release

                sync   =>   tryRelease()


    ------------------------------------------------------------------------------------------
    2、 tryAcquireShared()、tryReleaseShared()


        MyLock   ->   lock / tryLock / tryLock(time) / lockInterruptibly

            AQS   ->   acquireShared / tryAcquireSharedNanos / acquireSharedInterruptibly           // 模板方法

                sync   =>   tryAcquireShared()                                                      // 重写方法

        ---------------------------------------
        MyLock   ->   unlock

            AQS   ->   releaseShared

                sync   =>   tryReleaseShared()



    --------------------------------------------------------------------------------
    isHeldExclusively()         // 是否在独占模式下被线程占用  ->  独占模式 + 占用锁资源

        MyLock.isLocked       ->   sync.isHeldExclusively


------------------------------------------------------------------------------------------
Condition

    MyLock.newCondition   ->   sync.newCondition






========================================================================================================================
独占式
========================================================================================================================
acquire         // 获取 同步状态（锁）

    ---------------------------------------------------
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();

    -------------------------------------------------------------------------
    1、调用tryAcquire  ->  获取 同步状态（锁）  ->  成功则return

    2、构建 独占式Node，并加入 同步队列 的尾部

    3、获取当前Node的 前驱结点pred，判断pred 是否为头结点head

        1、是（则当前结点为 老二） -> 再次执行tryAcquire  ->  获取 同步状态（锁）

            获取成功 -> 将当前结点设置为head（头结点） -> 并返回

        2、tryAcquire失败 或 当前结点非二号结点

            通过shouldParkAfterFailedAcquire  ->  判断是否应该阻塞   // 当前Thread是否可以休息

            是 ->  通过parkAndCheckInterrupt 用来阻塞线程


    -------------------------------------------------------------------------
    1、首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节

    2、线程获取同步状态失败，就构造一个结点，加入同步队列中                // CAS - 加入队列过程 要保证线程安全

    3、加入队列中的结点线程进入自旋状态

        1、若为老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态

        2、否则，只有其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒


            ------------------------------------------------------------------------------------------------------------
            若前驱结点waitStatus > 0（CANCELLED = 1）  ->  直接丢弃此前驱结点  ->  继续往前找 -> ... ->  直到前驱结点 waitStatus <= 0 为止

                然后将 当前结点p 和 新的有效前驱结点pred 指针相连   // 双向链表

            然后继续自旋（for死循环）

            然后判断pred.waitStatus是否为SIGNAL

                是 -> 当前线程park阻塞

                否 ->  CAS 将pred设置为SIGNAL

            然后继续自旋（for死循环）

                然后判断pred.waitStatus是否为SIGNAL

                    是 -> 当前线程park阻塞



------------------------------------------------------------------------------------------------------------------------
release         // 释放 同步状态

    ------------------------------------------------
    final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0) {
                unparkSuccessor(h);
            }
            return true;
        }
        return false;
    }

    -----------------------------------------------------------------------------------------------
    1、释放锁

    2、唤醒 一个等待线程

        需要找到 头结点的后继结点 进行唤醒

        若后继结点为空或处于CANCEL状态，从链表尾部向前遍历 找寻一个正常的结点，唤醒其对应线程

    -----------------------------------------------------------------------------------------------
    1、调用重写的 tryRelease()     ->  释放 同步状态（锁）    ->  释放失败 返回false     // 释放锁

    2、唤醒 头结点的 后继结点                                                           // 唤醒 一个等待线程

        如果head.next结点为 CANCEL，从链表尾部 向前遍历，找寻一个正常的结点，唤醒其对应线程

    -----------------------------------------------------------------------------------------------
    1、释放锁

    2、唤醒 一个等待线程

        1、优先唤醒 后继结点（head.next）

        2、后继结点为CANCEL（已失效）  ->  从链表尾部 从后往前遍历  ->  取一个 waitStatus <= 0 的结点s

        3、执行唤醒  ->  唤醒结点 的线程      // LockSupport.unpark(s.thread);


------------------------------------------------------------------------------------------------------------------------
tryAcquireNanos

    ----------------------------------------------------------------
    final boolean tryAcquireNanos(int arg, long nanosTimeout) {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);
    }

    ----------------------------------------------------------------
    1、检测线程是否中断   =>  是 -> 抛出异常

    2、先尝试用 常规非阻塞方式 - tryAcquire()，获取一次 同步状态（锁）

    3、尝试获取失败   ->  再走 超时模式   ->   获取 同步状态（锁）

        超时  ->  自旋重试  +  time校验



========================================================================================================================
共享式
========================================================================================================================
acquireShared           // 获取同步状态

    --------------------------------------------
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0) {
            doAcquireShared(arg);
        }
    }

    -----------------------------------------------------------------
    执行 重写的tryAcquireShared()  ->  尝试获取 - 同步状态（锁）

        1、返回值＜0，获取同步状态失败，排队去；

        2、返回值≥0，获取同步状态成功，直接返回           // 去干自己的事儿

    -----------------------------------------------------------------
    doAcquireShared

        大体逻辑与 独占式的acquireQueued差距不大

        只不过由于是共享式，会有多个线程同时获取到资源，也可能同时释放资源，空出很多同步状态

        所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去              //  waitStatus -> PROPAGATE  = -3


------------------------------------------------------------------------------------------------------------------------
releaseShared           // 释放同步状态

    ----------------------------------------------
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

    -----------------------------------------------------------------
    释放同步状态

        共享模式，释放同步状态也是多线程的，采用了CAS自旋来保证安全



